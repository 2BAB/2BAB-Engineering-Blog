{
    "version": "https://jsonfeed.org/version/1",
    "title": "2BAB's Engineering Blog",
    "home_page_url": "https://2bab.me//",
    "feed_url": "https://2bab.me//feed.json",
    "description": "2BAB's Engineering Blog",
    "icon": "https://2bab.me//apple-touch-icon.png",
    "favicon": "https://2bab.me//favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "2BAB",
        "url": "https://2bab.me/",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://2bab.me//2023/05/05/kotlin-for-gradle",
            "title": "Kotlin 成为 Gradle 默认语言！如何快速上手？KOGE 小册来帮忙！",
            "summary": null,
            "content_text": "自 4 月中 Kotlin Conf 上宣布了这条消息：“Kotlin DSL 现在成为新 Gradle 构建的默认设置”，不少 Android 技术群就热烈地在转发/讨论相关消息。  “Compose 只用 Kotlin，现在连 Gradle 也默认用 Kotlin 了！”  “Kotlin DSL 是什么？我 Groovy 已经学不过来了，原来写个构建脚本还可以用 Kotlin 吗？”  …（能让三家公司一起发新闻稿，说明这事…真的稳！！！）没错，Kotlin 其实在 2016 就被引入了 Gradle 的构建工具中。并且，历经多年的集成和调优，终于在今年成为所有开发者的默认选项。只要你打开最新版的 Android Studio/IntelliJ IDEA，选择新建项目即可看到如下的提示：IDE 将为开发者默认创建 Kotlin DSL (buidl.gradle.kts) 的相关脚本。Gradle Kotlin DSL 带来的好处有：  编译时检查。  更好的 IDE 体验，包括自动补全，源代码导航，重构等。  简化的声明式插件语法。  丰富的 Kotlin 社区支持。尤其第二点，“自动补全”是过去使用 Groovy DSL 编写 Gradle 脚本的一大痛点，现在 Kotlin 为我们解决了这个问题。而作为 Android 开发者的我，也十分享受一门语言带来的统一体验（App 主体开发和构建工具开发）。不过，虽然 Kotlin 和 Gradle 大家都不陌生，但是二者的结合却对很多 Android 开发者有些新奇。如何能快速上手 Gradle Kotlin DSL？甚至借这次千载难逢的机会，补足以前难以上手 Gradle 的遗憾？有请 KOGE 小册！（点击链接即可阅读，开源项目）KOGE 是 Kotlin-oriented Gradle Essentials 的缩写，顾名思义是面向 Kotlin 的 Gradle 基础手册。我们按照合理的先后顺序，列出新手最困惑的概念，再从一些互联网上已有的问题、源码、示例项目中去学习。它不是 “Awesome Gradle” 的项目收藏夹，而是一份大纲，一本简练的自学手册。 手册选择了 Kotlin 作为介绍 DSL 脚本和插件开发的语言，链接和用例以 Android 构建场景为主。另外，“基础”的定义范围十分明确，它覆盖了下方第 1 点和部分第 2 点中的内容（源自我之前的一个问卷调查）。重点解决理解脚本、编写脚本，和常见 Gradle 工程化实践。      “仅基础使用”（初级）：我能读懂、修改 build.gradle(.kts)，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；    “实现高效自动化、工程化”（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 buildSrc 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；    “编译构建增强”（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；    …每个基础内容点都大致按如下四个步骤组织：  它是什么？  它能用来做什么？  它的自学要点？  主体内容，重点文档/文章链接、摘要、代码、运行结果等。手册目前涵盖了 2 大部分，共 10 个章节，涉及了新手上路的方方面面。虽然有不少链接内容是英文，但详细的知识点阐述、代码实战其实都在这些链接的文章、文档中，有困难的朋友也可借助一些翻译工具进行学习。！！！再放一次在线阅读地址：KOGE ！！！想参与手册编辑，请访问 KOGE 的 Github 仓库。觉得这个项目好的朋友也欢迎点个 Github Star，并分享给你的同事朋友。欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p>自 4 月中 Kotlin Conf 上宣布了这条消息：“Kotlin DSL 现在成为新 Gradle 构建的默认设置”，不少 Android 技术群就热烈地在转发/讨论相关消息。</p><ul>  <li>“Compose 只用 Kotlin，现在连 Gradle 也默认用 Kotlin 了！”</li>  <li>“Kotlin DSL 是什么？我 Groovy 已经学不过来了，原来写个构建脚本还可以用 Kotlin 吗？”</li>  <li>…</li></ul><p><img src=\"https://2bab-images.lastmayday.com/kotlin-is-the%20-default-lang-of-gradle-banner.png?imageslim\" alt=\"\" /></p><p><strong>（能让三家公司一起发新闻稿，说明这事…真的稳！！！）</strong></p><p>没错，Kotlin 其实在 2016 就被引入了 Gradle 的构建工具中。并且，历经多年的集成和调优，终于在今年成为所有开发者的默认选项。只要你打开最新版的 Android Studio/IntelliJ IDEA，选择新建项目即可看到如下的提示：</p><p><img src=\"https://2bab-images.lastmayday.com/20230505191241.png?imageslim\" alt=\"\" /></p><p>IDE 将为开发者默认创建 <code class=\"language-plaintext highlighter-rouge\">Kotlin DSL (buidl.gradle.kts)</code> 的相关脚本。</p><p>Gradle Kotlin DSL 带来的好处有：</p><ol>  <li>编译时检查。</li>  <li>更好的 IDE 体验，包括自动补全，源代码导航，重构等。</li>  <li>简化的声明式插件语法。</li>  <li>丰富的 Kotlin 社区支持。</li></ol><p>尤其第二点，“自动补全”是过去使用 Groovy DSL 编写 Gradle 脚本的一大痛点，现在 Kotlin 为我们解决了这个问题。而作为 Android 开发者的我，也十分享受一门语言带来的统一体验（App 主体开发和构建工具开发）。</p><p>不过，虽然 Kotlin 和 Gradle 大家都不陌生，但是二者的结合却对很多 Android 开发者有些新奇。<strong>如何能快速上手 Gradle Kotlin DSL？甚至借这次千载难逢的机会，补足以前难以上手 Gradle 的遗憾？有请 <a href=\"https://koge.2bab.me/#/zh-cn/\">KOGE</a> 小册！（点击链接即可阅读，开源项目）</strong></p><p><img src=\"https://2bab-images.lastmayday.com/koge-book-cover.png?imageslim\" alt=\"\" /></p><p><strong>KOGE 是 Kotlin-oriented Gradle Essentials 的缩写，顾名思义是面向 Kotlin 的 Gradle 基础手册</strong>。我们按照合理的先后顺序，列出新手最困惑的概念，再从一些互联网上已有的问题、源码、示例项目中去学习。它不是 “Awesome Gradle” 的项目收藏夹，<strong>而是一份大纲，一本简练的自学手册。</strong> 手册选择了 <strong>Kotlin</strong> 作为介绍 DSL 脚本和插件开发的语言，链接和用例以 <strong>Android</strong> 构建场景为主。</p><p>另外，“基础”的定义范围十分明确，它覆盖了下方第 1 点和部分第 2 点中的内容（源自我之前的一个<a href=\"https://mp.weixin.qq.com/s/TmHYKMU1KYOTdN_ytZNWZA\">问卷调查</a>）。重点解决<strong>理解脚本、编写脚本，和常见 Gradle 工程化实践。</strong></p><blockquote>  <ol>    <li>“仅基础使用”（初级）：我能读懂、修改 build.gradle(.kts)，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；</li>    <li>“实现高效自动化、工程化”（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 buildSrc 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；</li>    <li>“编译构建增强”（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；</li>  </ol>  <p>…</p></blockquote><p>每个基础内容点都大致按如下四个步骤组织：</p><ol>  <li>它是什么？</li>  <li>它能用来做什么？</li>  <li>它的自学要点？</li>  <li>主体内容，重点文档/文章链接、摘要、代码、运行结果等。</li></ol><p><img src=\"https://2bab-images.lastmayday.com/20230505193725.png?imageslim\" alt=\"\" /></p><p>手册目前涵盖了 2 大部分，共 10 个章节，涉及了新手上路的方方面面。虽然有不少链接内容是英文，但详细的知识点阐述、代码实战其实都在这些链接的文章、文档中，有困难的朋友也可借助一些翻译工具进行学习。</p><p>！！！再放一次在线阅读地址：<a href=\"https://koge.2bab.me/#/zh-cn/\">KOGE</a> ！！！</p><p>想参与手册编辑，请访问 KOGE 的 <a href=\"https://github.com/2BAB/KOGE\">Github 仓库</a>。觉得这个项目好的朋友也欢迎点个 Github Star，并分享给你的同事朋友。</p><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2023/05/05/kotlin-for-gradle",
            
            
            
            "tags": ["Gradle","Kotlin","Android Gradle Plugin"],
            
            "date_published": "2023-05-05T00:00:00+00:00",
            "date_modified": "2023-05-05T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2023/04/15/kotlin-conf-23-exp",
            "title": "KotlinConf 2023 参会体验",
            "summary": null,
            "content_text": "刚刚结束了 KotlinConf 2023 的旅程，心潮澎湃，趁余温尚在，记录下我的所见所闻。短短两天内，我获得了大量从未有过的人生体验。大会的议程安排，展位设置，高质量的参会人员和内容分享，甚至包括餐食、咖啡、Party 乐队等周边配套都是一级水平。注：这是一篇手机上编写的速记，格式编排等难免有些问题，望见谅。​会场今年是 KotlinConf 第二次在荷兰阿姆斯特丹举办，上一次是疫情前。地点在 Beurs van Berlage，是当地的历史建筑，翻新装修后现在成为会议租借的场地。​混合历史与现代的主会场，承载了厚实的内容与记忆。不少从其他国家来的人纷纷表示这是最美的会场，最好吃的食物。当然，既然是在欧洲举办，大部分现场的观众，包括展台的工作人员很多也是欧洲本土过来的，例如英国法国德国捷克比利时意大利等等。剩下一部分感觉有北美过来的，以及少数亚非拉的。综合来看，现场其实有各种各样的语言在交流，而大部分人不是 English Native Speaker，一起聊天讲英语时彼此压力都不大。​议程Kotlin 语言自然是会议的主题，但 Kotlin 生态发展到今天，已远不止传统 JVM 的内容。我们会看到 Android，Backend，Multiplatform，Infrastructure &amp; Tools，QA 和自动化等等主题。除了每天早上的  Opening Keynotes，其余时间都是有五六场活动并轨的情况，你需要在多个 Session 之间做出选择——这实际上是一件好事，因为会议质量的判断是极其主观的。主题分享找对了听众，听众找到最对自己胃口的内容，才能发挥出最佳的化学反应。（部分收藏的主题）例如我选择的多是 Kotlin Multiplatform、Kotlin Compiler、Compose for iOS 以及生态工具相关的主题，偏新奇或硬核向。这次在现场听分享，最重要两点体会是：  老生常谈，你可以和 speaker 在结束后畅谈更多问题。例如我听完 K2 Compiler Plugins 后私下和 Mikhail 又聊了一会儿，其中他解释了“文档已释出”主要指 API doc，而不是 Tutorial doc，然后现场打开 Kotlin 源码翻了翻，一起看看刚刚他讲的公开接口都在哪里，代码规范、注释清晰，那后续生成的文档自然就不错。配合上这次的分享视频，以及官方的几个真实案例，相信 KCP 在 K2 的加持下会衍生出更多社区生态。  前面提到并轨的分享已经把人群分流了，因此你在这个分会场见到的人一定是十分契合这个主题的。同样以 K2 Compiler Plugins 为例，虽主题小众、分会场也不大，Speaker 做调研时问有多少人写过 Compiler Plugin，竟然有 3-4 成的人举手，到提问环节也有四五个人举手。因此这个小屋子内有非常多值得认识的新朋友，可以抓住机会！​线下社交延续上一段的分享，我作为最后一个提问者，由于英语水平有限表达较为啰嗦，演讲者听着有些困惑——于是我们结束了这个环节，待他下场后在旁边又和其他几位开发者，一起探讨了 K2 的 KCP 计划取消 Gradle SubPlugin 的设定有哪些利弊。其中结识了一位比利时的年轻小哥，应届毕业没多久，聊起这些话题却已经十分老练，在回主会场的路上顺利和他交换了联系方式。紧接着，detekt 的那场则又认识了两位相见恨晚的朋友，Nicola 和 Chao，来自 detekt 的主要维护团队。我和 Chao 甚至在短短认识一小时后就一起去参与了 Kotlin 炉边漫谈的录制。（Nicola，Chao，我，圣佑）除了从分会场的人脉延伸，我还从第一天早饭时间起就马不停蹄地在大厅或者休息室找人唠嗑。事实上，你甚至可以牺牲一点点听分享的时间，来参与到这个一年一度的面基时刻。比如今天实在听了太多场，那剩下的一小时分享就留着等回放上线后再看吧！上图几位既是行业里的专家，也是 fo 他们了多年的单向网友，后两位还是搭档做分享的嘉宾。由于社交媒体都是放的真人头像，一到现场很容易就能认出。拿杯水，凑过去，先听听别人在聊什么，再慢慢打招呼，互相介绍了解更多。比如我刚开始听到的话题有：Maven Central 发布流程繁琐，骑车从巴黎去阿姆斯特丹的经历，做的 side project 等等。后续第二第三次碰面深入聊聊时，就可以探讨更多，例如职业规划，技术问题。（我的 E-ink 手机让很多人驻足围观 / 打开话题）第三种搭讪的方式就是直接去 Booth，比如 Google 的分享会后，Jeffrey 带我去了 Google 的展台。​在那里他介绍认识了 Ivan。Ivan 是 AS &amp; AGP 等工具的开发者之一，解答了大量我对目前 API 设计，版本更迭，Bug 提交和修复的一些疑惑，最重要的是现场帮我看了我写的书的英文目录，探讨后他给了多个实用的建议。之后我又在 Google 这见到 Marton，他是 Android Worldwide 大会的组织者之一，当时我去当讲师时就曾有过线上交流。而最近他整理和发布了不少 KSP 与 Android 开发的资讯（如上图），因此我们现场还一起找出了之前我那期 KSP 分享的视频（由于分享标题忘记了，我们找了一两分钟，差点尬住）。还有 Florina 等布道师也在现场，时间有限就仅仅是打打招呼，互相分享下在从事哪方面工作等。​展台通常会有很多周边，这里分享一部分我拿到的贴纸，Pinner 等周边。后续我希望在其他活动上，分享给本地的开发者，传递 KotlinConf 的盛况和热情给大家。当然，这里也有 Kotlin 的展台及周边，还有他们的工作人员、工程师等等。特别感谢圣佑带我认识了更多的 JetBrains 的朋友，还一起参加晚上的 Party，和几个德国的小伙伴拍照留念，大家畅聊了近一小时。更多和圣佑的对话请关注 Kotlin 的官方公众号，以及 Kotlin 炉边漫谈 播客！最后的彩蛋是——和 Jake Wharton 的合影： (YOU KNOW WHO)其他​我之前参加过的线下会议不多，早几年在大陆参加过一些 GDG 的活动，18 19 22 年在新加坡参加过几场 Google 和 DroidCon 的活动。从我和现场朋友们对技术会议的探讨回顾中，这次的 KotlinConf 依然是在众多会议中可圈可点的一个。与全世界同行业最有趣的人交流，认识新的朋友，在一个轻松的氛围下汲取新知、产生灵感。经历过 Covid-19 我想大家更加珍惜能面对面谈话的机会，而如果我没有提前一年订下这次的早鸟票，也一定会后悔。明年，再相见！",
            "content_html": "<p>刚刚结束了 KotlinConf 2023 的旅程，心潮澎湃，趁余温尚在，记录下我的所见所闻。短短两天内，我获得了大量从未有过的人生体验。大会的议程安排，展位设置，高质量的参会人员和内容分享，甚至包括餐食、咖啡、Party 乐队等周边配套都是一级水平。</p><p>注：这是一篇手机上编写的速记，格式编排等难免有些问题，望见谅。</p><h2 id=\"会场\">​会场</h2><p>今年是 KotlinConf 第二次在荷兰阿姆斯特丹举办，上一次是疫情前。地点在 Beurs van Berlage，是当地的历史建筑，翻新装修后现在成为会议租借的场地。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-01.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-02.jpg?imageslim\" alt=\"\" /></p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-03.jpg?imageslim\" alt=\"\" /></p><p>​混合历史与现代的主会场，承载了厚实的内容与记忆。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-04.jpg?imageslim\" alt=\"\" /></p><p>不少从其他国家来的人纷纷表示这是最美的会场，最好吃的食物。当然，既然是在欧洲举办，大部分现场的观众，包括展台的工作人员很多也是欧洲本土过来的，例如英国法国德国捷克比利时意大利等等。剩下一部分感觉有北美过来的，以及少数亚非拉的。综合来看，现场其实有各种各样的语言在交流，而大部分人不是 English Native Speaker，一起聊天讲英语时彼此压力都不大。</p><h2 id=\"议程\">​议程</h2><p>Kotlin 语言自然是会议的主题，但 Kotlin 生态发展到今天，已远不止传统 JVM 的内容。我们会看到 Android，Backend，Multiplatform，Infrastructure &amp; Tools，QA 和自动化等等主题。除了每天早上的  Opening Keynotes，其余时间都是有五六场活动并轨的情况，你需要在多个 Session 之间做出选择——这实际上是一件好事，因为会议质量的判断是极其主观的。主题分享找对了听众，听众找到最对自己胃口的内容，才能发挥出最佳的化学反应。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-05.png?imageslim\" alt=\"\" /></p><p>（部分收藏的主题）</p><p>例如我选择的多是 Kotlin Multiplatform、Kotlin Compiler、Compose for iOS 以及生态工具相关的主题，偏新奇或硬核向。</p><p>这次在现场听分享，最重要两点体会是：</p><ol>  <li>老生常谈，你可以和 speaker 在结束后畅谈更多问题。例如我听完 K2 Compiler Plugins 后私下和 Mikhail 又聊了一会儿，其中他解释了“文档已释出”主要指 API doc，而不是 Tutorial doc，然后现场打开 Kotlin 源码翻了翻，一起看看刚刚他讲的公开接口都在哪里，代码规范、注释清晰，那后续生成的文档自然就不错。配合上这次的分享视频，以及官方的几个真实案例，相信 KCP 在 K2 的加持下会衍生出更多社区生态。</li></ol><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-06.png?imageslim\" alt=\"\" /></p><ol>  <li>前面提到并轨的分享已经把人群分流了，因此你在这个分会场见到的人一定是十分契合这个主题的。同样以 K2 Compiler Plugins 为例，虽主题小众、分会场也不大，Speaker 做调研时问有多少人写过 Compiler Plugin，竟然有 3-4 成的人举手，到提问环节也有四五个人举手。因此这个小屋子内有非常多值得认识的新朋友，可以抓住机会！</li></ol><h2 id=\"线下社交\">​线下社交</h2><p>延续上一段的分享，我作为最后一个提问者，由于英语水平有限表达较为啰嗦，演讲者听着有些困惑——于是我们结束了这个环节，待他下场后在旁边又和其他几位开发者，一起探讨了 K2 的 KCP 计划取消 Gradle SubPlugin 的设定有哪些利弊。其中结识了一位比利时的年轻小哥，应届毕业没多久，聊起这些话题却已经十分老练，在回主会场的路上顺利和他交换了联系方式。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-07.jpg?imageslim\" alt=\"\" /></p><p>紧接着，detekt 的那场则又认识了两位相见恨晚的朋友，Nicola 和 Chao，来自 detekt 的主要维护团队。我和 Chao 甚至在短短认识一小时后就一起去参与了 Kotlin 炉边漫谈的录制。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-08.jpg?imageslim\" alt=\"\" />（Nicola，Chao，我，圣佑）</p><p>除了从分会场的人脉延伸，我还从第一天早饭时间起就马不停蹄地在大厅或者休息室找人唠嗑。事实上，你甚至可以牺牲一点点听分享的时间，来参与到这个一年一度的面基时刻。比如今天实在听了太多场，那剩下的一小时分享就留着等回放上线后再看吧！</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-09.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-10.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-12-1.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-11.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-13.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-14.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-14-1.png?imageslim\" alt=\"\" />上图几位既是行业里的专家，也是 fo 他们了多年的单向网友，后两位还是搭档做分享的嘉宾。由于社交媒体都是放的真人头像，一到现场很容易就能认出。拿杯水，凑过去，先听听别人在聊什么，再慢慢打招呼，互相介绍了解更多。比如我刚开始听到的话题有：Maven Central 发布流程繁琐，骑车从巴黎去阿姆斯特丹的经历，做的 side project 等等。后续第二第三次碰面深入聊聊时，就可以探讨更多，例如职业规划，技术问题。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-15.jpg?imageslim\" alt=\"\" />（我的 E-ink 手机让很多人驻足围观 / 打开话题）</p><p>第三种搭讪的方式就是直接去 Booth，比如 Google 的分享会后，Jeffrey 带我去了 Google 的展台。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-16.png?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-17.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-18.png?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-19.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-20.png?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-21.png?imageslim\" alt=\"\" />​在那里他介绍认识了 Ivan。Ivan 是 AS &amp; AGP 等工具的开发者之一，解答了大量我对目前 API 设计，版本更迭，Bug 提交和修复的一些疑惑，最重要的是现场帮我看了我写的书的英文目录，探讨后他给了多个实用的建议。</p><p>之后我又在 Google 这见到 Marton，他是 Android Worldwide 大会的组织者之一，当时我去当讲师时就曾有过线上交流。而最近他整理和发布了不少 KSP 与 Android 开发的资讯（如上图），因此我们现场还一起找出了之前我那期 KSP 分享的视频（由于分享标题忘记了，我们找了一两分钟，差点尬住）。</p><p>还有 Florina 等布道师也在现场，时间有限就仅仅是打打招呼，互相分享下在从事哪方面工作等。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-22.jpg?imageslim\" alt=\"\" />​展台通常会有很多周边，这里分享一部分我拿到的贴纸，Pinner 等周边。后续我希望在其他活动上，分享给本地的开发者，传递 KotlinConf 的盛况和热情给大家。当然，这里也有 Kotlin 的展台及周边，还有他们的工作人员、工程师等等。</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-23.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-24.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-25.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-26.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-27.jpg?imageslim\" alt=\"\" /></p><p>特别感谢圣佑带我认识了更多的 JetBrains 的朋友，还一起参加晚上的 Party，和几个德国的小伙伴拍照留念，大家畅聊了近一小时。更多和圣佑的对话请关注 Kotlin 的官方公众号，以及 Kotlin 炉边漫谈 播客！</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-28.jpg?imageslim\" alt=\"\" />最后的彩蛋是——和 Jake Wharton 的合影：</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-29.jpg?imageslim\" alt=\"\" /> (YOU KNOW WHO)</p><h2 id=\"其他\">其他</h2><p>​我之前参加过的线下会议不多，早几年在大陆参加过一些 GDG 的活动，18 19 22 年在新加坡参加过几场 Google 和 DroidCon 的活动。从我和现场朋友们对技术会议的探讨回顾中，这次的 KotlinConf 依然是在众多会议中可圈可点的一个。</p><p>与全世界同行业最有趣的人交流，认识新的朋友，在一个轻松的氛围下汲取新知、产生灵感。经历过 Covid-19 我想大家更加珍惜能面对面谈话的机会，而如果我没有提前一年订下这次的早鸟票，也一定会后悔。</p><p>明年，再相见！</p><p><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-30.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-31.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/kt-conf-23-32.jpg?imageslim\" alt=\"\" /></p>",
            "url": "https://2bab.me//2023/04/15/kotlin-conf-23-exp",
            
            
            
            
            
            "date_published": "2023-04-15T00:00:00+00:00",
            "date_modified": "2023-04-15T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/12/21/enable-feature-by-variant",
            "title": "构建指北 #12 根据 Variant 决定是否启用插件",
            "summary": null,
            "content_text": "在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。这个问题的根本原因在于 Variant（buildType + flavor) 不是一个 Gradle 概念，而是源于 Android Gralde Plugin（AGP）的多渠道配置。所以从 Gradle 平台的角度很难向上提供便捷的支持：一个工程内的插件引入是全局的、平台性的，不以某一个插件的意志（AGP）而改变下层平台的机制。OK，但我们的问题还是要解决的，所以便了有下面四种问题的解法（大雾。我们按照无效到高效的顺序一一解释其中的思路。根据 Variant 去 apply 插件（无效 XflavorDimensions += \"server\"productFlavors {    ...    create(\"production\") {        dimension = \"server\"        applicationIdSuffix = \".production\"        versionNameSuffix = \"-production\"        versionCode = 2        apply(\"xxx\") // 无效    }}很多 Android 或者 Gradle 的初学者会觉得，我把 apply(...) 放在这里不就好了？（当然，你肯定不能用 plugins { id(\"xxx\") }）这里的误区在于，apply(...) 方法和当前上下文对象并没有关联：  create(\"...\"){} 的闭包上下文是 this:ApplicationProductFlavor。  apply(...) 则为挂载于 PluginAware 的一个扩展方法（以 build.gradle.kts），作用于整个 Project，这样一来你的插件还是会被全局引入。同样的经典误区：create(\"production\") {    dimension = \"server\"    applicationIdSuffix = \".production\"    versionNameSuffix = \"-production\"    versionCode = 2    packagingOptions {        jniLibs {            excludes.add(\"...\")        }    }}你可能觉得这样可以为这个 flavor 设置单独的 packageingOptions，但实际上这个方法是 CommonExtension 接口的一个方法，并不属于 ApplicationProductFlavor。也即它是为整个 Android Gradle Plugin 进行设置，而不是单一 flavor，如果你在每个 flavor 中都进行不同的设置，最后一次的设置会覆盖前面所有的。针对这个问题的解决方法，可参考我之前 GDG 分享中的“二次配置”部分。根据命令去 apply 插件（部分有效 X我们本次讨论的问题在一些 StackOverflow 问答中也能查到，其中有大量的答案是关于“解析键入的命令”来进行判断。if (gradle.startParameter.taskRequests.toString().contains(\"production\")) {    apply(...)}这种做法能够解决你输入的命令为 ./gradlew clean assembleProductionRelease 等等的情况，因为这类命令中仅包含了一个 Variant 的信息（也就是 Production + Release）。然而如果输入的命令是 ./gradlew clean assembleRelease，它同时打包 Staging 和 Production 两个 flavors，这时上面的 if(...) 条件就完全不成立，你的构建也会因此遭到破坏。多数情况 taskRequests 下对第三方 Android 构建插件的开发者都是不应去获取和使用的，和第一条误区一样它是 Gradle 平台自身的 API，没有为上层 AGP 的 Variant 概念做优化。禁用对应 Variant 的插件 Task（有效 Y当然，SO 上也有人提到了正确、有效、且通用的做法——不要动态禁用（或开启）插件，而是去禁用插件内的 Task。plugins { id(\"com.example.ua\") }// or apply(\"com.example.ua\")...tasks.whenTaskAdded {    if (name.contains(\"production\", true)            &amp;&amp; name.contains(\"release\", true)            &amp;&amp; name.contains(\"UploadArchive\", true)) {        enabled = false    }}假设有一个上传构建结果的插件叫做 com.example.ua，我们不管什么情况，都在build.gradle.kts 内引用它。但是往下看，我们基于 whenTaskAdded {...} 做了类似上一条误区的 if(...) 判断，然后符合条件的 task 的 enabled 属性设置为 false。为什么上一个方法不行，而这个可以？我们要复习下这条 Gradle 脚本和 android{} DSL 规则：不管你 shell 键入的命令是什么，你键入的是 clean 也好 help 也好，这份脚本都是会完整地被执行，所有 Variant 的 Task 都会被注册（当然现在通常都是惰性注册了 register(...) 而不用 create()）。而 whenTaskAdded{...} 是 Gradle 平台的 API，它才不管你上层注册的 Task 分不分 Variant，它只管把所有注册后且确定会添加进运行图（是个有向无环图 DAG）的 Task 在这里提供一个回调的时机给开发者。与此同时，几乎所有的 Android 生态协同插件都会基于 Variant 的名字去给自己 Task 命名（如果它需要是一个 VariantAware Task 的话），例如 “UploadArchiveWithLogForProductionRelease”。这个不成文的规则给了我们字符串匹配的机会，也即你看到的上述代码。对于插件怎么找到对应的所有 Task，目前没有自动化的办法，也没有 API（但是最近的一个 AGP Team Q&amp;A 上，他们提到在和 Gradle 推进这个功能）。你可以做的就是：引入插件前打印下 Task List，引入后再打印一遍，找二者的 Diff。 当然对于一些比较简单的插件，直接看下文档或者源码，整理下有哪几个 Task 也行。所以这个方案小结下就一句话：总是引用插件，但禁用掉不需要的 Task。在 Task 注册时拦截（高效 Y我在上一篇[《构建指北 #11 BundleTool Gradle Plugin》](https://2bab.me/2021/12/19/bundle-tool-plugin]中提到：  bundle-tool-gradle-plugin 支持按不同 variant 渠道去开启插件的几个功能特性。这光听起来就和上一个方案就有点神似了，难不成就是把 enabled = false 藏 Plugin 里，再吐个 DSL 的开关配置出来给用户选择？其实不然，解决思路上已经大差不差了。但稍微思考下还有两个可以改进的空间：  既然我们想要在插件内部控制开关，何必使用 task.enabled = false，直接把注册流程跳过就好了（当然，这个做法不适用于所有情况，有时候还是需要动态禁用的）。  对于大部分的 Android 生态协同插件，其 DSL 一般都是 Variant 无关的静态配置，如果要设计一个 Variant 有关的配置，可能只能传入一堆自定义 rules（如下代码）：// 静态的 DSL 配置bundletool {    enableByVariantRules {        create(\"debugStaging\") {            enabledFeature1 = true            enabledFeature2 = true            enabledFeature3 = false        }        create(\"debugProduction\") {            ...        }    }} 这种 rules 的复杂度比较难控制，在上述代码里它是一个 2 * 2 * 3 的笛卡尔积，配置起来十分不变。解决的方法也很容易想到，如果它能做成传入一个 Kotlin Lambda（或者 Groovy Closure），不就很方便了？就像我们做二次配置时使用的 onVariants(...) {...} 方法一样，我们需要一些“动态”的东西，用户可以与之互动的东西，减少配置的复杂度。// “动态”的 DSL 配置，基于 Kotlin Lambda 和 Groovy Closure bundleTool {    enableByVariant { variant, feature -&gt;        !(variant.name.contains(\"debug\", true) &amp;&amp; feature == BundleToolFeature.GET_SIZE)    }    ...} 其中 variant 参数是 com.android.build.api.variant.Variant，即我们平时使用的 Variant API v2 的 Variant 对象；feature 参数是一个自定义的 enum 类，方便每个插件定制。然后我们看下实现：/** * Extract `enableByVariant(...)` function, can be reused in other plugins. * Currently the Lambda and Closure are defined by raw types, they can be encapsulated * by [Property] as well to fulfill \"lazily produced/consumed\" purpose. */abstract class EnableByFeatureExtension&lt;T&gt; {    var kotlinEnableByVariant: EnableByVariant&lt;T&gt;? = null    var groovyEnableByVariant: Closure&lt;Boolean&gt;? = null    // For Gradle Kotlin DSL    fun enableByVariant(selector: EnableByVariant&lt;T&gt;) {        kotlinEnableByVariant = selector    }    // For Gradle Groovy DSL    fun enableByVariant(selector: Closure&lt;Boolean&gt;) {        groovyEnableByVariant = selector.dehydrate()    }    internal fun isFeatureEnabled(variant: Variant, t: T): Boolean = when {        kotlinEnableByVariant != null -&gt; {            kotlinEnableByVariant!!.invoke(variant, t)        }        groovyEnableByVariant != null -&gt; {            groovyEnableByVariant!!.call(variant, t)        }        else -&gt; false    }}internal typealias EnableByVariant&lt;T&gt; = (variant: Variant, t: T) -&gt; Booleanabstract class BundleToolExtension: EnableByFeatureExtension&lt;BundleToolFeature&gt;() {    abstract val buildApks: NamedDomainObjectContainer&lt;BuildApksRule&gt;    abstract val getSize: NamedDomainObjectContainer&lt;GetSizeRule&gt;}enum class BundleToolFeature {    // It's currently a predecessor for GET_SIZE,    // and the first job that plugin does,    // disable it will cause the task registry got removed.    // The work action that transforms .aab to .apks using `build-apks` command.    BUILD_APKS,    // The work action that gets the transformed .apks file size using `get-size total` command.    GET_SIZE}这里我们分别定义了针对 Groovy 和 Kotlin 两种 Gradle DSL 的 Closure/Lambda，它们接受 Variant 和自定义的一个泛型参数，返回一个 Boolean 值表示是否开启对应功能。接着我们定义了 isFeatureEnabled(..,): Boolean 方法对两个语言分支进行整合，方便插件内部的调用。当实际使用该 EnableByFeatureExtension 时，实际上我们会让插件的 BundleToolExtension 继承于它，从而隔离出插件本体功能和通用的开关特性，任意其他的插件可以方便地拷走这个类加入到自己的 Extension 中。androidExtension.onVariants { variant -&gt;    if (!config.isFeatureEnabled(variant, BundleToolFeature.BUILD_APKS)) {        return@onVariants    }    val featureGetSize = config.isFeatureEnabled(variant, BundleToolFeature.GET_SIZE)    ...    val buildApksTaskProvider = project.tasks.register&lt;BundleToolTask&gt;(        \"TransformApksFromBundleFor${variantName}\"    ) {        enableGetSizeFeature = featureGetSize        ...    }}abstract class BundleToolTask : DefaultTask() {    @get:Input    var enableGetSizeFeature: Boolean = false    ...        @TaskAction    fun transform() {        ...        if (!enableGetSizeFeature) return    }}最后，我们展示了在两个地方使用这个开关的例子：  如果某个 Feature 影响的是整个 Task，我们可以使用开关跳过它的注册。  如果某个 Feature 只影响了一个 Task 内的部分功能，我们将开关的值传入 Task 内部再进行判断。上述的流程并非完全不可变，这个思路可以结合其他的开关方式进行调整。目前我已经在 bundle-tool-gradle-plugin 和 ScratchPaper 使用了这个方案，让插件功能的引入更加灵活。当然，你可能也已经发现，这个方案其实是从插件开发的角度入手，除非所有的插件开发者都使用了类似的方案进行优化，否则方案 3 仍然是从用户角度出发的目前唯一的通用办法。但是这个方案的优势在于控制粒度更精细、也更方便，开发者可以任意定制。总结本文主要讨论了插件功能根据不同 Variant 渠道进行开启的解决方案，可能也是全网第一次有如此详细和完整的多种方案对比讨论。文章的思考和方案其实还可以被运用到其他的一些 Gradle 场景中，大家可以自行发挥想象。那 2021 年的最后一篇技术文章就到这边啦，咱们明年再见。欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p>在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：<strong>我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。</strong></p><p>这个问题的根本原因在于 Variant（buildType + flavor) 不是一个 Gradle 概念，而是源于 Android Gralde Plugin（AGP）的多渠道配置。所以从 Gradle 平台的角度很难向上提供便捷的支持：一个工程内的插件引入是全局的、平台性的，不以某一个插件的意志（AGP）而改变下层平台的机制。</p><p>OK，但我们的问题还是要解决的，所以便了有下面四种问题的解法（大雾。我们按照无效到高效的顺序一一解释其中的思路。</p><h2 id=\"根据-variant-去-apply-插件无效-x\">根据 Variant 去 apply 插件（无效 X</h2><pre><code class=\"language-Kotlin\">flavorDimensions += \"server\"productFlavors {    ...    create(\"production\") {        dimension = \"server\"        applicationIdSuffix = \".production\"        versionNameSuffix = \"-production\"        versionCode = 2        apply(\"xxx\") // 无效    }}</code></pre><p>很多 Android 或者 Gradle 的初学者会觉得，我把 <code class=\"language-plaintext highlighter-rouge\">apply(...)</code> 放在这里不就好了？（当然，你肯定不能用 <code class=\"language-plaintext highlighter-rouge\">plugins { id(\"xxx\") }</code>）这里的误区在于，<strong><code class=\"language-plaintext highlighter-rouge\">apply(...)</code> 方法和当前上下文对象并没有关联</strong>：</p><p><img src=\"https://2bab-images.lastmayday.com/20211221205845.png?imageslim\" alt=\"\" /></p><p><img src=\"https://2bab-images.lastmayday.com/20211221210042.png?imageslim\" alt=\"\" /></p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">create(\"...\"){}</code> 的闭包上下文是 <code class=\"language-plaintext highlighter-rouge\">this:ApplicationProductFlavor</code>。</li>  <li><code class=\"language-plaintext highlighter-rouge\">apply(...)</code> 则为挂载于 PluginAware 的一个扩展方法（以 <code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code>），作用于整个 Project，这样一来你的插件还是会被全局引入。</li></ul><p>同样的经典误区：</p><pre><code class=\"language-Kotlin\">create(\"production\") {    dimension = \"server\"    applicationIdSuffix = \".production\"    versionNameSuffix = \"-production\"    versionCode = 2    packagingOptions {        jniLibs {            excludes.add(\"...\")        }    }}</code></pre><p><img src=\"https://2bab-images.lastmayday.com/20211221212514.png?imageslim\" alt=\"\" />你可能觉得这样可以为这个 flavor 设置单独的 <code class=\"language-plaintext highlighter-rouge\">packageingOptions</code>，但实际上这个方法是 <code class=\"language-plaintext highlighter-rouge\">CommonExtension</code> 接口的一个方法，并不属于 <code class=\"language-plaintext highlighter-rouge\">ApplicationProductFlavor</code>。也即它是为整个 Android Gradle Plugin 进行设置，而不是单一 flavor，如果你在每个 flavor 中都进行不同的设置，最后一次的设置会覆盖前面所有的。针对这个问题的解决方法，可参考我之前 <a href=\"https://www.bilibili.com/video/BV1WP4y1G71h\">GDG 分享</a>中的“二次配置”部分。</p><h2 id=\"根据命令去-apply-插件部分有效-x\">根据命令去 apply 插件（部分有效 X</h2><p>我们本次讨论的问题在一些 StackOverflow 问答中也能查到，其中有大量的答案是关于“解析键入的命令”来进行判断。</p><pre><code class=\"language-Kotlin\">if (gradle.startParameter.taskRequests.toString().contains(\"production\")) {    apply(...)}</code></pre><p>这种做法能够解决你输入的命令为 <code class=\"language-plaintext highlighter-rouge\">./gradlew clean assembleProductionRelease</code> 等等的情况，因为这类命令中仅包含了一个 Variant 的信息（也就是 Production + Release）。然而如果输入的命令是 <code class=\"language-plaintext highlighter-rouge\">./gradlew clean assembleRelease</code>，它同时打包 <code class=\"language-plaintext highlighter-rouge\">Staging</code> 和 <code class=\"language-plaintext highlighter-rouge\">Production</code> 两个 flavors，这时上面的 <code class=\"language-plaintext highlighter-rouge\">if(...)</code> 条件就完全不成立，你的构建也会因此遭到破坏。</p><p>多数情况 <code class=\"language-plaintext highlighter-rouge\">taskRequests</code> 下对第三方 Android 构建插件的开发者都是不应去获取和使用的，和第一条误区一样它是 Gradle 平台自身的 API，没有为上层 AGP 的 Variant 概念做优化。</p><h2 id=\"禁用对应-variant-的插件-task有效-y\">禁用对应 Variant 的插件 Task（有效 Y</h2><p>当然，SO 上也有人提到了正确、有效、且通用的做法——<strong>不要动态禁用（或开启）插件，而是去禁用插件内的 Task。</strong></p><pre><code class=\"language-Kotlin\">plugins { id(\"com.example.ua\") }// or apply(\"com.example.ua\")...tasks.whenTaskAdded {    if (name.contains(\"production\", true)            &amp;&amp; name.contains(\"release\", true)            &amp;&amp; name.contains(\"UploadArchive\", true)) {        enabled = false    }}</code></pre><p>假设有一个上传构建结果的插件叫做 <code class=\"language-plaintext highlighter-rouge\">com.example.ua</code>，我们不管什么情况，都在<code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code> 内引用它。但是往下看，我们基于 <code class=\"language-plaintext highlighter-rouge\">whenTaskAdded {...}</code> 做了类似上一条误区的 <code class=\"language-plaintext highlighter-rouge\">if(...)</code> 判断，然后符合条件的 task 的 <code class=\"language-plaintext highlighter-rouge\">enabled</code> 属性设置为 <code class=\"language-plaintext highlighter-rouge\">false</code>。为什么上一个方法不行，而这个可以？</p><p>我们要复习下这条 Gradle 脚本和 <code class=\"language-plaintext highlighter-rouge\">android{}</code> DSL 规则：不管你 shell 键入的命令是什么，你键入的是 <code class=\"language-plaintext highlighter-rouge\">clean</code> 也好 <code class=\"language-plaintext highlighter-rouge\">help</code> 也好，这份脚本都是会完整地被执行，所有 Variant 的 Task 都会被注册（当然现在通常都是惰性注册了 <code class=\"language-plaintext highlighter-rouge\">register(...)</code> 而不用 <code class=\"language-plaintext highlighter-rouge\">create()</code>）。<strong>而 <code class=\"language-plaintext highlighter-rouge\">whenTaskAdded{...}</code> 是 Gradle 平台的 API，它才不管你上层注册的 Task 分不分 Variant，它只管把所有注册后且确定会添加进运行图（是个有向无环图 DAG）的 Task 在这里提供一个回调的时机给开发者。与此同时，几乎所有的 Android 生态协同插件都会基于 Variant 的名字去给自己 Task 命名（如果它需要是一个 VariantAware Task 的话），例如 “UploadArchiveWithLogForProductionRelease”。这个不成文的规则给了我们字符串匹配的机会，也即你看到的上述代码。</strong></p><p>对于插件怎么找到对应的所有 Task，目前没有自动化的办法，也没有 API（但是最近的一个 AGP Team Q&amp;A 上，他们提到在和 Gradle 推进这个功能）。你可以做的就是：<strong>引入插件前打印下 Task List，引入后再打印一遍，找二者的 Diff。</strong> 当然对于一些比较简单的插件，直接看下文档或者源码，整理下有哪几个 Task 也行。</p><p>所以这个方案小结下就一句话：总是引用插件，但禁用掉不需要的 Task。</p><h2 id=\"在-task-注册时拦截高效-y\">在 Task 注册时拦截（高效 Y</h2><p>我在上一篇[《构建指北 #11 BundleTool Gradle Plugin》](https://2bab.me/2021/12/19/bundle-tool-plugin]中提到：</p><blockquote>  <p>bundle-tool-gradle-plugin 支持按不同 variant 渠道去开启插件的几个功能特性。</p></blockquote><p>这光听起来就和上一个方案就有点神似了，难不成就是把 <code class=\"language-plaintext highlighter-rouge\">enabled = false</code> 藏 Plugin 里，再吐个 DSL 的开关配置出来给用户选择？其实不然，解决思路上已经大差不差了。但稍微思考下还有两个可以改进的空间：</p><ol>  <li>既然我们想要在插件内部控制开关，何必使用 <code class=\"language-plaintext highlighter-rouge\">task.enabled = false</code>，<strong>直接把注册流程跳过就好了</strong>（当然，这个做法不适用于所有情况，有时候还是需要动态禁用的）。</li>  <li>对于大部分的 Android 生态协同插件，其 DSL 一般都是 Variant 无关的静态配置，如果要设计一个 Variant 有关的配置，可能只能传入一堆自定义 rules（如下代码）：</li></ol><pre><code class=\"language-Kotlin\">// 静态的 DSL 配置bundletool {    enableByVariantRules {        create(\"debugStaging\") {            enabledFeature1 = true            enabledFeature2 = true            enabledFeature3 = false        }        create(\"debugProduction\") {            ...        }    }} </code></pre><p>这种 rules 的复杂度比较难控制，在上述代码里它是一个 2 * 2 * 3 的笛卡尔积，配置起来十分不变。解决的方法也很容易想到，<strong>如果它能做成传入一个 Kotlin Lambda（或者 Groovy Closure），不就很方便了？就像我们做二次配置时使用的 <code class=\"language-plaintext highlighter-rouge\">onVariants(...) {...}</code> 方法一样，我们需要一些“动态”的东西，用户可以与之互动的东西，减少配置的复杂度。</strong></p><pre><code class=\"language-Kotlin\">// “动态”的 DSL 配置，基于 Kotlin Lambda 和 Groovy Closure bundleTool {    enableByVariant { variant, feature -&gt;        !(variant.name.contains(\"debug\", true) &amp;&amp; feature == BundleToolFeature.GET_SIZE)    }    ...} </code></pre><p>其中 <code class=\"language-plaintext highlighter-rouge\">variant</code> 参数是 <code class=\"language-plaintext highlighter-rouge\">com.android.build.api.variant.Variant</code>，即我们平时使用的 Variant API v2 的 Variant 对象；<code class=\"language-plaintext highlighter-rouge\">feature</code> 参数是一个自定义的 enum 类，方便每个插件定制。然后我们看下实现：</p><pre><code class=\"language-Kotlin\">/** * Extract `enableByVariant(...)` function, can be reused in other plugins. * Currently the Lambda and Closure are defined by raw types, they can be encapsulated * by [Property] as well to fulfill \"lazily produced/consumed\" purpose. */abstract class EnableByFeatureExtension&lt;T&gt; {    var kotlinEnableByVariant: EnableByVariant&lt;T&gt;? = null    var groovyEnableByVariant: Closure&lt;Boolean&gt;? = null    // For Gradle Kotlin DSL    fun enableByVariant(selector: EnableByVariant&lt;T&gt;) {        kotlinEnableByVariant = selector    }    // For Gradle Groovy DSL    fun enableByVariant(selector: Closure&lt;Boolean&gt;) {        groovyEnableByVariant = selector.dehydrate()    }    internal fun isFeatureEnabled(variant: Variant, t: T): Boolean = when {        kotlinEnableByVariant != null -&gt; {            kotlinEnableByVariant!!.invoke(variant, t)        }        groovyEnableByVariant != null -&gt; {            groovyEnableByVariant!!.call(variant, t)        }        else -&gt; false    }}internal typealias EnableByVariant&lt;T&gt; = (variant: Variant, t: T) -&gt; Booleanabstract class BundleToolExtension: EnableByFeatureExtension&lt;BundleToolFeature&gt;() {    abstract val buildApks: NamedDomainObjectContainer&lt;BuildApksRule&gt;    abstract val getSize: NamedDomainObjectContainer&lt;GetSizeRule&gt;}enum class BundleToolFeature {    // It's currently a predecessor for GET_SIZE,    // and the first job that plugin does,    // disable it will cause the task registry got removed.    // The work action that transforms .aab to .apks using `build-apks` command.    BUILD_APKS,    // The work action that gets the transformed .apks file size using `get-size total` command.    GET_SIZE}</code></pre><p>这里我们分别定义了针对 Groovy 和 Kotlin 两种 Gradle DSL 的 Closure/Lambda，它们接受 <code class=\"language-plaintext highlighter-rouge\">Variant</code> 和自定义的一个泛型参数，返回一个 Boolean 值表示是否开启对应功能。接着我们定义了 <code class=\"language-plaintext highlighter-rouge\">isFeatureEnabled(..,): Boolean</code> 方法对两个语言分支进行整合，方便插件内部的调用。当实际使用该 <code class=\"language-plaintext highlighter-rouge\">EnableByFeatureExtension</code> 时，实际上我们会让插件的 <code class=\"language-plaintext highlighter-rouge\">BundleToolExtension</code> 继承于它，从而隔离出插件本体功能和通用的开关特性，任意其他的插件可以方便地拷走这个类加入到自己的 Extension 中。</p><pre><code class=\"language-Kotlin\">androidExtension.onVariants { variant -&gt;    if (!config.isFeatureEnabled(variant, BundleToolFeature.BUILD_APKS)) {        return@onVariants    }    val featureGetSize = config.isFeatureEnabled(variant, BundleToolFeature.GET_SIZE)    ...    val buildApksTaskProvider = project.tasks.register&lt;BundleToolTask&gt;(        \"TransformApksFromBundleFor${variantName}\"    ) {        enableGetSizeFeature = featureGetSize        ...    }}abstract class BundleToolTask : DefaultTask() {    @get:Input    var enableGetSizeFeature: Boolean = false    ...        @TaskAction    fun transform() {        ...        if (!enableGetSizeFeature) return    }}</code></pre><p>最后，我们展示了在两个地方使用这个开关的例子：</p><ol>  <li>如果某个 Feature 影响的是整个 Task，我们可以使用开关跳过它的注册。</li>  <li>如果某个 Feature 只影响了一个 Task 内的部分功能，我们将开关的值传入 Task 内部再进行判断。</li></ol><p>上述的流程并非完全不可变，这个思路可以结合其他的开关方式进行调整。目前我已经在 <a href=\"https://github.com/2BAB/bundle-tool-gradle-plugin\">bundle-tool-gradle-plugin</a> 和 <a href=\"https://github.com/2BAB/ScratchPaper\">ScratchPaper</a> 使用了这个方案，让插件功能的引入更加灵活。</p><p><strong>当然，你可能也已经发现，这个方案其实是从插件开发的角度入手，除非所有的插件开发者都使用了类似的方案进行优化，否则方案 3 仍然是从用户角度出发的目前唯一的通用办法。但是这个方案的优势在于控制粒度更精细、也更方便，开发者可以任意定制。</strong></p><h2 id=\"总结\">总结</h2><p>本文主要讨论了插件功能根据不同 Variant 渠道进行开启的解决方案，可能也是全网第一次有如此详细和完整的多种方案对比讨论。文章的思考和方案其实还可以被运用到其他的一些 Gradle 场景中，大家可以自行发挥想象。那 2021 年的最后一篇技术文章就到这边啦，咱们明年再见。</p><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/12/21/enable-feature-by-variant",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2021-12-21T00:00:00+00:00",
            "date_modified": "2021-12-21T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/12/19/bundle-tool-plugin",
            "title": "构建指北 #11 BundleTool Gradle Plugin",
            "summary": null,
            "content_text": "App Bundle（.aab) 作为 Android 官方力推的新交付格式已经存在了一段时间，而今年 PlayStore 的政策强制“所有新应用必须使用 .aab”进行提交也成为了大家转换过去的一大动力。兼容和打包 .aab 文件格式其实并不复杂，简单添加对应的 DSL 配置并替换掉执行的打包命令为 bundle${VariantName} 即可。但是，打包后得到的 .aab 并不能直接在本地直接使用 adb 安装到调试设备，需要借助 bundletool 转换到 .apks 后再调用其安装命令进行安装。常见场景BundleTool 官方文档 列举了 CLI 命令的各类用途；放到更复杂的环境中，你可能碰到过 BundleTool 的这些场景：  本地测试时，需要使用 BundleTool 的 CLI 手动运行转换和安装命令；  CI 环境下，需要配置 BundleTool CLI 工具，再编写一些 Shell 脚本进行打包后的转换流程控制；  真机实验室的测试、真机云平台的测试，需要集成 BundleTool 到相对应的测试中，方便生成对应机型的 apks 包。这些场景常常伴随着下列的一些问题：  一些内部测试包发布渠道不支持 aab 和 apks，我们需要在这些非 GP 非真机实验平台做快速的功能测试，universal apk 才是这类场景的最好选择（但是从头再打一个 apk 显然是浪费资源）；  在 aab 包上传至 GP 的 Console 后，可以清晰得看到所有支持机型的预计下载大小，但是这个数据指标不方便在 CI 上直接用 Shell 脚本来做收集和量化（硬上或者用 Python 大概也可以）；  AGP 其实集成了，BundleTool 包，每次又要单独配置 BundleTool 的 CLI 其实显得有些多余。不禁思考，AGP 有 BundleTool 的依赖，没有这些 BundleTool 后续转换的 Task 吗？使用 Gradle 来做这些后续的操作其实更适合？深入 AGP &amp; BundleTool如果我们打开 IDE 的 Gradle Task 列表，查询 “Bundle“ 关键词，很容易就会发现 makeApkFromBundleForXxxx 等任务，它们的实现是 com.android.build.gradle.internal.tasks.BundleToApkTask 这个类。在源码中查看该类的关联使用，你会发现除了注册没有任何地方有该类的使用痕迹。而这个任务自身的具体作用其实只是：  依赖 PackageXxxBundle，等它打出一个未签名的 Bundle；  输入上一步的 Bundle，执行 BundleTool 包里的 BuildApksCommand 命令打出一个 .apks 包。  从它的输入参数可以看出，用户需要的配置它其实只暴露了一个 enableLocalTesting，其余的都使用 BundleTool build-apks 命令的默认值；  从它的输出结果（见下方）可以发现，它竟然只是一个“中间产物”（位于 /intermediates 文件夹中），而非最终产物。这就有点食之无味、弃之可惜了：有现成的 Task 但使用范围十分局限。不如…咱借助 BundleTool 库自己封装一个 Gradle Plugin？bundle-tool-gradle-plugin 怎么封装？简单分析下 BundleTool 的几个命令，我们发现它们的依赖关系如下：其中：  从顺序来看 build-apks 是其他几个命令的必选前置任务（实线），get-device-sepc 是几个命令的可选前置任务（虚线）。  从交互来看，build-apks 和 get-size（斜体部分）和构建流程关系紧密，不需要测试设备参与；其余命令需要测试设备参与。  get-device-spec 导出 json 文件是一次性的任务，我们可以假设这部分已经完成；如此，我们涉及的领域也清楚了：build-apks 和 get-size 等和最终产物直接相关的命令。install-apks 和 extract-apks 在本地测试可以根据当前设备使用 CLI 完成，在 CI 或者云真机测试平台等一般有专用的脚本去结合 BundleTool 处理。然后我们考虑获取如何获取最终输出的 Bundle 并修改。新版 Variant API 其实已经提供了方便修改和获取最终 Bundle 的方法，整个流程可以参考如下的运行截图。可以看到对比之前的中间产物模式，Variant API 的产物都已经输出到 /outputs 文件夹了。由于我们不需要中间 aab，所以我们只要简单调用 variants.get(SingleArtifact.BUNDLE)，把获取的 .aab 文件传入自定义 Task，之后再借鉴 AGP 的代码包装下各类命令即可：// 一个验证想法的简单 Task，完整插件的实现比这个复杂一些，请直接参考文末的仓库链接abstract class ConsumeBundleFileTask : DefaultTask() {    @get:InputFiles    abstract val finalBundleProperty: RegularFileProperty    @get:Internal    abstract val buildToolInfo: Property&lt;BuildToolInfo&gt;    @get:Nested    lateinit var signingConfigData: SigningConfigDataProvider    @get:OutputFile    abstract val apksFileProperty: RegularFileProperty    @TaskAction    fun taskAction() {        val aapt2Path = buildToolInfo.get().getPath(BuildToolInfo.PathId.AAPT2)        println(\".get(SingleArtifact.BUNDLE)\")        println(\"[ConsumeBundleFileTask][input]:\" + finalBundleProperty.asFile.get().absolutePath)        println(\"[ConsumeBundleFileTask][output]:\" + apksFileProperty.asFile.get().absolutePath)        val signingConfigData = signingConfigData.resolve()!!        val command = BuildApksCommand.builder()            .setBundlePath(finalBundleProperty.asFile.get().toPath())            .setOutputFile(apksFileProperty.asFile.get().toPath())            .setAapt2Command(                Aapt2Command.createFromExecutablePath(                    File(aapt2Path).toPath()                )            )            .setSigningConfiguration2(                keystoreFile = signingConfigData.storeFile,                keystorePassword = signingConfigData.storePassword,                keyAlias = signingConfigData.keyAlias,                keyPassword = signingConfigData.keyPassword            ).setLocalTestingMode(false)        command.build().execute()    }    ...}不了解新版 Variant API 的朋友可以参考我这个月在 GDG 社区的分享《扩展 Android 构建流程 - 基于新版 Variant/Artifact APIs》（回放地址）。最后我们简单看下 BundleTool 的 BuildApksCommand.Builder，这个 Builder 的 setXxx 相关的 API 过去一年也就两个小改动，其中还有一个是新增方法，不太影响原有的兼容性，相比 AGP 来说整体相对稳定了。至此，整个插件的理论构建成本和维护成本都在可接受范围内。使用插件插件的开发和我之前写过的几个并无差别，我们直接来看插件的使用。0x01. Add the plugin to classpath:buildscript {    repositories {        ...        mavenCentral()    }    dependencies {        classpath(\"com.android.tools.build:gradle:7.0.4\")        classpath(\"me.2bab:bundle-tool-plugin:1.1.0\")    }}0x02. Apply Plugin:// For your application moduleplugins {    id(\"me.2bab.bundletool\")}0x03. Advanced Configurationsimport me.xx2bab.bundletool.*bundleTool {    // 这里是一个很有趣的配置项，它可以按不同 variant 渠道去    // 开启插件的几个功能特性，例如这里我们把 debug + Get_SIZE 功能的组合禁掉了。    // 你可以根据项目实际的 buildtype 和 flavor 去调整和开启需要的功能。    enableByVariant { variant, feature -&gt;        !(variant.name.contains(\"debug\", true) &amp;&amp; feature == BundleToolFeature.GET_SIZE)    }        // 每个配置项会对应到一个 `build-apks` 命令的执行    buildApks {        create(\"universal\") {            buildMode.set(ApkBuildMode.UNIVERSAL.name)        }        create(\"pixel4a\") {            deviceSpec.set(file(\"./pixel4a.json\"))        }    }    // 每个配置项都会依次计算上面 `buildApks` 所有输出的 apks 的大小，    // 按当前的配置会输出 2 * 1 = 2 份 csv 文件    getSize {        create(\"all\") {            dimensions.addAll(                GetSizeDimension.SDK.name,                GetSizeDimension.ABI.name,                GetSizeDimension.SCREEN_DENSITY.name,                GetSizeDimension.LANGUAGE.name)        }    }}0x04. Build your App and Enjoy!# 确保执行命令里的 Variant 是 `enableByVariant` 中允许的./gradlew TransformApksFromBundleForProductionRelease最后可以在 /app/outputs/bundle/${variantName}/bundletool 中找到输出的结果。总结希望这个小工具可以帮助大家在集成新的 Android Bundle 时提供一些帮助，插件已经开源到我 Github：bundle-tool-gradle-plugin。关于按 Variant 开关插件功能的思路，请参考下一篇构建指北#12。欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p>App Bundle（.aab) 作为 Android 官方力推的新交付格式已经存在了一段时间，而今年 PlayStore 的政策强制“所有新应用必须使用 .aab”进行提交也成为了大家转换过去的一大动力。兼容和打包 .aab 文件格式其实并不复杂，简单添加对应的 DSL 配置并替换掉执行的打包命令为 <code class=\"language-plaintext highlighter-rouge\">bundle${VariantName}</code> 即可。但是，打包后得到的 .aab 并不能直接在本地直接使用 adb 安装到调试设备，需要借助 <a href=\"https://github.com/google/bundletool\">bundletool</a> 转换到 .apks 后再调用其安装命令进行安装。</p><h2 id=\"常见场景\">常见场景</h2><p><a href=\"https://developer.android.com/studio/command-line/bundletool#build_app_bundle\">BundleTool 官方文档</a> 列举了 CLI 命令的各类用途；放到更复杂的环境中，你可能碰到过 BundleTool 的这些场景：</p><ol>  <li>本地测试时，需要使用 BundleTool 的 CLI 手动运行转换和安装命令；</li>  <li>CI 环境下，需要配置 BundleTool CLI 工具，再编写一些 Shell 脚本进行打包后的转换流程控制；</li>  <li>真机实验室的测试、真机云平台的测试，需要集成 BundleTool 到相对应的测试中，方便生成对应机型的 apks 包。</li></ol><p>这些场景常常伴随着下列的一些问题：</p><ol>  <li>一些内部测试包发布渠道不支持 aab 和 apks，我们需要在这些非 GP 非真机实验平台做快速的功能测试，universal apk 才是这类场景的最好选择（但是从头再打一个 apk 显然是浪费资源）；</li>  <li>在 aab 包上传至 GP 的 Console 后，可以清晰得看到所有支持机型的预计下载大小，但是这个数据指标不方便在 CI 上直接用 Shell 脚本来做收集和量化（硬上或者用 Python 大概也可以）；</li>  <li>AGP 其实集成了，BundleTool 包，每次又要单独配置 BundleTool 的 CLI 其实显得有些多余。</li></ol><p>不禁思考，AGP 有 BundleTool 的依赖，没有这些 BundleTool 后续转换的 Task 吗？使用 Gradle 来做这些后续的操作其实更适合？</p><h2 id=\"深入-agp--bundletool\">深入 AGP &amp; BundleTool</h2><p>如果我们打开 IDE 的 Gradle Task 列表，查询 “Bundle“ 关键词，很容易就会发现 <code class=\"language-plaintext highlighter-rouge\">makeApkFromBundleForXxxx</code> 等任务，它们的实现是 <code class=\"language-plaintext highlighter-rouge\">com.android.build.gradle.internal.tasks.BundleToApkTask</code> 这个类。</p><p><img src=\"https://2bab-images.lastmayday.com/20211219_bundle_tool_bundle_to_apk_task.png?imageslim\" alt=\"Task 列表和 BundleToApkTask 截图\" /></p><p>在源码中查看该类的关联使用，你会发现除了注册没有任何地方有该类的使用痕迹。而这个任务自身的具体作用其实只是：</p><ul>  <li>依赖 <code class=\"language-plaintext highlighter-rouge\">PackageXxxBundle</code>，等它打出一个未签名的 Bundle；</li>  <li>输入上一步的 Bundle，执行 BundleTool 包里的 <code class=\"language-plaintext highlighter-rouge\">BuildApksCommand</code> 命令打出一个 .apks 包。</li>  <li>从它的输入参数可以看出，用户需要的<strong>配置</strong>它其实只暴露了一个 <code class=\"language-plaintext highlighter-rouge\">enableLocalTesting</code>，其余的都使用 BundleTool <code class=\"language-plaintext highlighter-rouge\">build-apks</code> 命令的<strong>默认值</strong>；</li>  <li>从它的输出结果（见下方）可以发现，它竟然只是一个“<strong>中间产物</strong>”（位于 <code class=\"language-plaintext highlighter-rouge\">/intermediates</code> 文件夹中），而非最终产物。</li></ul><p><img src=\"https://2bab-images.lastmayday.com/20211219_bundle_tool_tasks_1.png?imageslim\" alt=\"\" /></p><p>这就有点食之无味、弃之可惜了：有现成的 Task 但使用范围十分局限。不如…咱借助 BundleTool 库自己封装一个 Gradle Plugin？</p><h2 id=\"bundle-tool-gradle-plugin-怎么封装\">bundle-tool-gradle-plugin 怎么封装？</h2><p>简单分析下 BundleTool 的几个命令，我们发现它们的依赖关系如下：</p><p><img src=\"https://2bab-images.lastmayday.com/20211219_bundle_tool_commands.png?imageslim\" alt=\"\" /></p><p>其中：</p><ul>  <li>从顺序来看 <code class=\"language-plaintext highlighter-rouge\">build-apks</code> 是其他几个命令的必选前置任务（实线），<code class=\"language-plaintext highlighter-rouge\">get-device-sepc</code> 是几个命令的可选前置任务（虚线）。</li>  <li>从交互来看，<code class=\"language-plaintext highlighter-rouge\">build-apks</code> 和 <code class=\"language-plaintext highlighter-rouge\">get-size</code>（斜体部分）和构建流程关系紧密，不需要测试设备参与；其余命令需要测试设备参与。</li>  <li><code class=\"language-plaintext highlighter-rouge\">get-device-spec</code> 导出 json 文件是一次性的任务，我们可以假设这部分已经完成；</li></ul><p>如此，我们<strong>涉及的领域</strong>也清楚了：<code class=\"language-plaintext highlighter-rouge\">build-apks</code> 和 <code class=\"language-plaintext highlighter-rouge\">get-size</code> 等和最终产物直接相关的命令。<code class=\"language-plaintext highlighter-rouge\">install-apks</code> 和 <code class=\"language-plaintext highlighter-rouge\">extract-apks</code> 在本地测试可以根据当前设备使用 CLI 完成，在 CI 或者云真机测试平台等一般有专用的脚本去结合 BundleTool 处理。</p><p>然后我们考虑获取<strong>如何获取最终输出的 Bundle 并修改</strong>。新版 Variant API 其实已经提供了方便修改和获取最终 Bundle 的方法，整个流程可以参考如下的运行截图。可以看到对比之前的中间产物模式，Variant API 的产物都已经输出到 <code class=\"language-plaintext highlighter-rouge\">/outputs</code> 文件夹了。由于我们不需要中间 aab，所以我们只要简单调用 <code class=\"language-plaintext highlighter-rouge\">variants.get(SingleArtifact.BUNDLE)</code>，把获取的 .aab 文件传入自定义 Task，之后再借鉴 AGP 的代码包装下各类命令即可：</p><p><img src=\"https://2bab-images.lastmayday.com/20211219_bundle_tool_tasks_2.png?imageslim\" alt=\"\" /></p><pre><code class=\"language-Kotlin\">// 一个验证想法的简单 Task，完整插件的实现比这个复杂一些，请直接参考文末的仓库链接abstract class ConsumeBundleFileTask : DefaultTask() {    @get:InputFiles    abstract val finalBundleProperty: RegularFileProperty    @get:Internal    abstract val buildToolInfo: Property&lt;BuildToolInfo&gt;    @get:Nested    lateinit var signingConfigData: SigningConfigDataProvider    @get:OutputFile    abstract val apksFileProperty: RegularFileProperty    @TaskAction    fun taskAction() {        val aapt2Path = buildToolInfo.get().getPath(BuildToolInfo.PathId.AAPT2)        println(\".get(SingleArtifact.BUNDLE)\")        println(\"[ConsumeBundleFileTask][input]:\" + finalBundleProperty.asFile.get().absolutePath)        println(\"[ConsumeBundleFileTask][output]:\" + apksFileProperty.asFile.get().absolutePath)        val signingConfigData = signingConfigData.resolve()!!        val command = BuildApksCommand.builder()            .setBundlePath(finalBundleProperty.asFile.get().toPath())            .setOutputFile(apksFileProperty.asFile.get().toPath())            .setAapt2Command(                Aapt2Command.createFromExecutablePath(                    File(aapt2Path).toPath()                )            )            .setSigningConfiguration2(                keystoreFile = signingConfigData.storeFile,                keystorePassword = signingConfigData.storePassword,                keyAlias = signingConfigData.keyAlias,                keyPassword = signingConfigData.keyPassword            ).setLocalTestingMode(false)        command.build().execute()    }    ...}</code></pre><p>不了解<strong>新版 Variant API</strong> 的朋友可以参考我这个月在 GDG 社区的分享《扩展 Android 构建流程 - 基于新版 Variant/Artifact APIs》（<a href=\"https://www.bilibili.com/video/BV1WP4y1G71h?share_source=copy_web\">回放地址</a>）。</p><p>最后我们简单看下 BundleTool 的 BuildApksCommand.Builder，这个 Builder 的 setXxx 相关的 <strong>API</strong> 过去一年也就两个小改动，其中还有一个是新增方法，不太影响原有的兼容性，相比 AGP 来说整体<strong>相对稳定</strong>了。</p><p>至此，整个插件的理论构建成本和维护成本都在可接受范围内。</p><h2 id=\"使用插件\">使用插件</h2><p>插件的开发和我之前写过的几个并无差别，我们直接来看插件的使用。</p><p><strong>0x01. Add the plugin to classpath:</strong></p><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">buildscript</span> <span class=\"p\">{</span>    <span class=\"nf\">repositories</span> <span class=\"p\">{</span>        <span class=\"o\">..</span><span class=\"p\">.</span>        <span class=\"nf\">mavenCentral</span><span class=\"p\">()</span>    <span class=\"p\">}</span>    <span class=\"nf\">dependencies</span> <span class=\"p\">{</span>        <span class=\"nf\">classpath</span><span class=\"p\">(</span><span class=\"s\">\"com.android.tools.build:gradle:7.0.4\"</span><span class=\"p\">)</span>        <span class=\"nf\">classpath</span><span class=\"p\">(</span><span class=\"s\">\"me.2bab:bundle-tool-plugin:1.1.0\"</span><span class=\"p\">)</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p><strong>0x02. Apply Plugin:</strong></p><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// For your application module</span><span class=\"nf\">plugins</span> <span class=\"p\">{</span>    <span class=\"nf\">id</span><span class=\"p\">(</span><span class=\"s\">\"me.2bab.bundletool\"</span><span class=\"p\">)</span><span class=\"p\">}</span></code></pre></div></div><p><strong>0x03. Advanced Configurations</strong></p><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"nn\">me.xx2bab.bundletool.*</span><span class=\"nf\">bundleTool</span> <span class=\"p\">{</span>    <span class=\"c1\">// 这里是一个很有趣的配置项，它可以按不同 variant 渠道去</span>    <span class=\"c1\">// 开启插件的几个功能特性，例如这里我们把 debug + Get_SIZE 功能的组合禁掉了。</span>    <span class=\"c1\">// 你可以根据项目实际的 buildtype 和 flavor 去调整和开启需要的功能。</span>    <span class=\"nf\">enableByVariant</span> <span class=\"p\">{</span> <span class=\"n\">variant</span><span class=\"p\">,</span> <span class=\"n\">feature</span> <span class=\"p\">-&gt;</span>        <span class=\"p\">!(</span><span class=\"n\">variant</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"nf\">contains</span><span class=\"p\">(</span><span class=\"s\">\"debug\"</span><span class=\"p\">,</span> <span class=\"k\">true</span><span class=\"p\">)</span> <span class=\"p\">&amp;&amp;</span> <span class=\"n\">feature</span> <span class=\"p\">==</span> <span class=\"nc\">BundleToolFeature</span><span class=\"p\">.</span><span class=\"nc\">GET_SIZE</span><span class=\"p\">)</span>    <span class=\"p\">}</span>        <span class=\"c1\">// 每个配置项会对应到一个 `build-apks` 命令的执行</span>    <span class=\"nf\">buildApks</span> <span class=\"p\">{</span>        <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"s\">\"universal\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">buildMode</span><span class=\"p\">.</span><span class=\"k\">set</span><span class=\"p\">(</span><span class=\"nc\">ApkBuildMode</span><span class=\"p\">.</span><span class=\"nc\">UNIVERSAL</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">)</span>        <span class=\"p\">}</span>        <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"s\">\"pixel4a\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">deviceSpec</span><span class=\"p\">.</span><span class=\"k\">set</span><span class=\"p\">(</span><span class=\"nf\">file</span><span class=\"p\">(</span><span class=\"s\">\"./pixel4a.json\"</span><span class=\"p\">))</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span>    <span class=\"c1\">// 每个配置项都会依次计算上面 `buildApks` 所有输出的 apks 的大小，</span>    <span class=\"c1\">// 按当前的配置会输出 2 * 1 = 2 份 csv 文件</span>    <span class=\"nf\">getSize</span> <span class=\"p\">{</span>        <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"s\">\"all\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">dimensions</span><span class=\"p\">.</span><span class=\"nf\">addAll</span><span class=\"p\">(</span>                <span class=\"nc\">GetSizeDimension</span><span class=\"p\">.</span><span class=\"nc\">SDK</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>                <span class=\"nc\">GetSizeDimension</span><span class=\"p\">.</span><span class=\"nc\">ABI</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>                <span class=\"nc\">GetSizeDimension</span><span class=\"p\">.</span><span class=\"nc\">SCREEN_DENSITY</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>                <span class=\"nc\">GetSizeDimension</span><span class=\"p\">.</span><span class=\"nc\">LANGUAGE</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">)</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p><strong>0x04. Build your App and Enjoy!</strong></p><div class=\"language-shell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># 确保执行命令里的 Variant 是 `enableByVariant` 中允许的</span>./gradlew TransformApksFromBundleForProductionRelease</code></pre></div></div><p>最后可以在 <code class=\"language-plaintext highlighter-rouge\">/app/outputs/bundle/${variantName}/bundletool</code> 中找到输出的结果。</p><p><img src=\"https://2bab-images.lastmayday.com/20211219_bundle_tool_outputs2.png?imageslim\" alt=\"\" /></p><h2 id=\"总结\">总结</h2><p>希望这个小工具可以帮助大家在集成新的 Android Bundle 时提供一些帮助，插件已经开源到我 Github：<a href=\"https://github.com/2BAB/bundle-tool-gradle-plugin\">bundle-tool-gradle-plugin</a>。关于按 Variant 开关插件功能的思路，请参考下一篇构建指北#12。</p><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/12/19/bundle-tool-plugin",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2021-12-19T00:00:00+00:00",
            "date_modified": "2021-12-19T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/09/24/android-build-survey-result",
            "title": "编译构建知识的调查结果&新企划！\"",
            "summary": null,
            "content_text": "上周的《Android App 编译构建知识的小调查》，收到了预期的问卷数量 101 份（剔除我自己正好100份，也太巧了？）。仅基于个人的理解，我编写了下方五个选项（下文的 1/2/3/4 指代这五个层级）：  ”仅基础使用“（初级）：我能读懂、修改 build.gradle(.kts)，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；  ”实现高效自动化、工程化“（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 buildSrc 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；  ”编译构建增强“（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；  ”对编译构建有较为全面的理解“（资深）：我了解编译构建的主要环节实现，常见架构应用的原理，实践过多个编译构建增强工具，对项目的基础架构梳理得井井有条；  ”深度参与“：我了解 Android App 编译构建的前沿发展，积极参与社区 Discussion、Proposal、PR、Review，灵活运用、修改各类工具，对于不同类型的问题、需求能给出优解、多解。调查结果虽说有一百份，但是：  第一天我就收到了“为什么没有0基础的选项”反馈；  大部分投票的同学都是我公众号的读者 + 社区比较活跃且对 Gradle/Android 构建有兴趣的朋友；  所以从整个社区的角度来看，结果应比下图更往“初级”靠拢。简单分析了几个点：  现在处于的位置：          是典型的倒金字塔结构，并不意外，不管哪门技术调研都会是这个结果；      但前面提到，实际“初级”的占比应比上述数据更多，原本预计可能就 50% 的“初级”现在看来其实有 70%，所以收到“希望多写点基础内容”的反馈非常真实；      我很想知道“深度参与”的那一票是谁投的（不是我），很想和业界大佬交流交流ヾ(◍°∇°◍)ﾉﾞ。        努力达到的位置：          是比较正态分布的结果，即便考虑到误差，也是令我感到欣慰的；      这和现在的市场需求还比较贴切，初级工程师的供给较为均衡，高级工程师仍然供不应求，掌握构建相关的知识可能是一块不错的向上跃迁的敲门砖；      如果有更优质的内容在社区传播，我相信填“深度参与”的人一定能做到，并且可以更多。      所以…我想输出的是…?不少读者（特别是“Android&amp;英语群”里的朋友）知道我已经做了很长一段时间的 Android 构建高级进阶的内容，为了系统性地解决从位置 1 或 2 进阶到 3+ 的多个难题，还需要一段时间的整理和编写，预计在明年会放出。而从这段时间的社区讨论、问卷反馈中，我也不断在思考从 0 到 1 或 2 的内容该怎么做？社区上这块的内容虽然不及 UI 方面的多，但鉴于每个 Android 开发者都必须使用 Gradle，业务上也有多渠道打包、加固等绕不过去的技术需要集成，Android 构建基础的内容还是零星有人分享的，中文社区中例如掘金的 Android 类目下还专门有 Gradle 的小类。那，大家缺的是什么？我认为是一个方向，一份大纲。  从 Gradle 的角度切入的系统性教程出现了多年断层，你能找到的图书很多还在使用 “«” 等过时的 API（“doLast(…)” 的符号重载）；  而 Gradle 官方的文档按 PDF 版来算有 1200+ 页，面之广，直接覆盖了 1-4 的各层级内容，英文不错的朋友快速读一遍都得花上几天；  从 Android 构建的角度切入的系统性教程几乎没有，一旦碰到复杂点的需求，要求自定义一个简单的 Task 和 AGP 进行交互，就发现缺漏的知识太多，更不知从何入手学起。理顺出一条学习路径，加上诸多实例，可能几个篇章就能做出不错的效果，再加上 Kotlin First 的原则，以 KTS 和 Kotlin 编写的插件为例，减少一些 Groovy 的学习成本，我想应该妙极了！ 不出意外的话，十月份我会放出一些有意思的东西。从 KMM 文档翻译活动到 KOGE几个月前，由于我工作中使用了 KMM（Kotlin Multi-platform Mobile)，所以决定做点什么—— “kotlin-mobile-docs” 的中文文档翻译计划。以我为初始翻译者，到后来的另外五个小伙伴加入，我们做了大概 60% 的文档翻译。很可惜我们最后没有完成所有的内容，具体原因如项目 README：而上述 Android 构建 0 到 1 的内容，在确定了路线并做好一部分内容后，我依旧想开源到社区，和大家共同打造这个有价值的项目。我起了个项目名字叫 KOGE，意味 Kotlin-oriented Gradle Essential。这次，我们不做翻译，我们做更有意思的自学大纲，做一手的内容，做反向输出到英文社区的内容。最后，还没有加过“Android&amp;英语群”的朋友，欢迎来群里玩~ 这里日常吹水的东西很少，但是一手的新知识、新资料很多呀~欢迎关注我的  Github / 公众号 / 播客 / Twitter。",
            "content_html": "<p>上周的<a href=\"https://2bab.me/2021/09/14/android-build-survey\">《Android App 编译构建知识的小调查》</a>，收到了预期的问卷数量 101 份（剔除我自己正好100份，也太巧了？）。仅基于个人的理解，我编写了下方五个选项（下文的 1/2/3/4 指代这五个层级）：</p><ol>  <li>”仅基础使用“（初级）：我能读懂、修改 <code class=\"language-plaintext highlighter-rouge\">build.gradle(.kts)</code>，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；</li>  <li>”实现高效自动化、工程化“（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 <code class=\"language-plaintext highlighter-rouge\">buildSrc</code> 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；</li>  <li>”编译构建增强“（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；</li>  <li>”对编译构建有较为全面的理解“（资深）：我了解编译构建的主要环节实现，常见架构应用的原理，实践过多个编译构建增强工具，对项目的基础架构梳理得井井有条；</li>  <li>”深度参与“：我了解 Android App 编译构建的前沿发展，积极参与社区 Discussion、Proposal、PR、Review，灵活运用、修改各类工具，对于不同类型的问题、需求能给出优解、多解。</li></ol><h2 id=\"调查结果\">调查结果</h2><p>虽说有一百份，但是：</p><ol>  <li>第一天我就收到了“为什么没有0基础的选项”反馈；</li>  <li>大部分投票的同学都是我公众号的读者 + 社区比较活跃且对 Gradle/Android 构建有兴趣的朋友；</li>  <li>所以从整个社区的角度来看，结果应比下图更往“初级”靠拢。</li></ol><p><img src=\"https://2bab-images.lastmayday.com/blog/2021-09-24-android-survey-result-1.jpg?imageslim\" alt=\"\" /><img src=\"https://2bab-images.lastmayday.com/blog/2021-09-24-android-survey-result-2.jpg?imageslim\" alt=\"\" /></p><p>简单分析了几个点：</p><ul>  <li>现在处于的位置：    <ul>      <li>是典型的倒金字塔结构，并不意外，不管哪门技术调研都会是这个结果；</li>      <li>但前面提到，实际“初级”的占比应比上述数据更多，原本预计可能就 50% 的“初级”现在看来其实有 70%，所以收到“希望多写点基础内容”的反馈非常真实；</li>      <li>我很想知道“深度参与”的那一票是谁投的（不是我），很想和业界大佬交流交流ヾ(◍°∇°◍)ﾉﾞ。</li>    </ul>  </li>  <li>努力达到的位置：    <ul>      <li>是比较正态分布的结果，即便考虑到误差，也是令我感到欣慰的；</li>      <li>这和现在的市场需求还比较贴切，初级工程师的供给较为均衡，高级工程师仍然供不应求，掌握构建相关的知识可能是一块不错的向上跃迁的敲门砖；</li>      <li>如果有更优质的内容在社区传播，我相信填“深度参与”的人一定能做到，并且可以更多。</li>    </ul>  </li></ul><h2 id=\"所以我想输出的是\">所以…我想输出的是…?</h2><p>不少读者（特别是“Android&amp;英语群”里的朋友）知道我已经做了很长一段时间的 Android 构建高级进阶的内容，为了系统性地解决<strong>从位置 1 或 2 进阶到 3+ 的多个难题</strong>，还需要一段时间的整理和编写，预计在明年会放出。</p><p>而从这段时间的社区讨论、问卷反馈中，我也不断在思考<strong>从 0 到 1 或 2 的内容该怎么做</strong>？社区上这块的内容虽然不及 UI 方面的多，但鉴于每个 Android 开发者都必须使用 Gradle，业务上也有多渠道打包、加固等绕不过去的技术需要集成，Android 构建基础的内容还是零星有人分享的，中文社区中例如掘金的 Android 类目下还专门有 Gradle 的小类。那，大家缺的是什么？</p><p><strong>我认为是一个方向，一份大纲。</strong></p><ol>  <li>从 Gradle 的角度切入的系统性教程出现了多年断层，你能找到的图书很多还在使用 “«” 等过时的 API（“doLast(…)” 的符号重载）；</li>  <li>而 Gradle 官方的文档按 <a href=\"https://docs.gradle.org/current/userguide/userguide.pdf\">PDF</a> 版来算有 1200+ 页，面之广，直接覆盖了 1-4 的各层级内容，英文不错的朋友快速读一遍都得花上几天；</li>  <li>从 Android 构建的角度切入的系统性教程几乎没有，一旦碰到复杂点的需求，要求自定义一个简单的 Task 和 AGP 进行交互，就发现缺漏的知识太多，更不知从何入手学起。</li></ol><p><strong>理顺出一条学习路径，加上诸多实例，可能几个篇章就能做出不错的效果，再加上 Kotlin First 的原则，以 KTS 和 Kotlin 编写的插件为例，减少一些 Groovy 的学习成本，我想应该妙极了！</strong> 不出意外的话，十月份我会放出一些有意思的东西。</p><h2 id=\"从-kmm-文档翻译活动到-koge\">从 KMM 文档翻译活动到 KOGE</h2><p>几个月前，由于我工作中使用了 KMM（Kotlin Multi-platform Mobile)，所以决定做点什么—— “kotlin-mobile-docs” 的<a href=\"https://github.com/2BAB/kotlin-mobile-docs\">中文文档翻译计划</a>。以我为初始翻译者，到后来的另外五个小伙伴加入，我们做了大概 60% 的文档翻译。很可惜我们最后没有完成所有的内容，具体原因如项目 README：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210924174118.png?imageslim\" alt=\"\" /></p><p><strong>而上述 Android 构建 0 到 1 的内容，在确定了路线并做好一部分内容后，我依旧想开源到社区，和大家共同打造这个有价值的项目。我起了个项目名字叫 KOGE，意味 <em>Kotlin-oriented Gradle Essential</em>。这次，我们不做翻译，我们做更有意思的自学大纲，做一手的内容，做反向输出到英文社区的内容。</strong></p><p>最后，还没有加过“Android&amp;英语群”的朋友，欢迎来群里玩~ 这里日常吹水的东西很少，但是一手的新知识、新资料很多呀~</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210924174641.png?imageslim\" alt=\"\" /></p><p><em>欢迎关注我的 <a href=\"/about\"> Github / 公众号 / 播客 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/09/24/android-build-survey-result",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建，调研"],
            
            "date_published": "2021-09-24T00:00:00+00:00",
            "date_modified": "2021-09-24T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/09/14/android-build-survey",
            "title": "Android App 编译构建知识的小调查",
            "summary": null,
            "content_text": "不久前写了篇文章《Google I/O 21 Android Gradle Plugin 更新总结》，今天被 Google 的 “Android 开发者” 转载了。但收到了一些反馈是：能不能也写一些更基础的文章。确实我接触过的绝大多数 Android 开发者都对 Android 构建方面的知识有种敬畏感，Gradle + Android Gradle Plugin（AGP）的组合复杂度不低，而互联网上能找到的系统性资料稀少（英文都不多，中文就更少啦）。  底层技术：Gradle、AGP、Annotation Processor（AP）、AAPT、D8&amp;R8、ByteCode modification、Dex modification、Kotlin Compiler、ZIP&amp;APK&amp;AAR&amp;AAB、IDE Plugin、etc.  架构应用：依赖注入、组件化、插件化、多渠道包、SDK 按需接入、白牌应用、多维度测试（单元、集成、功能测试）、安全防护（混淆、加壳、native 加密…），Jetpack Compose、CICD 以及更多其他的自动化流程；编译构建的知识不仅是单独的加快构建速度，也，还作用于运行期。才疏学浅，下方的选项仅基于个人的理解来编写，有不足之处欢迎私信我提建议~  ”仅基础使用“（初级）：我能读懂、修改 build.gradle(.kts)，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；  ”实现高效自动化、工程化“（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 buildSrc 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；  ”编译构建增强“（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；  ”对编译构建有较为全面的理解“（资深）：我了解编译构建的主要环节实现，常见架构应用的原理，实践过多个编译构建增强工具，对项目的基础架构梳理得井井有条；  ”深度参与“：我了解 Android App 编译构建的前沿发展，积极参与社区 Discussion、Proposal、PR、Review，灵活运用、修改各类工具，对于不同类型的问题、需求能给出优解、多解。（为方便统计，参与调研请关注公众号“Android高效开发”进行填写）欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p>不久前写了篇文章<a href=\"https://2bab.me/2021/06/17/google-io-21-agp-recap\">《Google I/O 21 Android Gradle Plugin 更新总结》</a>，今天被 Google 的 “Android 开发者” 转载了。但收到了一些反馈是：能不能也写一些更基础的文章。确实我接触过的绝大多数 Android 开发者都对 Android 构建方面的知识有种敬畏感，Gradle + Android Gradle Plugin（AGP）的组合复杂度不低，而互联网上能找到的系统性资料稀少（英文都不多，中文就更少啦）。</p><blockquote>  <p>底层技术：Gradle、AGP、Annotation Processor（AP）、AAPT、D8&amp;R8、ByteCode modification、Dex modification、Kotlin Compiler、ZIP&amp;APK&amp;AAR&amp;AAB、IDE Plugin、etc.</p></blockquote><blockquote>  <p>架构应用：依赖注入、组件化、插件化、多渠道包、SDK 按需接入、白牌应用、多维度测试（单元、集成、功能测试）、安全防护（混淆、加壳、native 加密…），Jetpack Compose、CICD 以及更多其他的自动化流程；</p></blockquote><p>编译构建的知识不仅是单独的加快构建速度，也，还作用于运行期。才疏学浅，下方的选项仅基于个人的理解来编写，有不足之处欢迎私信我提建议~</p><ol>  <li>”仅基础使用“（初级）：我能读懂、修改 <code class=\"language-plaintext highlighter-rouge\">build.gradle(.kts)</code>，对 Gradle、AGP 有基础的认知，例如了解 Gradle 的任务机制，但碰到非 App 源码的编译错误有点不知所措；</li>  <li>”实现高效自动化、工程化“（中级）：我对工程化、自动化有一定的认知、追求，可以通过构建脚本拆分、自定义 Task 来实现日常事务的优化，例如使用 <code class=\"language-plaintext highlighter-rouge\">buildSrc</code> 模块抽取并统一管理依赖、使用自定义 Task 组合 CICD 的流程，运用一些最佳实践来提高编译构建效率；</li>  <li>”编译构建增强“（高级）：我可以通过查阅 Gradle 文档、Debug AGP、编译期的 Profiler 日志，来自定义 Annotation Processor、Gradle Plugin 等解决一个项目碰到实际问题，抽象成一套可复用的工具；</li>  <li>”对编译构建有较为全面的理解“（资深）：我了解编译构建的主要环节实现，常见架构应用的原理，实践过多个编译构建增强工具，对项目的基础架构梳理得井井有条；</li>  <li>”深度参与“：我了解 Android App 编译构建的前沿发展，积极参与社区 Discussion、Proposal、PR、Review，灵活运用、修改各类工具，对于不同类型的问题、需求能给出优解、多解。</li></ol><p><img src=\"https://2bab-images.lastmayday.com/blog/20210924115821.png?imageslim\" alt=\"\" /></p><p>（为方便统计，参与调研请关注公众号“Android高效开发”进行填写）</p><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/09/14/android-build-survey",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建，调研"],
            
            "date_published": "2021-09-14T00:00:00+00:00",
            "date_modified": "2021-09-14T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/08/07/android-dev-tool-composition-on-m1",
            "title": "构建指北 #10 Android 开发工具兼容性",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。发现问题，解决问题，传递新知，提高效率。由于几个月前电脑 CPU 烧了，被迫换了 M1 的 Mac Mini，所以整个开发环境重新搭建了一遍。趁这个机会，我想整理几个基础工具的版本搭配策略、兼容性、以及在 M1 芯片上的表现。对于版本搭配和兼容性的一些讨论不局限于当前使用的版本和平台。下方提及的版本分别是：  Zulu JDK: 11.0.11  Kotlin: 1.5.21  Gradle: 7.1.1  Android Gradle Plugin（AGP）: 7.0 &amp; 7.1  Android Studio: Arctic Fox 2020.3.1 &amp; BumbleBee 2021.1.1 Canary 6JDK自 AGP 7.0 起，JDK 11 便是最低要求。JDK 11 成为 LTS（Long-term Support) 版本已经有将近 3 年历史（Sep 2018），自身经历了 12 个小版本（11.0.12）的迭代目前相对成熟了。作为对比，上一个 LTS 的 JDK 8 2014 年发布，已经陪着我们走过了 7 年时光和 300 个小版本迭代。事实上作为 Android 开发者，即便目前项目是 Java 为主的情况，一般 Language Level 也仅 target to 1.8（一些 9-12 的特性 D8、R8 有支持，Android 11 12 也有融入）。Android 官方虽然说不会放弃 Java，但实际上对 Kotlin 的支持确实更给力。从这个角度来看，JDK 11 带来给我们的更多是：  Kotlin Compiler、Gradle、IDE 层面上性能的升级；  JDK 8 将停止维护的情况下（3 年后），安全层面的持续保障；  适应新的发布机制，每半年一个小版本，三年一个 LTS 大版本，减少历史包袱跑得更快；而 JDK 的升级策略我认为是：  保守派：如果不在意新语言特性，可以等每年 AGP 升级的情况来决定 JDK 的版本，因为 IDE 一般 bundle 了一个 JDK，Kotlin 编译器、Gradle 一直追着最新 JDK 并有不错的向下兼容——所以根据木桶原理等 AGP 升级了再升即可，目前看来 AGP 可能也只跟进比较稳定的 LTS 版本；  激进派：Gradle 支持后即可测试；在 M1 Mac 上，由于 Oracle 还未有的 ARM64 版本，所以目前主流的做法是安装 Azul 维护的 Zulu JDK11。需要注意的是，常用的 JDK 管理工具 SDKMAN! 在我的测试中依旧跑在 Rosetta 2 的转译环境中。这会造成即便你是安装的 Zulu JDK11，通过 SDKMAN! 的脚本启动依然会显示 Gradle java 的进程跑在 Intel ABI 下。故目前建议从官网下载安装，等后续配套工具支持后再考虑切换。KotlinKotlin 的版本搭配限制相对不多，一般我考虑三个点：  有没有特别吸引人的新功能，比如刚放出稳定版的 Coroutine、Flow，或者新版本 Kotlin Multiplatform Mobile 的更好支持等；  用不用大迭代的第一个版本，例如观察刚发布时的 1.4.0，1.5.0，这条其实广泛适用于各类 Library；  Gradle 目前 bundle/test 的 Kotlin 的版本，例如最新的 7.1.1 stable 依旧是用的 1.4.31 的 Kotlin（7.2 RC 则跳到 1.5.21 了）；关于最后一点，如果使用的 Kotlin 版本和 Gradle bundle 的不一致，会出现如下 Warning：  w: Runtime JAR files in the classpath should have the same version. &gt;These files were found in the classpath: …   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.4.31/84ce8e85f6e84270b2b501d44e9f0ba6ff64fa71/kotlin-stdlib-jdk7-1.4.31.jar (version 1.4)   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.21/2f537cad7e9eeb9da73738c8812e1e4cf9b62e4e/kotlin-stdlib-1.5.21.jar (version 1.5)   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-common/1.5.21/cc8bf3586fd2ebcf234058b9440bb406e62dfacb/kotlin-stdlib-common-1.5.21.jar (version 1.5)w: Consider providing an explicit dependency on kotlin-reflect 1.5 to prevent strange errorsw: Some runtime JAR files in the classpath have an incompatible version. Consider removing them from the用一个简单的例子看下问题是怎么发生的：plugins {    id(\"com.android.application\")    // 没有指定版本，用的就是 Gradle bundle 的版本，    // Gradle 7.1.1 对应的就是 Kotlin 1.4.31 的各种类库和编译工具    kotlin(\"android\") }dependencies {    // 而这里我们却用了 1.5.21 的最新版 Kotlin，就会出现如上问题    implementation(\"org.jetbrains.kotlin:kotlin-stdlib:1.5.21\")}解决起来也很简单：plugins {    id(\"com.android.application\")    // 手动指定版本    kotlin(\"android\") version \"1.5.21\"}Kotlin 官方的文档直接就演示了加版本号的写法。但是，这个版本是 Kotlin 基于 Gradle 测试通过，而 Gradle 自身还没有基于它测试过并打包进去（见 Gradle 部分的配图），若出现了问题可能难以解决：所以我推荐的升级策略是：  保守派：等 Gradle 升级的时候再升级，例如 1.5.0 到 1.5.21 中间仅隔了两个月，Gradle 就跟进了；  激进派：有实用的新功能或者大版本迭代后的第一个补丁版本就升。Gradle前面提到 Kotlin 的官方文档解释了各类和 Gradle 配合兼容的情况，反过来 Gradle 这边也有一个标明了 Java、Kotlin、Android 等各语言和平台的支持文档。像前面提到的 Java 版本支持，Kotlin 版本支持在这里便一目了然。除了 Kotlin 的支持会稍落后一两个月，其他工具的最新版本兼容都不成问题。而 Gradle 自身的向下兼容我觉得还不错，我基本上每个版本都升级。而上层的 AGP DSL，特别是老版本，则挺经常有大改动（好在 7.0 后终于强多了）。所以我推荐的升级策略是：  保守派：根据 AGP 的文档按最低版本进行升级（详见下图），例如 AGP 4.2.0+ 对应 Gradle 6.7.1+；  激进派：每个补丁版本(x.y.1/2/3)或者每个版本都升（Gradle 没有 -betaX 的版本习惯，一般就是 Nightly 和 RC）。另外，Gradle 7.0 后的版本原生支持了 M1，我个人的使用体验还不错。Android Gradle PluginAGP 的版本搭配限制我们在前面基本都介绍完了，以 7.0 为例，我们来看官方 Release Note 的兼容说明：额外补充一点：从 AGP 7.0 起，其版本会同步 Gradle 的 major 版本，严格遵守 Semantic Versioning 体系（之前同步的是 AS 的版本）。也即 AGP 7.x 会适配 Gradle 7.x 的版本。不过 AGP 的发布时间依旧是随着 AS 一起发布，并且目前来看其 alpha/beta 的数字是跟随 AS 的，所以其实可以当成三者形成了某种默契的同步机制。所以我推荐的升级策略是：  保守派：随 AS 正式版升级（或适当跳过第一个大版本更迭）；  激进派：每个版本都升，或从 alpha/beta 开始升级，例如要做 Gradle 插件适配。Android StudioAS 基本上没有什么搭配限制，只要你用的之前正式版的 AGP，AS 就可以向下兼容。我推荐的升级策略是：  保守派：适当跳过第一个大版本更迭；  激进派：每个版本都升，或从 alpha/beta 开始升级，例如要做 IDE 插件适配或者对 Compose、调试工具新功能等有需求的。另外，由于 AS 基于的 IDEA 社区版二次开发，整体稳定性、新特性支持的速度都不如 IDEA Ultimate，例如 Gradle 的 nesting Composite Build 目前就不在 AS 支持范围，见该 issue。最后，自 Arctic Fox 2020.3.1 起，AS 原生支持了 M1，但如果想有更流畅的体验，我认为 BumbleBee 2021.1.1 Canary 效果更好一些。IDEAIDEA 的主要搭配限制来自于 Android Plugin（Android IDE 插件）的版本适配。一般来说，在 AS 新的正式版本发布之后，下一个 IDEA 的正式版本就会带上该新版插件，从而对Android 开发包括 AGP 做支持。偶尔也有等比较久的时候，比如今年 AS&amp;AGP 4.2 在 4 月发布，而直到 7 月 IDEA 2021.2 发布时，才更新了 Android Plugin，官方的说法是 Google 放出 AGP 4.2 的源码时间晚了些，导致没赶上 2021.1 的版本。我推荐的升级策略是：  保守派：仅升级正式版本；  激进派：从 EAP 或 RC 开始升级，例如会获得比较好的 Kotlin 支持、更早的 AGP 支持，以及 M1 平台的优化等。最后，2021.2 也是让我在 M1 感觉终于不再有什么卡顿的版本了。总结我自己由于使用 M1 的平台 + 适配一些 Gradle Plugin，经常会使用 beta 甚至 alpha 的 AGP（作为 Runtime 的 library），配合最新的 IDEA Ultimate 开发起来还是挺顺手。而公司项目，现阶段 x86 平台我觉得可以使用如下配置，ARM M1 则根据上文调整对应的工具版本：  JDK 11（由于 AGP 升了迟早要升级）  Gradle 7.1.1（7.2 支持 1.5.21 后可以升级）  Kotlin 1.4.31  AGP 4.2.2（7.0 稳定了新版的 Variant API，马上 7.1 也稳定新版的 DSL，不需要 Compose 的话可以观望观望）  AS 4.2.2（不需要 Compose 的话可以观望观望）  IDEA 2021.2欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。发现问题，解决问题，传递新知，提高效率。</em></p><p>由于几个月前电脑 CPU 烧了，被迫换了 M1 的 Mac Mini，所以整个开发环境重新搭建了一遍。趁这个机会，我想整理几个基础工具的版本搭配策略、兼容性、以及在 M1 芯片上的表现。对于版本搭配和兼容性的一些讨论不局限于当前使用的版本和平台。</p><p>下方提及的版本分别是：</p><ul>  <li>Zulu JDK: 11.0.11</li>  <li>Kotlin: 1.5.21</li>  <li>Gradle: 7.1.1</li>  <li>Android Gradle Plugin（AGP）: 7.0 &amp; 7.1</li>  <li>Android Studio: Arctic Fox 2020.3.1 &amp; BumbleBee 2021.1.1 Canary 6</li></ul><h2 id=\"jdk\">JDK</h2><p><strong>自 AGP 7.0 起，JDK 11 便是最低要求</strong>。JDK 11 成为 LTS（Long-term Support) 版本已经有将近 3 年历史（Sep 2018），自身经历了 12 个小版本（11.0.12）的迭代目前相对成熟了。作为对比，上一个 LTS 的 JDK 8 2014 年发布，已经陪着我们走过了 7 年时光和 300 个小版本迭代。事实上作为 Android 开发者，即便目前项目是 Java 为主的情况，一般 Language Level 也仅 target to 1.8（一些 9-12 的特性 D8、R8 有支持，Android 11 12 也有融入）。Android 官方虽然说不会放弃 Java，但实际上对 Kotlin 的支持确实更给力。</p><p>从这个角度来看，JDK 11 带来给我们的更多是：</p><ul>  <li>Kotlin Compiler、Gradle、IDE 层面上性能的升级；</li>  <li>JDK 8 将停止维护的情况下（3 年后），安全层面的持续保障；</li>  <li>适应新的发布机制，每半年一个小版本，三年一个 LTS 大版本，减少历史包袱跑得更快；</li></ul><p>而 JDK 的升级策略我认为是：</p><ul>  <li><strong>保守派：如果不在意新语言特性，可以等每年 AGP 升级的情况来决定 JDK 的版本，因为 IDE 一般 bundle 了一个 JDK，Kotlin 编译器、Gradle 一直追着最新 JDK 并有不错的向下兼容——所以根据木桶原理等 AGP 升级了再升即可，目前看来 AGP 可能也只跟进比较稳定的 LTS 版本；</strong></li>  <li><strong>激进派：Gradle 支持后即可测试；</strong></li></ul><p>在 M1 Mac 上，由于 Oracle 还未有的 ARM64 版本，所以目前主流的做法是安装 <a href=\"https://www.azul.com/downloads/?package=jdk\">Azul</a> 维护的 <code class=\"language-plaintext highlighter-rouge\">Zulu JDK11</code>。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210805160844.png?imageslim\" alt=\"\" /></p><p>需要注意的是，常用的 JDK 管理工具 <code class=\"language-plaintext highlighter-rouge\">SDKMAN!</code> 在我的测试中依旧跑在 <code class=\"language-plaintext highlighter-rouge\">Rosetta 2</code> 的转译环境中。这会造成即便你是安装的 <code class=\"language-plaintext highlighter-rouge\">Zulu JDK11</code>，通过 <code class=\"language-plaintext highlighter-rouge\">SDKMAN!</code> 的脚本启动依然会显示 Gradle <code class=\"language-plaintext highlighter-rouge\">java</code> 的进程跑在 Intel ABI 下。故目前建议从官网下载安装，等后续配套工具支持后再考虑切换。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210805162529.png?imageslim\" alt=\"\" /></p><h2 id=\"kotlin\">Kotlin</h2><p>Kotlin 的版本搭配限制相对不多，一般我考虑三个点：</p><ul>  <li>有没有特别吸引人的新功能，比如刚放出稳定版的 Coroutine、Flow，或者新版本 Kotlin Multiplatform Mobile 的更好支持等；</li>  <li>用不用大迭代的第一个版本，例如观察刚发布时的 <code class=\"language-plaintext highlighter-rouge\">1.4.0</code>，<code class=\"language-plaintext highlighter-rouge\">1.5.0</code>，这条其实广泛适用于各类 Library；</li>  <li>Gradle 目前 bundle/test 的 Kotlin 的版本，例如最新的 7.1.1 stable 依旧是用的 <code class=\"language-plaintext highlighter-rouge\">1.4.31</code> 的 Kotlin（7.2 RC 则跳到 <code class=\"language-plaintext highlighter-rouge\">1.5.21</code> 了）；</li></ul><p>关于最后一点，如果使用的 Kotlin 版本和 Gradle bundle 的不一致，会出现如下 Warning：</p><blockquote>  <p>w: Runtime JAR files in the classpath should have the same version. &gt;These files were found in the classpath: …   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.4.31/84ce8e85f6e84270b2b501d44e9f0ba6ff64fa71/kotlin-stdlib-jdk7-1.4.31.jar (version 1.4)   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.5.21/2f537cad7e9eeb9da73738c8812e1e4cf9b62e4e/kotlin-stdlib-1.5.21.jar (version 1.5)   /Users/2bab/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-common/1.5.21/cc8bf3586fd2ebcf234058b9440bb406e62dfacb/kotlin-stdlib-common-1.5.21.jar (version 1.5)w: Consider providing an explicit dependency on kotlin-reflect 1.5 to prevent strange errorsw: Some runtime JAR files in the classpath have an incompatible version. Consider removing them from the</p></blockquote><p>用一个简单的例子看下问题是怎么发生的：</p><pre><code class=\"language-Kotlin\">plugins {    id(\"com.android.application\")    // 没有指定版本，用的就是 Gradle bundle 的版本，    // Gradle 7.1.1 对应的就是 Kotlin 1.4.31 的各种类库和编译工具    kotlin(\"android\") }dependencies {    // 而这里我们却用了 1.5.21 的最新版 Kotlin，就会出现如上问题    implementation(\"org.jetbrains.kotlin:kotlin-stdlib:1.5.21\")}</code></pre><p>解决起来也很简单：</p><pre><code class=\"language-Kotlin\">plugins {    id(\"com.android.application\")    // 手动指定版本    kotlin(\"android\") version \"1.5.21\"}</code></pre><p>Kotlin <a href=\"https://kotlinlang.org/docs/gradle.html\">官方的文档</a>直接就演示了加版本号的写法。<strong>但是，这个版本是 Kotlin 基于 Gradle 测试通过，而 Gradle 自身还没有基于它<a href=\"https://docs.gradle.org/7.1.1/userguide/compatibility.html\">测试</a>过并打包进去（见 Gradle 部分的配图），若出现了问题可能难以解决</strong>：</p><p>所以我推荐的升级策略是：</p><ul>  <li><strong>保守派：等 Gradle 升级的时候再升级，例如 1.5.0 到 1.5.21 中间仅隔了两个月，Gradle 就跟进了；</strong></li>  <li><strong>激进派：有实用的新功能或者大版本迭代后的第一个补丁版本就升。</strong></li></ul><h2 id=\"gradle\">Gradle</h2><p>前面提到 Kotlin 的官方文档解释了各类和 Gradle 配合兼容的情况，反过来 Gradle 这边也有一个标明了 Java、Kotlin、Android 等各语言和平台的<a href=\"https://docs.gradle.org/7.1.1/userguide/compatibility.html\">支持文档</a>。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210805214442.png?imageslim\" alt=\"\" /></p><p>像前面提到的 Java 版本支持，Kotlin 版本支持在这里便一目了然。除了 Kotlin 的支持会稍落后一两个月，其他工具的最新版本兼容都不成问题。而 Gradle 自身的向下兼容我觉得还不错，我基本上每个版本都升级。而上层的 AGP DSL，特别是老版本，则挺经常有大改动（好在 7.0 后终于强多了）。</p><p>所以我推荐的升级策略是：</p><ul>  <li><strong>保守派：根据 AGP 的<a href=\"https://developer.android.com/studio/releases/gradle-plugin\">文档</a>按最低版本进行升级（详见下图），例如 AGP 4.2.0+ 对应 Gradle 6.7.1+；</strong></li>  <li><strong>激进派：每个补丁版本(x.y.1/2/3)或者每个版本都升（Gradle 没有 -betaX 的版本习惯，一般就是 Nightly 和 RC）。</strong></li></ul><p><img src=\"https://2bab-images.lastmayday.com/blog/20210806211434.png?imageslim\" alt=\"\" /></p><p>另外，Gradle 7.0 后的版本原生支持了 M1，我个人的使用体验还不错。</p><h2 id=\"android-gradle-plugin\">Android Gradle Plugin</h2><p>AGP 的版本搭配限制我们在前面基本都介绍完了，以 7.0 为例，我们来看官方 Release Note 的兼容说明：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210806214019.png?imageslim\" alt=\"\" /></p><p>额外补充一点：从 AGP 7.0 起，其版本会<a href=\"https://android-developers.googleblog.com/2020/12/announcing-android-gradle-plugin.html\">同步 Gradle 的 major 版本</a>，严格遵守 Semantic Versioning 体系（之前同步的是 AS 的版本）。也即 AGP 7.x 会适配 Gradle 7.x 的版本。不过 AGP 的发布时间依旧是随着 AS 一起发布，并且目前来看其 alpha/beta 的数字是跟随 AS 的，所以其实可以当成三者形成了某种默契的同步机制。</p><p>所以我推荐的升级策略是：</p><ul>  <li><strong>保守派：随 AS 正式版升级（或适当跳过第一个大版本更迭）；</strong></li>  <li><strong>激进派：每个版本都升，或从 alpha/beta 开始升级，例如要做 Gradle 插件适配。</strong></li></ul><h2 id=\"android-studio\">Android Studio</h2><p>AS 基本上没有什么搭配限制，只要你用的之前正式版的 AGP，AS 就可以向下兼容。我推荐的升级策略是：</p><ul>  <li><strong>保守派：适当跳过第一个大版本更迭；</strong></li>  <li><strong>激进派：每个版本都升，或从 alpha/beta 开始升级，例如要做 IDE 插件适配或者对 Compose、调试工具新功能等有需求的。</strong></li></ul><p>另外，由于 AS 基于的 IDEA 社区版二次开发，整体稳定性、新特性支持的速度都不如 IDEA Ultimate，例如 Gradle 的 nesting Composite Build 目前就不在 AS 支持范围，见该 <a href=\"https://issuetracker.google.com/issues/189366120\">issue</a>。</p><p>最后，自 Arctic Fox 2020.3.1 起，AS 原生支持了 M1，但如果想有更流畅的体验，我认为 BumbleBee 2021.1.1 Canary 效果更好一些。</p><h2 id=\"idea\">IDEA</h2><p>IDEA 的主要搭配限制来自于 Android Plugin（Android IDE 插件）的版本适配。一般来说，在 AS 新的正式版本发布之后，下一个 IDEA 的正式版本就会带上该新版插件，从而对Android 开发包括 AGP 做支持。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210807154410.png?imageslim\" alt=\"\" /></p><p>偶尔也有等比较久的时候，比如今年 AS&amp;AGP 4.2 在 4 月发布，而直到 7 月 IDEA 2021.2 <a href=\"https://www.jetbrains.com/idea/whatsnew/#Other\">发布</a>时，才更新了 Android Plugin，官方的说法是 Google 放出 AGP 4.2 的源码时间晚了些，导致没赶上 2021.1 的版本。</p><p>我推荐的升级策略是：</p><ul>  <li><strong>保守派：仅升级正式版本；</strong></li>  <li><strong>激进派：从 EAP 或 RC 开始升级，例如会获得比较好的 Kotlin 支持、更早的 AGP 支持，以及 M1 平台的优化等。</strong></li></ul><p>最后，2021.2 也是让我在 M1 感觉终于不再有什么卡顿的版本了。</p><h2 id=\"总结\">总结</h2><p>我自己由于使用 M1 的平台 + 适配一些 <a href=\"https://github.com/2BAB\">Gradle Plugin</a>，经常会使用 beta 甚至 alpha 的 AGP（作为 Runtime 的 library），配合最新的 IDEA Ultimate 开发起来还是挺顺手。</p><p>而公司项目，现阶段 x86 平台我觉得可以使用如下配置，ARM M1 则根据上文调整对应的工具版本：</p><ul>  <li>JDK 11（由于 AGP 升了迟早要升级）</li>  <li>Gradle 7.1.1（7.2 支持 1.5.21 后可以升级）</li>  <li>Kotlin 1.4.31</li>  <li>AGP 4.2.2（7.0 稳定了新版的 Variant API，马上 7.1 也稳定新版的 DSL，不需要 Compose 的话可以观望观望）</li>  <li>AS 4.2.2（不需要 Compose 的话可以观望观望）</li>  <li>IDEA 2021.2</li></ul><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/08/07/android-dev-tool-composition-on-m1",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2021-08-07T00:00:00+00:00",
            "date_modified": "2021-08-07T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/07/11/dev-exp-monthly-update-01",
            "title": "AB 的工程效率小集 #1 七月刊",
            "summary": null,
            "content_text": "约是年初开始，我持续不断地在一些较有讨论氛围的社区、社群，参与我感兴趣的技术话题互动。经过半年的体验，这类持续输入输出对我个人有不少的收获。一方面我能从这些社区社群看到不少新东西，例如第一时间看到世界各地的技术访谈、博客、新闻、活动；另外一方面我的知识体系在反哺社区和讨论的过程中逐步完善。可惜，不少的社区社群并不能被搜索引擎记录，例如 Slack、星球、以及各种普通 IM 工具内的群组。在第八期“二分电台”讨论”持续学习“话题时，Randy 和我聊到了《Learn in Public》这篇文章——是的，固然加入了某个 Slack 社区后可以在里面搜索历史记录，但是它依然不是搜索引擎可见的。特别像 Gradle 这类大家“熟悉的陌生人”，我们每天都在用，但真碰到一个什么奇怪的问题想赶紧知道（不一定是 bug，可能只是一个用法、一个 API 的理解等），目前最好的办法还是去他们的 Slack 社区互动，纵然他们有论坛和 StackOverflow 的 tag。这些“封闭”的内容无法有效地被更广泛的人群接受，新手很难从外部获取到最新的资讯、讨论；以至于我有时候甚至觉得技术分享的视频如果不把 timeline 和关键字标注出来，也会流失大量本来可以点击进入的观众。所以，我一直有这个想法：做一个月度或者半月的小集合，把我参与过、具有通用价值的一些东西记录下来、公开出去。  这类问答式的内容，如果单独写成一篇，可能有些 overkill 了，所以定位在一个月度的小集的形式；  目前以我参与过的内容为主，在所有的内容确保是无版权、或者我拥有版本的情况下，再整理、记录、沉淀，后面也会考虑加入一些 Slack 或其他群组上我看到的精彩内容；  至于分发形式，我斟酌的结论是：先在我的博客记录，公众号/掘金等二次分发，如果有其他朋友参与一起做且方向比较统一在工程效率和开发体验这块的话，可以尝试 Substack 这种邮件订阅的形式做订阅。但目标是不变的，需要在公开的互联网领域留下这些有参考价值的内容。OK，那我们进入第一期的正文。2021 年 7 月工程效率小集：构建：Gradle/AGP/CI/…Q1: To pass a bunch of File which come from different dirs, should I use SetProperty&lt;File&gt; or SetProperty&lt;RegularFile&gt; ?A1:  @vierbergenlars: I think a FileCollection is better suited for that.It also gives you some nice additional methods to add files and to manage them.  @wolfs: I agree, ConfigurableFileCollection is the analog to RegularFile/DirectoryProperty for multiple files.这则问答来自于 Gradle Slack 社区，起因是我在写一个 demo 时发现有一个场景是需要收集一些来自不同文件夹的文件，并传入到某个 Task。对于这类场景，不管是多个文件、文件夹，或者混合的场景，使用 FileCollection 都是比较好的选项，因为它的 API 在面对这类场景时比较友好，比如 from(varags Object)。如果想保持一致性都使用 Provider，可以使用 FileCollection.getElements() API 转换。对这些类不了解的朋友可以参考 Working with Files 和 Lazy Configurations。Q2: Gradle 7.1 + zulu arm64 JDK11 do not run natively on my M1 Mac mini.A2: 这则问题我后来自己发现了问题（小黄鸭调试法），因为我使用 SDKMAN! 安装的 zulu 的sdk，但是 SDKMAN! 本身是通过 Rosetta2 转译运行的，加上它在命令行 bash_profile / zshrc 添加了一些东西（没细看了…大概是为了支持 Java 版本的切换等），导致 Gradle 起 java 进程时也都通过 Rosetta2 去跑。删掉重装后即可。Q3：From the performance perspective, is buildSrc still a bit worse than composite build?A3:      @Vampire: This should still be true, but depending on your test project you might or might not be hit by a performance hit compared to composite builds. If your test project is too simple you will for example not see any difference. The point is, that buildSrc is automatically added to the class path of all build scripts in the main build and due to that the runtime class path of all tasks changed and thus all tasks in all projects are out of date if anything in buildSrc changes. If you use composite builds instead, only the dependencies you actually use by applying a plugin or adding it to the buildscript dependencies block are added to the class path of that specific build script, so all other build scripts / projects stay unaffected. If you apply all plugins you have to all projects you have, then there sill probabaly be no performance difference, as then still all tasks are going to be out of date when something is changed.I personally only use composite builds nowadays, also because I can then easily use composite build within (though there is a “work-around” now) and I can also move and rename it, for example to &lt;root project&gt;/gradle/build-logic instead of &lt;root project&gt;/buildSrc.        @CristianGM: And…I should add another small difference, buildSrc runs its tests when it compiles, while composite build doesn’t  这则问题讨论了在哪些情况下 composite-build 优于 buildSrc，主要的性能问题集中在是否把这个额外的编译脚本模块 apply 到所有的主代码模块中。Q4: 我执行 gradlew bundle 命令的时候，为什么每个 product flavor 里面的配置都会被执行一次？如何给渠道设置版本名称？producatFlavors {     india {         setProperty(\"archivesBaseName\", \"urbanic-${versioNameIndia}-${currentVersionCode}\"     }        india {         setProperty(\"archivesBaseName\", \"urbanic-${versioNameOther}-${currentVersionCode}\"     }}A4:  Gradle 配置阶段的脚本是全部都会执行的，不然没法得到配置好的 Extension，也没办法得到 Task Graph；  就这段脚本而言它是执行 Flavor 的配置，像 dimension applicationIdSuffix buildConfigField 都是作用于 flavor 的（隐藏的 this 是 ProdcutFlavor)，setProperty 是作用于 project 的，所以会被覆盖；  archivesBaseName 的配置看了下是从 Gradle API 来的，并不是 AGP 的（AGP 有挺多地方用了不过，但是没法搞 variant aware 的策略），如果你真想 hack 一下，那就根据你输入的命令 hardcode 对应的 property：if(gradle.startParameter.getTaskNames().get(0).contains(\"India\")) { setProperty(...) }  现在应该用这个了 Artifacts API：https://github.com/android/gradle-recipes/blob/agp-4.2/Kotlin/getApksTest/app/build.gradle.kts （可以切分支查看不同版本 AGP 的 API，7.0 后稳定了），添加一个 Task 获取对应渠道 APK 后再修改名称。Q5: 对于想在 assembleDebug 后对 APK 执行一些操作的情况，可以用 finalizeBy()。A5:我也经常忍不住用😂，但是这个 API 有几个问题：  如果一个 task 有多个 finalizer，它们是按 finalizer 的名字排序（相当于乱序；  Finalizer 可不管前一个任务执行成功没(见附图)，只要前一个任务执行了，它就总是会接着执行；上面两点其实是 by design 的，所以官方文档的用例是用来做 task 的资源清理工作。我一直觉得自己有点滥用，不过有需要没办法的时候也只能用。就这个 case 可能的几个别的解法是：  用 doLast()，但是只接受 Action 而不是 Task；  反向 dependsOn(), 让 apkRenameDebug.dependsOn(resguardDebug)，然后执行终端执行 apkRenameDebug；  加一个类似 lifecycle task 的锚点 task 作为最后运行的 task，然后把前面那些 task 往他上面 dependsOn()，算是 2 的优化版（比较好看干净）；  用 buildFinish() 生命周期监听器，所有任务跑完后取 apk 做处理可以不需要依赖 AGP；  用新的 Artifacts API （见 A4 的链接）。Kotlin 周边：Koin/Ktor/Coil/…Q1: Is it possible a feature/plugin depends on another?I need to transform the type with my feature before JsonFeature get it. The problem is JsonFeature should be able to parse SomeError or User, so I have to unwrap it from my Either before, if not, JsonFeature will try it with the Either class and it will fail.A1: For ktor client’s plugin I used/created, I don’t think there’s a direct approach to implement this. But if u look into their implementations, can see the interceptor pipelines - base on the lifecycle of those pipeline, u can define the running sequence and thus make dependent relationship indirectly. In this case, probably u can use HttpResponsePipeline.Receive in your custom plugin to unwrap before JsonFeature works.scope.responsePipeline.intercept(HttpResponsePipeline.Receive) { (info, body) -&gt;    if (body !is ByteReadChannel) { return @intercept}    // Do something you want and get the final result in String (others types I did not try)    val result: String = decrypt(body.readRemaining().readText())    proceedWith(HttpResponseContainer(info, ByteReadChannel(result)))}Q2: Coil 加载时报错 Software rendering doesn't support hardware bitmapsA2：  Recipes - Coil，你大概率是碰到了：Shared element transitions are incompatible with hardware bitmaps；  除了上面那个，还有一些机型原生不支持，以及 OS 版本原生不支持的，库本身应该是处理好了：https://github.com/coil-kt/coil/blob/main/coil-base/src/main/java/coil/memory/HardwareBitmapService.kt  查看所有相关 issue，比如这个，没有看到超出上述范围的讨论，所以我觉得应该就是这样啦。欢迎关注我的 Github / 公众号 / 播客 / 微博 / Twitter。",
            "content_html": "<p>约是年初开始，我持续不断地在一些较有讨论氛围的社区、社群，参与我感兴趣的技术话题互动。经过半年的体验，这类持续输入输出对我个人有不少的收获。一方面我能从这些社区社群看到不少新东西，例如第一时间看到世界各地的技术访谈、博客、新闻、活动；另外一方面我的知识体系在反哺社区和讨论的过程中逐步完善。</p><p>可惜，不少的社区社群并不能被搜索引擎记录，例如 Slack、星球、以及各种普通 IM 工具内的群组。在第八期<a href=\"https://binary.2bab.me/episodes/008-enlightenment-n-self-innovation\">“二分电台”</a>讨论”持续学习“话题时，Randy 和我聊到了<a href=\"https://www.swyx.io/learn-in-public/\">《Learn in Public》</a>这篇文章——是的，<strong>固然加入了某个 Slack 社区后可以在里面搜索历史记录，但是它依然不是搜索引擎可见的</strong>。特别像 Gradle 这类大家“熟悉的陌生人”，我们每天都在用，但真碰到一个什么奇怪的问题想赶紧知道（不一定是 bug，可能只是一个用法、一个 API 的理解等），目前最好的办法还是去他们的 Slack 社区互动，纵然他们有论坛和 StackOverflow 的 tag。<strong>这些“封闭”的内容无法有效地被更广泛的人群接受，新手很难从外部获取到最新的资讯、讨论；以至于我有时候甚至觉得技术分享的视频如果不把 timeline 和关键字标注出来，也会流失大量本来可以点击进入的观众。</strong></p><p>所以，我一直有这个想法：做一个月度或者半月的小集合，把我参与过、具有通用价值的一些东西记录下来、公开出去。</p><ul>  <li>这类问答式的内容，如果单独写成一篇，可能有些 overkill 了，所以定位在一个月度的小集的形式；</li>  <li>目前以我参与过的内容为主，在所有的内容确保是无版权、或者我拥有版本的情况下，再整理、记录、沉淀，后面也会考虑加入一些 Slack 或其他群组上我看到的精彩内容；</li>  <li>至于分发形式，我斟酌的结论是：先在我的博客记录，公众号/掘金等二次分发，如果有其他朋友参与一起做且方向比较统一在工程效率和开发体验这块的话，可以尝试 Substack 这种邮件订阅的形式做订阅。但目标是不变的，需要在公开的互联网领域留下这些有参考价值的内容。</li></ul><p>OK，那我们进入第一期的正文。<strong>2021 年 7 月工程效率小集：</strong></p><h2 id=\"构建gradleagpci\">构建：Gradle/AGP/CI/…</h2><p><strong><a href=\"https://gradle-community.slack.com/archives/CA7UM03V3/p1624871227328200\">Q1</a>: To pass a bunch of File which come from different dirs, should I use <code class=\"language-plaintext highlighter-rouge\">SetProperty&lt;File&gt;</code> or <code class=\"language-plaintext highlighter-rouge\">SetProperty&lt;RegularFile&gt;</code> ?</strong></p><p>A1:</p><ul>  <li>@vierbergenlars: I think a FileCollection is better suited for that.It also gives you some nice additional methods to add files and to manage them.</li>  <li>@wolfs: I agree, ConfigurableFileCollection is the analog to RegularFile/DirectoryProperty for multiple files.</li></ul><p>这则问答来自于 Gradle Slack 社区，起因是我在写一个 demo 时发现有一个场景是需要收集一些来自不同文件夹的文件，并传入到某个 Task。对于这类场景，不管是多个文件、文件夹，或者混合的场景，使用 <code class=\"language-plaintext highlighter-rouge\">FileCollection</code> 都是比较好的选项，因为它的 API 在面对这类场景时比较友好，比如 <code class=\"language-plaintext highlighter-rouge\">from(varags Object)</code>。如果想保持一致性都使用 <code class=\"language-plaintext highlighter-rouge\">Provider</code>，可以使用 <code class=\"language-plaintext highlighter-rouge\">FileCollection.getElements()</code> API 转换。对这些类不了解的朋友可以参考 <a href=\"https://docs.gradle.org/current/userguide/working_with_files.html#working_with_files\">Working with Files</a> 和 <a href=\"https://docs.gradle.org/current/userguide/lazy_configuration.html\">Lazy Configurations</a>。</p><p><strong><a href=\"https://gradle-community.slack.com/archives/CA7UM03V3/p1624759837322700\">Q2</a>: Gradle 7.1 + zulu arm64 JDK11 do not run natively on my M1 Mac mini.</strong></p><p>A2: 这则问题我后来自己发现了问题（小黄鸭调试法），因为我使用 SDKMAN! 安装的 zulu 的sdk，但是 SDKMAN! 本身是通过 Rosetta2 转译运行的，加上它在命令行 <code class=\"language-plaintext highlighter-rouge\">bash_profile</code> / <code class=\"language-plaintext highlighter-rouge\">zshrc</code> 添加了一些东西（没细看了…大概是为了支持 Java 版本的切换等），导致 Gradle 起 java 进程时也都通过 Rosetta2 去跑。删掉重装后即可。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210712213206.png?imageslim\" alt=\"\" /></p><p><strong><a href=\"https://gradle-community.slack.com/archives/CA83B1VLL/p1622211648007000\">Q3</a>：From the performance perspective, is buildSrc still a bit worse than composite build?</strong></p><p>A3:</p><ul>  <li>    <p>@Vampire: This should still be true, but depending on your test project you might or might not be hit by a performance hit compared to composite builds. If your test project is too simple you will for example not see any difference. The point is, that <code class=\"language-plaintext highlighter-rouge\">buildSrc</code> is automatically added to the class path of all build scripts in the main build and due to that the runtime class path of all tasks changed and thus all tasks in all projects are out of date if anything in <code class=\"language-plaintext highlighter-rouge\">buildSrc</code> changes. If you use composite builds instead, only the dependencies you actually use by applying a plugin or adding it to the <code class=\"language-plaintext highlighter-rouge\">buildscript</code> dependencies block are added to the class path of that specific build script, so all other build scripts / projects stay unaffected. If you apply all plugins you have to all projects you have, then there sill probabaly be no performance difference, as then still all tasks are going to be out of date when something is changed.I personally only use composite builds nowadays, also because I can then easily use composite build within (though there is a “work-around” now) and I can also move and rename it, for example to <code class=\"language-plaintext highlighter-rouge\">&lt;root project&gt;/gradle/build-logic</code> instead of <code class=\"language-plaintext highlighter-rouge\">&lt;root project&gt;/buildSrc</code>.</p>  </li>  <li>    <p>@CristianGM: And…I should add another small difference, buildSrc runs its tests when it compiles, while composite build doesn’t</p>  </li></ul><p>这则问题讨论了在哪些情况下 composite-build 优于 buildSrc，主要的性能问题集中在是否把这个额外的编译脚本模块 apply 到所有的主代码模块中。</p><p><strong><a href=\"https://t.me/AndroidDevCn/195956\">Q4</a>: 我执行 gradlew bundle 命令的时候，为什么每个 product flavor 里面的配置都会被执行一次？如何给渠道设置版本名称？</strong></p><pre><code class=\"language-Kotlin\">producatFlavors {     india {         setProperty(\"archivesBaseName\", \"urbanic-${versioNameIndia}-${currentVersionCode}\"     }        india {         setProperty(\"archivesBaseName\", \"urbanic-${versioNameOther}-${currentVersionCode}\"     }}</code></pre><p>A4:</p><ul>  <li>Gradle 配置阶段的脚本是全部都会执行的，不然没法得到配置好的 Extension，也没办法得到 Task Graph；</li>  <li>就这段脚本而言它是执行 Flavor 的配置，像 <code class=\"language-plaintext highlighter-rouge\">dimension</code> <code class=\"language-plaintext highlighter-rouge\">applicationIdSuffix</code> <code class=\"language-plaintext highlighter-rouge\">buildConfigField</code> 都是作用于 flavor 的（隐藏的 this 是 ProdcutFlavor)，<code class=\"language-plaintext highlighter-rouge\">setProperty</code> 是作用于 project 的，所以会被覆盖；</li>  <li><code class=\"language-plaintext highlighter-rouge\">archivesBaseName</code> 的配置看了下是从 Gradle API 来的，并不是 AGP 的（AGP 有挺多地方用了不过，但是没法搞 variant aware 的策略），如果你真想 hack 一下，那就根据你输入的命令 hardcode 对应的 property：<code class=\"language-plaintext highlighter-rouge\">if(gradle.startParameter.getTaskNames().get(0).contains(\"India\")) { setProperty(...) }</code></li>  <li>现在应该用这个了 Artifacts API：https://github.com/android/gradle-recipes/blob/agp-4.2/Kotlin/getApksTest/app/build.gradle.kts （可以切分支查看不同版本 AGP 的 API，7.0 后稳定了），添加一个 Task 获取对应渠道 APK 后再修改名称。</li></ul><p><strong>Q5: 对于想在 assembleDebug 后对 APK 执行一些操作的情况，可以用 <code class=\"language-plaintext highlighter-rouge\">finalizeBy()</code>。</strong></p><p>A5:</p><p>我也经常忍不住用😂，但是这个 API 有几个问题：</p><ol>  <li>如果一个 task 有多个 finalizer，它们是按 finalizer 的名字排序（相当于乱序；</li>  <li>Finalizer 可不管前一个任务执行成功没(见附图)，只要前一个任务执行了，它就总是会接着执行；</li></ol><p>上面两点其实是 by design 的，所以官方文档的用例是用来做 task 的资源清理工作。我一直觉得自己有点滥用，不过有需要没办法的时候也只能用。</p><p>就这个 case 可能的几个别的解法是：</p><ol>  <li>用 <code class=\"language-plaintext highlighter-rouge\">doLast()</code>，但是只接受 <code class=\"language-plaintext highlighter-rouge\">Action</code> 而不是 <code class=\"language-plaintext highlighter-rouge\">Task</code>；</li>  <li>反向 <code class=\"language-plaintext highlighter-rouge\">dependsOn()</code>, 让 <code class=\"language-plaintext highlighter-rouge\">apkRenameDebug.dependsOn(resguardDebug)</code>，然后执行终端执行 <code class=\"language-plaintext highlighter-rouge\">apkRenameDebug</code>；</li>  <li>加一个类似 lifecycle task 的锚点 task 作为最后运行的 task，然后把前面那些 task 往他上面 <code class=\"language-plaintext highlighter-rouge\">dependsOn()</code>，算是 2 的优化版（比较好看干净）；</li>  <li>用 <code class=\"language-plaintext highlighter-rouge\">buildFinish()</code> 生命周期监听器，所有任务跑完后取 apk 做处理可以不需要依赖 AGP；</li>  <li>用新的 Artifacts API （见 A4 的链接）。</li></ol><p><img src=\"https://2bab-images.lastmayday.com/blog/lu2nXbi7yEZ1p0eoD3eKMSCjsKYy.jpeg?imageslim\" alt=\"\" /></p><h2 id=\"kotlin-周边koinktorcoil\">Kotlin 周边：Koin/Ktor/Coil/…</h2><p><strong><a href=\"https://kotlinlang.slack.com/archives/C0A974TJ9/p1623070601174400\">Q1</a>: Is it possible a feature/plugin depends on another?I need to transform the type with my feature before JsonFeature get it. The problem is JsonFeature should be able to parse SomeError or User, so I have to unwrap it from my Either before, if not, JsonFeature will try it with the Either class and it will fail.</strong></p><p>A1: For ktor client’s plugin I used/created, I don’t think there’s a direct approach to implement this. But if u look into their implementations, can see the interceptor pipelines - base on the lifecycle of those pipeline, u can define the running sequence and thus make dependent relationship indirectly. In this case, probably u can use HttpResponsePipeline.Receive in your custom plugin to unwrap before JsonFeature works.</p><pre><code class=\"language-Kotlin\">scope.responsePipeline.intercept(HttpResponsePipeline.Receive) { (info, body) -&gt;    if (body !is ByteReadChannel) { return @intercept}    // Do something you want and get the final result in String (others types I did not try)    val result: String = decrypt(body.readRemaining().readText())    proceedWith(HttpResponseContainer(info, ByteReadChannel(result)))}</code></pre><p><strong>Q2: Coil 加载时报错 <code class=\"language-plaintext highlighter-rouge\">Software rendering doesn't support hardware bitmaps</code></strong></p><p>A2：</p><ol>  <li><a href=\"https://coil-kt.github.io/coil/recipes/#shared-element-transitions\">Recipes - Coil</a>，你大概率是碰到了：Shared element transitions are incompatible with hardware bitmaps；</li>  <li>除了上面那个，还有一些机型原生不支持，以及 OS 版本原生不支持的，库本身应该是处理好了：<a href=\"https://github.com/coil-kt/coil/blob/main/coil-base/src/main/java/coil/memory/HardwareBitmapService.kt\">https://github.com/coil-kt/coil/blob/main/coil-base/src/main/java/coil/memory/HardwareBitmapService.kt</a></li>  <li>查看所有相关 issue，比如<a href=\"https://wx.zsxq.com/dweb2/index/group/51285415155554\">这个</a>，没有看到超出上述范围的讨论，所以我觉得应该就是这样啦。</li></ol><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/07/11/dev-exp-monthly-update-01",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建","工程效率小集"],
            
            "date_published": "2021-07-11T00:00:00+00:00",
            "date_modified": "2021-07-11T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/06/17/google-io-21-agp-recap",
            "title": "继往开来：Google I/O 21 Android Gradle Plugin 更新总结",
            "summary": null,
            "content_text": "距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。性能提升Configuration CacheGradle 的生命周期分为大的三个部分：初始化阶段（Initialization Phase)，配置阶段（Configuration Phase），执行阶段（Execution Phase）。其中任务执行的部分只要处理恰当，已经能够很好的进行缓存和重用——重用已有的缓存是加快编译速度十分关键的一环，如果把这个机制运用到其他阶段当然也能带来一些收益。仅次于执行阶段耗时的一般是配置阶段，而今年 AGP 给我们带来的 Gradle Configuration Cache 的支持，一项自 Gradle 6.6 起开始孵化的新功能。它使得配置阶段的主要产出物——Task Graph 可以被重用，在示例的项目中这个优化可以带来 8s 左右的不必要等待（如果 Gradle 脚本配置并没有改变）。想体验这项优化只需要在执行 Gradle 命令时加入 --configuration-cache，例如 ./gradlew --configuration-cache help。由于 Configuration Cache 现在还未完全稳定，如果你想一直开启（包括享受 IDE Sync 时的优化），需要使用如下 properties：org.gradle.unsafe.configuration-cache=true第一次使用时会看到计算 Task Graph 的提示：  Calculating task graph as no configuration cache is available for tasks: :test-app:assembleDebug成功后会在 Build 结束时提示：  Configuration cache entry stored.之后 Cache 就可以被下一次构建复用（如果没有构建脚本修改）：  Reusing configuration cache.  …  51 actionable tasks: 2 executed, 49 up-to-date  Configuration cache entry reused.作为插件使用者，发现常用插件出现不支持的情况，可先搜索是否有相同的问题已经出现，例如下面这个 Kotlin 1.4.32 插件和 Gradle 7.0 配合时出现的问题：在这个 YouTrack issue 下我们可以简单看到通过升级 Kotlin 插件版本至 1.5.0 以上即可解决。事实上 AGP/Kotlin/Gradle 核心的几个插件（主要是背后的 Tasks）在最近的版本都已经支持 Configuration Cache，通过这几篇文档/issue 可以了解大概：  Help community Gradle plugins adopt the configuration cache #13490 - Gradle Github Issues  Gradle Properties Change - Android Gradle Plugin 4.2 Release Note  Gradle Configuration Cache Support - Kotlin Doc而作为插件开发者，则还要关心 Configuration Cache 的适配工作。其重点在于：Task 的参数和内部实现需要避开直接传入/使用 Gradle 的几个 Context 及一些无法序列化的类。以我维护的 Seal 插件为例，它是一个解决 AndroidManifest.xml 冲突的小插件，我们执行 /gradlew --configuration-cache :test-app:assembleDebug 会发现有两个问题待修复：通过构建结束时输出的 Configuration Cache HTML Report 我们可以查看到详细的堆栈：针对这个错误，其实仅仅需要把 project.logger 改成 this.logger 的引用即可：对于更复杂的规则和用例，可以参考 Gradle 的文档以及 AGP 兼容 Configuration Cache 的心路历程（修复了 400 多个 issues）：  Configuration Cache  Configuration caching deep dive - Android Developers最后，有个 Gradle 官方维护的 android-cache-fix-gradle-plugin ，一些 AGP build cache、configuration cache 的特殊问题，可以在此处查阅下，说不定正好是你项目碰到的。Non-transitive R-classes事实上 R 文件的这类特性已经发展了很多年，可以参考这篇按时间顺序整理的文章。但是最新的 nonTransitiveAppRClass 特性需要 AGP 7.0 及以上，目前资料较少，在 Android Studio Arctic Fox 版本发布说明中有部分提及：  非传递性 R 类重构：在 Android Gradle 插件中使用非传递性 (non-transitive) R 类，可以为具有多个模块的应用带来更快的构建速度。它通过确保每个模块只包含对其自身资源的引用，而不从依赖关系中提取引用来防止资源的重复。您可以通过重构 (Refactor) &gt; 迁移到非传递性 R 类 (Migrate to Non-transitive R Classes) 来使用此功能。开启方式如下：这个操作帮助你自动添加两行特性开启的代码到 gradle.properties，并重新 build project：Cacheable Lint TaskLint 的运行一直是耗时大户，在 AGP 7.0 后（最早计划于是 3.5，见这篇文档），终于正式成为可缓存的 Task。其他另外 AS + AGP 自 4.x 以来还有一些提升的点：  Gradle Kotlin DSL 体验和性能提升，可以看到 Google I/O Android App 项目已经全部改成 *.gradle.kts 脚本；  AAPT2 的性能提升；  JDK 11 引入的性能提升；  …可以在 AGP/AS 的 Release Notes 里找到这些信息。新的 DSLDSL Doc 迁移至 android.com旧的 AGP DSL 文档 从 3.4 之后就不再更新了。新的文档迁移至 android.com，更加统一。依旧可按版本查看：  当前版本（Current Release）：即稳定版本 4.2；  预览版本（Preview Releases）：即 beta 7.0 和 alpha 7.1 测试版；  之前的版本（Past Releases）：即之前所有的老版本，但由于中间的更迭/切换，所以其实 3.5 -&gt; 4.0 版本的文档都没有；这个变化也反映在了 google source 的 tag 上，对于 AGP 源码来说 gradle-x.y.z 的 tag 自 3.4.0 之后就没有了，目前你可以使用 studio-x.y.z 例如 studio-4.2.0 来反向定位 AGP 的版本。Android Studio 提供的 AGP 升级助手为了让开发者便捷流畅地升级 AGP，AGP 配合 AS 的推出了升级助手功能。这个新特性已经迭代了几个版本，目前对 Gradle Groovy DSL 脚本的升级十分有用，当你看到升级提示时（一般发生在刚打开一个工程时）：点击 Upgrade 还会有预览功能（截图自 session 的 slide）：不过对于 Gradle Kotlin DSL 的支持还有待补齐，例如基础的 compileSdkVersion 等废弃 DSL 的迁移也未支持：当然，复杂的对象引用也无法帮你直接修改，例如 classpath(Deps.agp)，这已经超过该工具能做的范围。你可以把其当成类似 Java 转 Kotlin 的辅助工具，先用它快速升级和整理基础的 DSL，然后再手动对照 DSL 文档修改出错的小部分。新的 Variant APIVariant API 是这两年 Android 与插件开发相关的最重要更新，如果之前没有针对 AGP 生态开发过协同插件的朋友可以通过下面这张图“了解什么是 Variant”？Variant API 的更新可以概括：为了使协同插件的开发者依赖于更稳定的 API，将原来的 com.android.tools.build:gradle 包拆分成 gradle 和 gradle-api 两个包，做到接口和实现的隔离。实战角度来看我们可以关注两部分：Variant 遍历入口变更和部分自定义 Task 的简化。Variant 遍历入口变更大部分 AGP 生态的协同插件都需要注册 Variant aware 的 Task，即遍历 Variant 注册与其对应的自定义 Task，例如上面提到的 Seal 插件的 postUpdateDebugManifest postUpdateReleaseManifest。你一定看到过这样的代码（Groovy）：def android = project.extensions.androidandroid.applicationVariants.all { variant -&gt;    def variantName = variant.name.capitalize()    createTask(project, variantName)}或者 Kotlin 的版本：val androidExtension = project.extensions.findByType(AppExtension::class.java)!!androidExtension.applicationVariants.all { variant -&gt;    val variantName = variant.name.capitalize()    createTask(project, variantName)}如果是适用于 library 的插件则需要 LibraryExtension 和 libraryVariants。这类 API 现在改成了 gradle-api 内的新 API 调用：val androidExtension = project.extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()androidExtension.onVariants { variant -&gt;    ...}这里获取到的 Variant 是 com.android.build.api.variant.ApplicationVariant，Extension 则来自于 com.android.build.api.extension.ApplicationAndroidComponentsExtension。另外一个可能会用到的接口是 beforeVariants(...)，用来控制 Variant 的构建，例如全局修改一些 Variant 的属性等。从这段 Snippet 我们可能看不出来 Variant 具体的变化，但这变化背后包含了规范的 Variant 状态流转，公开的 API 等。部分自定义 Task 的简化这类简化指 Task 插入点和 Task 参数获取（注入）的简化，提供这类特性的 API 也称之为 Artifact APIs。在比较经典的模式里：对于插入点，一般我们会手动找到 Task 的前后依赖关系，使用 Gradle API 进行依赖关系重新梳理（甚至可能要自定义一些新的生命周期锚点 Task 辅助）；对于 Task 的参数，就使出各种奇技淫巧，从已有 Task 里的参数/中间产物/私有对象等找到我们需要的数据，再注入到自定义的 Task 中。而现在 Artifact APIs 规范了一套标准操作，使得我们可以简易地和已有的数据、中间产物进行交互，实战角度来看我们可以分为两种模式：复杂的 Transform/Append/Create 操作：插入 Task 到特定节点和 Task 参数注入一条龙服务，一般适用于需要定义某个具体的插入点；androidComponents {    val gitVersionProvider = tasks.register&lt;GitVersionTask&gt;(\"gitVersionProvider\") {        gitVersionOutputFile.set(            File(project.buildDir, \"intermediates/gitVersionProvider/output\"))        outputs.upToDateWhen { false }    }    onVariants { variant -&gt;        val manifestProducer = tasks.register&lt;ManifestProducerTask&gt;(\"${variant.name}ManifestProducer\") {            gitInfoFile.set(gitVersionProvider.flatMap(GitVersionTask::gitVersionOutputFile))        }        variant.artifacts.use(manifestProducer)            .wiredWith(ManifestProducerTask::outputManifest)            .toCreate(SingleArtifact.MERGED_MANIFEST)    }}纯粹的 Get：主动获取 intermediates，一般适用于较为独立的 Task，没有严苛的插入位置要求（但是藉由 Provider 的传递会有隐式的 Task 依赖），没有需要替换等操作：androidComponents {    onVariants { variant -&gt;        project.tasks.register&lt;DisplayApksTask&gt;(\"${variant.name}DisplayApks\") {            apkFolder.set(variant.artifacts.get(SingleArtifact.APK))            builtArtifactsLoader.set(variant.artifacts.getBuiltArtifactsLoader())        }    }}更多从实用的角度来说，新的 Variant 接口、Extension 接口公开的 API 比之前少了，但更加规范。Artifacts 作为手动获取 Task input/output 的补充，目前的公开 API 也还比较少，希望插件开发者们在遇到合理的需要公开的 API 但目前还没有时，给 AGP team 多提点 issue :)。另外，限于篇幅我无法在这里介绍全部的 Variant API 更新，包括新的 Provider&lt;T&gt; API 引入（Lazy Configuration），Variant 状态流转，更多种的 Artifacts API 的使用，如何借鉴它的设计来自己动手解决那些还没有被封装、公开的接口等等。你可以从下面几份资料中获得更多的灵感：  From Gradle properties to AGP APIs - Android Dev Summit ‘19：讲解了 Variant API 的基石—— Provider&lt;T&gt; API 及其衍生的多个子类，Variant 状态流转及其 API 的多种使用姿势等；  New APIs in the Android Gradle Plugin - Android Developers Blog：介绍了 Variant API 想法设计的由来，新 API 的使用；  android/gradle-recipes：分别提供了 Groovy/Kotlin DSL 下 Variant API 常用的示例代码；  Android Gradle Plugin DSL/API migration timeline：未来三年 New DSL 和 Variant API 相关的 milestone；  Lazy Configuration：Task 配置延迟获取，Provider&lt;T&gt; 及其各种子类，Task 隐式依赖等。新的 ASM APIASM API 是之前 Transform API 的替代品，旨在更低成本地提供一个 Class -&gt; Dex 之间的插入点用以修改字节码。它没有了之前 Transform API 的灵活性，比如目前看起来它和 ASM 字节码工具是绑定的，不支持 Javassist 或者 Aspect 等。但同时，它拥有更好的性能，更低的使用成本（指实现 transform 本身，因为 ASM 实际上是相对 Javasssist Aspect 更底层的 API，更灵活、学习成本也更高），以及更容易适配 Gradle 的新特性。目前刚刚开始孵化，从 API Doc 来看还不推荐开发者使用它来构建一个生产环境的插件。abstract class ExamplePlugin : Plugin&lt;Project&gt; {    override fun apply(project: Project) {        val androidComponents = project.extensions.getByType(AndroidComponentsExtension::class.java)        androidComponents.onVariants { variant -&gt;            variant.transformClassesWith(ExampleClassVisitorFactory::class.java,                                 InstrumentationScope.ALL) {                it.writeToStdout.set(true)            }            variant.setAsmFramesComputationMode(FramesComputationMode.COPY_FRAMES)        }    }    interface ExampleParams : InstrumentationParameters {        @get:Input        val writeToStdout: Property&lt;Boolean&gt;    }    abstract class ExampleClassVisitorFactory :        AsmClassVisitorFactory&lt;ExampleParams&gt; {        override fun createClassVisitor(            classContext: ClassContext,            nextClassVisitor: ClassVisitor        ): ClassVisitor {            return if (parameters.get().writeToStdout.get()) {                TraceClassVisitor(nextClassVisitor, PrintWriter(System.out))            } else {                TraceClassVisitor(nextClassVisitor, PrintWriter(File(\"trace_out\")))            }        }        override fun isInstrumentable(classData: ClassData): Boolean {            return classData.className.startsWith(\"com.example\")        }    }}上面代码用到的 API 可以参考如下说明：  Component#transformClassesWith(…)  InstrumentationParameters对经典的 Transform 不熟悉的朋友可以看下几个知名的 Transform 库封装（挺巧都是中国公司的开源项目）：  ByteX（活跃）  Booster（活跃，部分功能使用）  Lancet（不活跃）总结从开发者的角度来看，Android 工具团队在 AGP &amp; AS 上更加注重 Engineering Experience 的东西了。在解决了很多历史遗留问题的同时，这次的 Session 还透露出对 AGP 周边生态的建设的长远计划，希望明年可以看到这些东西真的被更多 Android 开发者接受，到时候我也一定再写一篇 22 年版的总结和前瞻。欢迎关注我的 Github / 公众号 / 微博 / Twitter。",
            "content_html": "<p>距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。</p><h2 id=\"性能提升\">性能提升</h2><h3 id=\"configuration-cache\">Configuration Cache</h3><p>Gradle 的生命周期分为大的三个部分：初始化阶段（Initialization Phase)，配置阶段（Configuration Phase），执行阶段（Execution Phase）。其中任务执行的部分只要处理恰当，已经能够很好的进行缓存和重用——重用已有的缓存是加快编译速度十分关键的一环，如果把这个机制运用到其他阶段当然也能带来一些收益。仅次于执行阶段耗时的一般是配置阶段，而今年 AGP 给我们带来的 Gradle <a href=\"https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:requirements\">Configuration Cache</a> 的支持，一项自 <a href=\"https://blog.gradle.org/introducing-configuration-caching\">Gradle 6.6</a> 起开始孵化的新功能。它使得配置阶段的主要产出物——Task Graph 可以被重用，在示例的项目中这个优化可以带来 8s 左右的不必要等待（如果 Gradle 脚本配置并没有改变）。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210617155730.png?imageslim\" alt=\"\" /></p><p>想体验这项优化只需要在执行 Gradle 命令时加入 <code class=\"language-plaintext highlighter-rouge\">--configuration-cache</code>，例如 <code class=\"language-plaintext highlighter-rouge\">./gradlew --configuration-cache help</code>。由于 Configuration Cache 现在还未完全稳定，如果你想一直开启（包括享受 IDE Sync 时的优化），需要使用如下 properties：</p><div class=\"language-properties highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"py\">org.gradle.unsafe.configuration-cache</span><span class=\"p\">=</span><span class=\"s\">true</span></code></pre></div></div><p>第一次使用时会看到计算 Task Graph 的提示：</p><blockquote>  <p>Calculating task graph as no configuration cache is available for tasks: :test-app:assembleDebug</p></blockquote><p>成功后会在 Build 结束时提示：</p><blockquote>  <p>Configuration cache entry stored.</p></blockquote><p>之后 Cache 就可以被下一次构建复用（如果没有构建脚本修改）：</p><blockquote>  <p>Reusing configuration cache.</p>  <p>…</p>  <p>51 actionable tasks: 2 executed, 49 up-to-date</p>  <p>Configuration cache entry reused.</p></blockquote><p>作为插件使用者，发现常用插件出现不支持的情况，可先搜索是否有相同的问题已经出现，例如下面这个 Kotlin 1.4.32 插件和 Gradle 7.0 配合时出现的问题：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-kotlin-plugin.png?imageslim\" alt=\"\" /></p><p>在这个 YouTrack <a href=\"https://youtrack.jetbrains.com/issue/KT-43605\">issue</a> 下我们可以简单看到通过升级 Kotlin 插件版本至 1.5.0 以上即可解决。</p><p>事实上 AGP/Kotlin/Gradle 核心的几个插件（主要是背后的 Tasks）在最近的版本都已经支持 Configuration Cache，通过这几篇文档/issue 可以了解大概：</p><ul>  <li><a href=\"https://github.com/gradle/gradle/issues/13490\">Help community Gradle plugins adopt the configuration cache #13490 - Gradle Github Issues</a></li>  <li><a href=\"https://developer.android.com/studio/releases/gradle-plugin#4.2-gradle-properties\">Gradle Properties Change - Android Gradle Plugin 4.2 Release Note</a></li>  <li><a href=\"https://kotlinlang.org/docs/gradle.html#gradle-configuration-cache-support\">Gradle Configuration Cache Support - Kotlin Doc</a></li></ul><p>而作为插件开发者，则还要关心 Configuration Cache 的适配工作。其重点在于：Task 的参数和内部实现需要避开直接传入/使用 Gradle 的几个 Context 及一些无法序列化的类。以我维护的 <a href=\"https://github.com/2BAB/Seal\">Seal</a> 插件为例，它是一个解决 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 冲突的小插件，我们执行 <code class=\"language-plaintext highlighter-rouge\">/gradlew --configuration-cache :test-app:assembleDebug</code> 会发现有两个问题待修复：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-seal-plugin.png?imageslim\" alt=\"\" /></p><p>通过构建结束时输出的 Configuration Cache HTML Report 我们可以查看到详细的堆栈：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-error-html.png?imageslim\" alt=\"\" /></p><p>针对这个错误，其实仅仅需要把 <code class=\"language-plaintext highlighter-rouge\">project.logger</code> 改成 <code class=\"language-plaintext highlighter-rouge\">this.logger</code> 的引用即可：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-git-change.png?imageslim\" alt=\"\" /></p><p>对于更复杂的规则和用例，可以参考 Gradle 的文档以及 AGP 兼容 Configuration Cache 的心路历程（修复了 400 多个 issues）：</p><ul>  <li><a href=\"https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:requirements\">Configuration Cache</a></li>  <li><a href=\"https://medium.com/androiddevelopers/configuration-caching-deep-dive-bcb304698070\">Configuration caching deep dive - Android Developers</a></li></ul><p>最后，有个 Gradle 官方维护的 <a href=\"https://github.com/gradle/android-cache-fix-gradle-plugin\">android-cache-fix-gradle-plugin</a> ，一些 AGP build cache、configuration cache 的特殊问题，可以在此处查阅下，说不定正好是你项目碰到的。</p><h3 id=\"non-transitive-r-classes\">Non-transitive R-classes</h3><p>事实上 R 文件的这类特性已经发展了很多年，可以参考这篇按时间顺序整理的<a href=\"https://www.mobileit.cz/Blog/Pages/r-class.aspx\">文章</a>。但是最新的 <code class=\"language-plaintext highlighter-rouge\">nonTransitiveAppRClass</code> 特性需要 AGP 7.0 及以上，目前资料较少，在 Android Studio Arctic Fox 版本发布说明中有部分提及：</p><blockquote>  <p>非传递性 R 类重构：在 Android Gradle 插件中使用非传递性 (non-transitive) R 类，可以为具有多个模块的应用带来更快的构建速度。它通过确保每个模块只包含对其自身资源的引用，而不从依赖关系中提取引用来防止资源的重复。您可以通过重构 (Refactor) &gt; 迁移到非传递性 R 类 (Migrate to Non-transitive R Classes) 来使用此功能。</p></blockquote><p>开启方式如下：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-non-transitive-r-as-refactor2.png?imageslim\" alt=\"\" /></p><p>这个操作帮助你自动添加两行特性开启的代码到 <code class=\"language-plaintext highlighter-rouge\">gradle.properties</code>，并重新 build project：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-non-transitive-r-properties.png?imageslim\" alt=\"\" /></p><h3 id=\"cacheable-lint-task\">Cacheable Lint Task</h3><p>Lint 的运行一直是耗时大户，在 AGP 7.0 后（最早计划于是 3.5，见这篇<a href=\"https://docs.gradle.org/current/userguide/caching_android_projects.html#lint\">文档</a>），终于正式成为可缓存的 Task。</p><h3 id=\"其他\">其他</h3><p>另外 AS + AGP 自 4.x 以来还有一些提升的点：</p><ul>  <li>Gradle Kotlin DSL 体验和性能提升，可以看到 <a href=\"https://github.com/google/iosched\">Google I/O Android App</a> 项目已经全部改成 <code class=\"language-plaintext highlighter-rouge\">*.gradle.kts</code> 脚本；</li>  <li>AAPT2 的性能提升；</li>  <li>JDK 11 引入的性能提升；</li>  <li>…</li></ul><p>可以在 AGP/AS 的 Release Notes 里找到这些信息。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-new-as-bumblebee.png?imageslim\" alt=\"\" /></p><h2 id=\"新的-dsl\">新的 DSL</h2><h3 id=\"dsl-doc-迁移至-androidcom\">DSL Doc 迁移至 android.com</h3><p>旧的 AGP DSL <a href=\"https://google.github.io/android-gradle-dsl/\">文档</a> 从 3.4 之后就不再更新了。新的文档迁移至 <a href=\"https://developer.android.com/reference/tools/gradle-api\">android.com</a>，更加统一。依旧可按版本查看：</p><ul>  <li>当前版本（Current Release）：即稳定版本 4.2；</li>  <li>预览版本（Preview Releases）：即 beta 7.0 和 alpha 7.1 测试版；</li>  <li>之前的版本（Past Releases）：即之前所有的老版本，但由于中间的更迭/切换，所以其实 3.5 -&gt; 4.0 版本的文档都没有；</li></ul><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-dsl-doc.png?imageslim\" alt=\"\" /></p><p>这个变化也反映在了 <a href=\"https://android.googlesource.com/platform/manifest/+refs\">google source</a> 的 tag 上，对于 AGP 源码来说 <code class=\"language-plaintext highlighter-rouge\">gradle-x.y.z</code> 的 tag 自 3.4.0 之后就没有了，目前你可以使用 <code class=\"language-plaintext highlighter-rouge\">studio-x.y.z</code> 例如 <code class=\"language-plaintext highlighter-rouge\">studio-4.2.0</code> 来反向定位 AGP 的版本。</p><h3 id=\"android-studio-提供的-agp-升级助手\">Android Studio 提供的 AGP 升级助手</h3><p>为了让开发者便捷流畅地升级 AGP，AGP 配合 AS 的推出了升级助手功能。这个新特性已经迭代了几个版本，目前对 Gradle Groovy DSL 脚本的升级十分有用，当你看到升级提示时（一般发生在刚打开一个工程时）：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant.png?imageslim\" alt=\"\" /></p><p>点击 <code class=\"language-plaintext highlighter-rouge\">Upgrade</code> 还会有预览功能（截图自 session 的 slide）：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant-2.png?imageslim\" alt=\"\" /></p><p>不过对于 Gradle Kotlin DSL 的支持还有待补齐，例如基础的 <code class=\"language-plaintext highlighter-rouge\">compileSdkVersion</code> 等废弃 DSL 的迁移也未支持：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant-3.png?imageslim\" alt=\"\" /></p><p>当然，复杂的对象引用也无法帮你直接修改，例如 <code class=\"language-plaintext highlighter-rouge\">classpath(Deps.agp)</code>，这已经超过该工具能做的范围。你可以把其当成类似 <code class=\"language-plaintext highlighter-rouge\">Java</code> 转 <code class=\"language-plaintext highlighter-rouge\">Kotlin</code> 的辅助工具，先用它快速升级和整理基础的 DSL，然后再手动对照 DSL 文档修改出错的小部分。</p><h2 id=\"新的-variant-api\">新的 Variant API</h2><p>Variant API 是这两年 Android 与插件开发相关的最重要更新，如果之前没有针对 AGP 生态开发过协同插件的朋友可以通过下面这张图“了解什么是 Variant”？</p><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-variant-api-definition-2.png?imageslim\" alt=\"\" /></p><p>Variant API 的更新可以概括：为了使协同插件的开发者依赖于更稳定的 API，将原来的 <code class=\"language-plaintext highlighter-rouge\">com.android.tools.build:gradle</code> 包拆分成 <code class=\"language-plaintext highlighter-rouge\">gradle</code> 和 <code class=\"language-plaintext highlighter-rouge\">gradle-api</code> 两个包，做到接口和实现的隔离。实战角度来看我们可以关注两部分：Variant 遍历入口变更和部分自定义 Task 的简化。</p><h3 id=\"variant-遍历入口变更\">Variant 遍历入口变更</h3><p>大部分 AGP 生态的协同插件都需要注册 Variant aware 的 Task，即遍历 Variant 注册与其对应的自定义 Task，例如上面提到的 Seal 插件的 <code class=\"language-plaintext highlighter-rouge\">postUpdateDebugManifest</code> <code class=\"language-plaintext highlighter-rouge\">postUpdateReleaseManifest</code>。你一定看到过这样的代码（Groovy）：</p><pre><code class=\"language-Groovy\">def android = project.extensions.androidandroid.applicationVariants.all { variant -&gt;    def variantName = variant.name.capitalize()    createTask(project, variantName)}</code></pre><p>或者 Kotlin 的版本：</p><pre><code class=\"language-Kotlin\">val androidExtension = project.extensions.findByType(AppExtension::class.java)!!androidExtension.applicationVariants.all { variant -&gt;    val variantName = variant.name.capitalize()    createTask(project, variantName)}</code></pre><p>如果是适用于 library 的插件则需要 <code class=\"language-plaintext highlighter-rouge\">LibraryExtension</code> 和 <code class=\"language-plaintext highlighter-rouge\">libraryVariants</code>。</p><p>这类 API 现在改成了 <code class=\"language-plaintext highlighter-rouge\">gradle-api</code> 内的新 API 调用：</p><pre><code class=\"language-Kotlin\">val androidExtension = project.extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()androidExtension.onVariants { variant -&gt;    ...}</code></pre><p>这里获取到的 Variant 是 <a href=\"https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/variant/ApplicationVariant\">com.android.build.api.variant.ApplicationVariant</a>，Extension 则来自于 <a href=\"https://developer.android.com/reference/tools/gradle-api/4.2/com/android/build/api/extension/ApplicationAndroidComponentsExtension\">com.android.build.api.extension.ApplicationAndroidComponentsExtension</a>。另外一个可能会用到的接口是 <code class=\"language-plaintext highlighter-rouge\">beforeVariants(...)</code>，用来控制 Variant 的构建，例如全局修改一些 Variant 的属性等。从这段 Snippet 我们可能看不出来 Variant 具体的变化，但这变化背后包含了规范的 Variant 状态流转，公开的 API 等。</p><h3 id=\"部分自定义-task-的简化\">部分自定义 Task 的简化</h3><p>这类简化指 Task 插入点和 Task 参数获取（注入）的简化，提供这类特性的 API 也称之为 Artifact APIs。在比较经典的模式里：对于插入点，一般我们会手动找到 Task 的前后依赖关系，使用 Gradle API 进行依赖关系重新梳理（甚至可能要自定义一些新的生命周期锚点 Task 辅助）；对于 Task 的参数，就使出各种奇技淫巧，从已有 Task 里的参数/中间产物/私有对象等找到我们需要的数据，再注入到自定义的 Task 中。而现在 Artifact APIs 规范了一套标准操作，使得我们可以简易地和已有的数据、中间产物进行交互，实战角度来看我们可以分为两种模式：</p><p>复杂的 Transform/Append/Create 操作：插入 Task 到特定节点和 Task 参数注入一条龙服务，一般适用于需要定义某个具体的插入点；</p><pre><code class=\"language-Kotlin\">androidComponents {    val gitVersionProvider = tasks.register&lt;GitVersionTask&gt;(\"gitVersionProvider\") {        gitVersionOutputFile.set(            File(project.buildDir, \"intermediates/gitVersionProvider/output\"))        outputs.upToDateWhen { false }    }    onVariants { variant -&gt;        val manifestProducer = tasks.register&lt;ManifestProducerTask&gt;(\"${variant.name}ManifestProducer\") {            gitInfoFile.set(gitVersionProvider.flatMap(GitVersionTask::gitVersionOutputFile))        }        variant.artifacts.use(manifestProducer)            .wiredWith(ManifestProducerTask::outputManifest)            .toCreate(SingleArtifact.MERGED_MANIFEST)    }}</code></pre><p>纯粹的 Get：主动获取 intermediates，一般适用于较为独立的 Task，没有严苛的插入位置要求（但是藉由 Provider 的传递会有隐式的 Task 依赖），没有需要替换等操作：</p><pre><code class=\"language-Kotlin\">androidComponents {    onVariants { variant -&gt;        project.tasks.register&lt;DisplayApksTask&gt;(\"${variant.name}DisplayApks\") {            apkFolder.set(variant.artifacts.get(SingleArtifact.APK))            builtArtifactsLoader.set(variant.artifacts.getBuiltArtifactsLoader())        }    }}</code></pre><h3 id=\"更多\">更多</h3><p>从实用的角度来说，新的 Variant 接口、Extension 接口公开的 API 比之前少了，但更加规范。Artifacts 作为手动获取 Task input/output 的补充，目前的公开 API 也还比较少，希望插件开发者们在遇到合理的需要公开的 API 但目前还没有时，给 AGP team 多提点 issue :)。</p><p>另外，限于篇幅我无法在这里介绍全部的 Variant API 更新，包括新的 <code class=\"language-plaintext highlighter-rouge\">Provider&lt;T&gt;</code> API 引入（Lazy Configuration），Variant 状态流转，更多种的 Artifacts API 的使用，如何借鉴它的设计来自己动手解决那些还没有被封装、公开的接口等等。你可以从下面几份资料中获得更多的灵感：</p><ul>  <li><a href=\"https://www.youtube.com/watch?v=OTANozHzgPc\">From Gradle properties to AGP APIs - Android Dev Summit ‘19</a>：讲解了 Variant API 的基石—— <code class=\"language-plaintext highlighter-rouge\">Provider&lt;T&gt;</code> API 及其衍生的多个子类，Variant 状态流转及其 API 的多种使用姿势等；</li>  <li><a href=\"https://medium.com/androiddevelopers/new-apis-in-the-android-gradle-plugin-f5325742e614\">New APIs in the Android Gradle Plugin - Android Developers Blog</a>：介绍了 Variant API 想法设计的由来，新 API 的使用；</li>  <li><a href=\"https://github.com/android/gradle-recipes/tree/agp-7.1\">android/gradle-recipes</a>：分别提供了 Groovy/Kotlin DSL 下 Variant API 常用的示例代码；</li>  <li><a href=\"https://developer.android.com/studio/releases/gradle-plugin-roadmap\">Android Gradle Plugin DSL/API migration timeline</a>：未来三年 New DSL 和 Variant API 相关的 milestone；</li>  <li><a href=\"https://docs.gradle.org/current/userguide/lazy_configuration.html\">Lazy Configuration</a>：Task 配置延迟获取，<code class=\"language-plaintext highlighter-rouge\">Provider&lt;T&gt;</code> 及其各种子类，Task 隐式依赖等。</li></ul><h2 id=\"新的-asm-api\">新的 ASM API</h2><p><img src=\"https://2bab-images.lastmayday.com/blog/io-2021-asm-api.png?imageslim\" alt=\"\" /></p><p>ASM API 是之前 Transform API 的替代品，旨在更低成本地提供一个 Class -&gt; Dex 之间的插入点用以修改字节码。它没有了之前 Transform API 的灵活性，比如目前看起来它和 ASM 字节码工具是绑定的，不支持 Javassist 或者 Aspect 等。但同时，它拥有更好的性能，更低的使用成本（指实现 transform 本身，因为 ASM 实际上是相对 Javasssist Aspect 更底层的 API，更灵活、学习成本也更高），以及更容易适配 Gradle 的新特性。目前刚刚开始孵化，从 API Doc 来看还不推荐开发者使用它来构建一个生产环境的插件。</p><pre><code class=\"language-Kotlin\">abstract class ExamplePlugin : Plugin&lt;Project&gt; {    override fun apply(project: Project) {        val androidComponents = project.extensions.getByType(AndroidComponentsExtension::class.java)        androidComponents.onVariants { variant -&gt;            variant.transformClassesWith(ExampleClassVisitorFactory::class.java,                                 InstrumentationScope.ALL) {                it.writeToStdout.set(true)            }            variant.setAsmFramesComputationMode(FramesComputationMode.COPY_FRAMES)        }    }    interface ExampleParams : InstrumentationParameters {        @get:Input        val writeToStdout: Property&lt;Boolean&gt;    }    abstract class ExampleClassVisitorFactory :        AsmClassVisitorFactory&lt;ExampleParams&gt; {        override fun createClassVisitor(            classContext: ClassContext,            nextClassVisitor: ClassVisitor        ): ClassVisitor {            return if (parameters.get().writeToStdout.get()) {                TraceClassVisitor(nextClassVisitor, PrintWriter(System.out))            } else {                TraceClassVisitor(nextClassVisitor, PrintWriter(File(\"trace_out\")))            }        }        override fun isInstrumentable(classData: ClassData): Boolean {            return classData.className.startsWith(\"com.example\")        }    }}</code></pre><p>上面代码用到的 API 可以参考如下说明：</p><ul>  <li><a href=\"https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/component/Component.html#transformClassesWith(java.lang.Class,%20com.android.build.api.instrumentation.InstrumentationScope,%20kotlin.Function1)\">Component#transformClassesWith(…)</a></li>  <li><a href=\"https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/instrumentation/InstrumentationParameters\">InstrumentationParameters</a></li></ul><p>对经典的 Transform 不熟悉的朋友可以看下几个知名的 Transform 库封装（挺巧都是中国公司的开源项目）：</p><ul>  <li><a href=\"https://github.com/bytedance/ByteX\">ByteX</a>（活跃）</li>  <li><a href=\"https://github.com/didi/booster\">Booster</a>（活跃，部分功能使用）</li>  <li><a href=\"https://github.com/eleme/lancet\">Lancet</a>（不活跃）</li></ul><h2 id=\"总结\">总结</h2><p>从开发者的角度来看，Android 工具团队在 AGP &amp; AS 上更加注重 Engineering Experience 的东西了。在解决了很多历史遗留问题的同时，这次的 Session 还透露出对 AGP 周边生态的建设的长远计划，希望明年可以看到这些东西真的被更多 Android 开发者接受，到时候我也一定再写一篇 22 年版的总结和前瞻。</p><p><em>欢迎关注我的<a href=\"/about\"> Github / 公众号 / 微博 / Twitter</a>。</em></p>",
            "url": "https://2bab.me//2021/06/17/google-io-21-agp-recap",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2021-06-17T00:00:00+00:00",
            "date_modified": "2021-06-17T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/05/09/trap-of-maven-central-publish",
            "title": "MavenCentral 发布集成的几个坑",
            "summary": null,
            "content_text": "由于 JCenter 即将关停，前段时间把几个活跃开源项目的发布流程迁移到了 MavenCentral 上去。参考的两篇文章在各个步骤细节上已经讲解的比较详细了：  Publishing your Kotlin Multiplatform library to Maven Central  Publishing Android libraries to MavenCentral in 2021然而这个过程我还是踩了些坑，以及有一些摸不着头脑的操作，让我决定写篇文章分享下。不要为单一 Artifact 做申请在申请 OSSRH Ticket 时，其实我们在申请的是 Group ID，关键的参数是 Group Id，标题其实都不需要提及具体的 Artifact。一般 Group ID 即域名倒置，会要求验证域名所有权、Github 仓库所有权、JCenter Group 所有权等，根据对应的回复提示操作即可。一次申请，后续所有的新包发布都不需要再申请，例如：我申请了 me.2bab 的 group，那么未来所有 me.2bab.* 的发布都将支持。Signing Plugin 隐式的配置为了校验上传的合法性，我们会对待上传的包做 GPG 签名，用的 Gradle 官方的 The Signing Plugin。刚开始集成时，我按照上述两篇教程的步骤做完，总感觉不对：因为并没有发现我把 signing plugin 所需要的密钥信息传入插件中。// 插件 DSL 配置最基本的情况就只要这一行signing {    sign(publishing.publications)}简单浏览下文档，然后你就会发现他竟然约定了一些 Keys，插件配置时直接从 Project 的 Properties 读取了。// 所以你可以看到参考教程的写法都是如下ext[\"signing.keyId\"] = ...ext[\"signing.password\"] = ...ext[\"signing.secretKeyRingFile\"] = ...以及这个我以前一直不知道能这样干的约定，参考 Build Environment：//. Using the following setup, you can pass the secret key (in ascii-// armored format) and the password using the // ORG_GRADLE_PROJECT_signingKey and ORG_GRADLE_PROJECT_signingPassword // environment variables, respectively:signing {    val signingKey: String? by project    val signingPassword: String? by project    useInMemoryPgpKeys(signingKey, signingPassword)    sign(tasks[\"stuffZip\"])}我挺不喜欢这种过于“隐式”的规定，不仔细看文档根本不能知道我到底写了啥。好在它还有提供显示配置的办法：signing {    val signingKeyId: String? by project // 放在哪里是可选项，不一定要用 Project Properties    val signingKey: String? by project    val signingPassword: String? by project    useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword) // 这行才是关键    sign(tasks[\"stuffZip\"])}类似做法的还有 Android Gradle Plugin 的一些 experimental config，那个由于存在和运用的广泛度太高，可能也懒得吐槽了（不过大部分的开关还是可以从 DSL 里直接配置）。如果你看到这不觉得它有问题，那么可以考虑这样的场景：  显而易见 DSL 可以提供有约束的配置，优秀的 DSL 你可以直接通过 IDE 补全就可以了解自己有哪些 API 可用，怎么交互等；  如果所有的插件都用这样的隐式配置，失去了 DSL 的优势，和直接写个 JSON 配置没啥区别，太松散、易出错、难上手，你可能不知道哪个配置文件对应哪个模块，不知道这个 Key 写对了没有等等；下次更新插件的时候我就打算改成 useInMemoryPgpKeys(...)，不然过一年又不记得这个坑，或者任何接手你项目而不了解 Signing 插件的人都会再迷惑一回。Signing Plugin 的密钥路径指定如果采用了 signing.secretKeyRingFile 配置，那么就得考虑本地和 CI 环境下的不同配置：  本地：../local/secret.gpg，建议放项目根目录或建立一个 local 文件夹并整个文件夹加入 gitignore，原因是一台机器上可能用不止一份的 secret.gpg，密钥随项目走其实比较好找，对其他合作者来说 setup 也方便；  CI：/secret.gpg，直接放虚拟环境根目录，方便配合 RingFile 生成脚本；Batch Upload + 控制面板操作前不久在掘金看到有人写的 MavenCentral 发布教程，提到不要多个包上传后再一起 Close。事实上这是支持并且推荐的，同一 Group ID 的 Package 会放到一个 staging repo，然后就可以一起 close &amp; release。如果引用了自动处理 close &amp; release 流程的插件，聚合上传（batch upload）反倒能提升后续操作的成功率（SonaType 的 API 和网页都不太稳定）。比如我的这个项目有六个模块，其实就使用了 Batch Upload 策略。欢迎关注我的公众号和微博。",
            "content_html": "<p>由于 <a href=\"https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/\">JCenter 即将关停</a>，前段时间把几个活跃开源项目的发布流程迁移到了 <a href=\"https://search.maven.org\">MavenCentral</a> 上去。参考的两篇文章在各个步骤细节上已经讲解的比较详细了：</p><ul>  <li><a href=\"https://dev.to/kotlin/how-to-build-and-publish-a-kotlin-multiplatform-library-going-public-4a8k\">Publishing your Kotlin Multiplatform library to Maven Central</a></li>  <li><a href=\"https://proandroiddev.com/publishing-android-libraries-to-mavencentral-in-2021-8ac9975c3e52\">Publishing Android libraries to MavenCentral in 2021</a></li></ul><p>然而这个过程我还是踩了些坑，以及有一些摸不着头脑的操作，让我决定写篇文章分享下。</p><h2 id=\"不要为单一-artifact-做申请\">不要为单一 Artifact 做申请</h2><p>在申请 OSSRH Ticket 时，其实我们在申请的是 <strong>Group ID</strong>，关键的参数是 Group Id，标题其实都不需要提及具体的 Artifact。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/20210509204352.png?imageslim\" alt=\"group-id\" /></p><p>一般 Group ID 即域名倒置，会要求验证域名所有权、Github 仓库所有权、JCenter Group 所有权等，根据对应的回复提示操作即可。一次申请，后续所有的新包发布都不需要再申请，例如：我申请了 <code class=\"language-plaintext highlighter-rouge\">me.2bab</code> 的 group，那么未来所有 <code class=\"language-plaintext highlighter-rouge\">me.2bab.*</code> 的发布都将支持。</p><h2 id=\"signing-plugin-隐式的配置\">Signing Plugin 隐式的配置</h2><p>为了校验上传的合法性，我们会对待上传的包做 GPG 签名，用的 Gradle 官方的 <a href=\"https://docs.gradle.org/current/userguide/signing_plugin.html\">The Signing Plugin</a>。刚开始集成时，我按照上述两篇教程的步骤做完，总感觉不对：因为并没有发现我把 signing plugin 所需要的密钥信息传入插件中。</p><pre><code class=\"language-Kotlin\">// 插件 DSL 配置最基本的情况就只要这一行signing {    sign(publishing.publications)}</code></pre><p>简单浏览下文档，然后你就会发现他竟然约定了一些 Keys，插件配置时直接从 Project 的 Properties 读取了。</p><pre><code class=\"language-Kotlin\">// 所以你可以看到参考教程的写法都是如下ext[\"signing.keyId\"] = ...ext[\"signing.password\"] = ...ext[\"signing.secretKeyRingFile\"] = ...</code></pre><p>以及这个我以前一直不知道能这样干的约定，参考 <a href=\"https://docs.gradle.org/current/userguide/build_environment.html#sec:project_properties\">Build Environment</a>：</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//. Using the following setup, you can pass the secret key (in ascii-// armored format) and the password using the // ORG_GRADLE_PROJECT_signingKey and ORG_GRADLE_PROJECT_signingPassword // environment variables, respectively:signing {    val signingKey: String? by project    val signingPassword: String? by project    useInMemoryPgpKeys(signingKey, signingPassword)    sign(tasks[\"stuffZip\"])}</code></pre></div></div><p>我挺不喜欢这种过于“隐式”的规定，不仔细看文档根本不能知道我到底写了啥。好在它还有提供显示配置的办法：</p><pre><code class=\"language-Kotlin\">signing {    val signingKeyId: String? by project // 放在哪里是可选项，不一定要用 Project Properties    val signingKey: String? by project    val signingPassword: String? by project    useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword) // 这行才是关键    sign(tasks[\"stuffZip\"])}</code></pre><p>类似做法的还有 Android Gradle Plugin 的一些 experimental config，那个由于存在和运用的广泛度太高，可能也懒得吐槽了（不过大部分的开关还是可以从 DSL 里直接配置）。如果你看到这不觉得它有问题，那么可以考虑这样的场景：</p><ul>  <li>显而易见 DSL 可以提供有<strong>约束的配置</strong>，优秀的 DSL 你可以直接通过 <strong>IDE 补全</strong>就可以了解自己有哪些 API 可用，怎么交互等；</li>  <li>如果所有的插件都用这样的隐式配置，失去了 DSL 的优势，和直接写个 JSON 配置没啥区别，<strong>太松散、易出错、难上手</strong>，你可能不知道哪个配置文件对应哪个模块，不知道这个 Key 写对了没有等等；</li></ul><p>下次更新插件的时候我就打算改成 <code class=\"language-plaintext highlighter-rouge\">useInMemoryPgpKeys(...)</code>，不然过一年又不记得这个坑，或者任何接手你项目而不了解 Signing 插件的人都会再迷惑一回。</p><h2 id=\"signing-plugin-的密钥路径指定\">Signing Plugin 的密钥路径指定</h2><p>如果采用了 <code class=\"language-plaintext highlighter-rouge\">signing.secretKeyRingFile</code> 配置，那么就得考虑本地和 CI 环境下的不同配置：</p><ul>  <li>本地：<code class=\"language-plaintext highlighter-rouge\">../local/secret.gpg</code>，建议放项目根目录或建立一个 <code class=\"language-plaintext highlighter-rouge\">local</code> 文件夹并整个文件夹加入 gitignore，原因是一台机器上可能用不止一份的 secret.gpg，密钥随项目走其实比较好找，对其他合作者来说 setup 也方便；</li>  <li>CI：<code class=\"language-plaintext highlighter-rouge\">/secret.gpg</code>，直接放虚拟环境根目录，方便配合 RingFile 生成脚本；</li></ul><h2 id=\"batch-upload--控制面板操作\">Batch Upload + 控制面板操作</h2><p>前不久在掘金看到有人写的 MavenCentral 发布教程，提到不要多个包上传后再一起 Close。事实上这是支持并且推荐的，同一 Group ID 的 Package 会放到一个 staging repo，然后就可以一起 close &amp; release。如果引用了自动处理 close &amp; release 流程的插件，聚合上传（batch upload）反倒能提升后续操作的成功率（SonaType 的 API 和网页都不太稳定）。比如我的这个<a href=\"https://github.com/2BAB/Polyfill\">项目</a>有六个模块，其实就使用了 Batch Upload 策略。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2021/05/09/trap-of-maven-central-publish",
            
            
            
            "tags": ["Android","Gradle"],
            
            "date_published": "2021-05-09T00:00:00+00:00",
            "date_modified": "2021-05-09T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/05/01/thoughts-on-android-programming-guide",
            "title": "Android 开发初学：多读多看多写",
            "summary": null,
            "content_text": "前段时间收到了明发哥翻译的《Android 编程权威指南》第四版，许久没有打开纸质书，但翻阅时的纸墨味儿依旧，仿佛回到了几年前初学 xml 布局的时候。我从大一暑假开始自学 Java，随后买了本不记得名的 Android 开发入门图书，学习 Android UI、交互、数据 CRUD 等等。2014 年初，正好碰上一位海归的新老师授课 Android 开发，学的 O’Reilly 的动物书《Learning Android》。全英授课，加上教材编排的顺序和我自学一半的内容不太接的上，上课多数是自己坐后排默默敲代码。好在几次实践课和期末大作业我都完成的不错，并且用的 Android Studio beta 版（还没 1.0）给老师留下了一些印象。作为一个新手开发一些自己的作品时，还偶尔会去询问那位老师，她尽管不一定碰过，但也能回一些 StackOverflow 的链接参考给我。那个暑假以及之后的两年，我有幸在一个外校研究生实验室参与项目实战，并在学长们的推荐下加入了一个在校技术团队。大量的实战经历对初学者的进步起到了明显的作用，很快我就从查书变成查 Github、StackOverflow，找一些更新更实用的东西。当时看到《第一行代码》出版，觉得相见恨晚，推荐给了技术团队的成员，当作新人入门的教材。工作多年，也读过几本优秀的进阶书籍，但没想到再一次聊起入门书籍的话题，是发生在出国工作后。Code Coverage 的考量，CI/CD 的实现和扩展，不同维度的测试手段，依赖注入等在工作和面试中碰到的问题，让我又找回当初困惑期的体验。我一边啃着 Google 的优秀项目实践案例，一边回想之前看过的书，发现一是自学的书里面其实没有太多相关的部分，二是有这些内容的书例如《Learning Android》也可能被我跳过，或因为快猛糙的实战中使用较少而遗忘。学习的本质如此：我们既需要快猛糙的“速食”解决眼前问题，也要系统地、长期地查缺补漏，完善对一个领域的理解。如果有机会，最佳的办法当然是在一开始就“愚笨”地完成每一个章节的阅读和练习，而不跳过你觉得“用不到”的基础知识。回头看，我认为没有一本书入门书籍或者在线教程可以完整 Cover 目前复杂的 Android 工程化流程以及常见需求，但是多读多看可以很大程度上解决我们的困惑。举个例子，先看《Android 编程权威指南（第四版）》可以 Cover 大量 Android 开发基础概念和细致的讲解，包含 UI/存储/网络/测试（包括依赖解耦注入）/无障碍/本地化等；再看《第一行代码（第三版）》，有更实用化的角度去增强初学者对常用控件/SDK 的组合，节奏逐步加快；最后可以借助 Android 官方最新的 Demo App 进一步巩固。没有人规定初学者应该只看一本书，也因为不存在完美的“入门图书”，所以结合多本图书、官方 Sample/Tutorial 的系统学习，加上大量的练习我觉得才能真正地完成“入门”。编程和写作有些许相似，阅读和见识是关键的一环。学涵柏老师的写作课时，他总结了几个经验：  区分式阅读：基本原理与通史是为树根；期刊、新闻、报道等是为枝干；日常资讯则为枝叶。  提炼观点，学会联想，多记录多写作。Android 初学者可以活用借鉴：  多读：入门书籍/教程的侧重点各有不同，可结合学习；  多看：经典的官方 Demo App；  多练：大量的 App 开发实战，没有真实项目的同学可找一些仿写的项目，跟着做。回到《Android 编程权威指南（第四版）》，年初时图灵的编辑英子问我有没有兴趣为它写推荐语，第一次听到时确实有点慌。不过在我拿到书稿花了几天阅读后，发现了它的几个重要特点：  基于 Kotlin 和 Jetpack 编写，紧跟开发最新趋势；  测试、无障碍等章节给初学者启蒙了良好代码设计的重要性，也给图书本身增添了温度；  译者明发哥的行文清爽、舒畅。没有告诉明发哥的是，我第一次“认识”他是在 2019 年 8 月，《Kotlin 权威编程指南》首发的时候。当时我刚刚在自己的项目中尝试 Kotlin，马上入职的新工作也都是 Kotlin Base 的项目；而网络上的入门教程有些零散，我看到图灵上线一本新的 Kotlin 图书包含了不少详细的 Sample，立马下了单。是好书，把我们联系在一起。欢迎关注我的公众号和微博。",
            "content_html": "<p>前段时间收到了明发哥翻译的《Android 编程权威指南》第四版，许久没有打开纸质书，但翻阅时的纸墨味儿依旧，仿佛回到了几年前初学 xml 布局的时候。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/android-programming-3.jpg?imageslim\" alt=\"\" /></p><p>我从大一暑假开始自学 Java，随后买了本不记得名的 Android 开发入门图书，学习 Android UI、交互、数据 CRUD 等等。2014 年初，正好碰上一位海归的新老师授课 Android 开发，学的 O’Reilly 的动物书《Learning Android》。全英授课，加上教材编排的顺序和我自学一半的内容不太接的上，上课多数是自己坐后排默默敲代码。好在几次实践课和期末大作业我都完成的不错，并且用的 Android Studio beta 版（还没 1.0）给老师留下了一些印象。作为一个新手开发一些自己的作品时，还偶尔会去询问那位老师，她尽管不一定碰过，但也能回一些 StackOverflow 的链接参考给我。</p><p>那个暑假以及之后的两年，我有幸在一个外校研究生实验室参与项目实战，并在学长们的推荐下加入了一个在校技术团队。大量的实战经历对初学者的进步起到了明显的作用，很快我就从查书变成查 Github、StackOverflow，找一些更新更实用的东西。当时看到《第一行代码》出版，觉得相见恨晚，推荐给了技术团队的成员，当作新人入门的教材。</p><p>工作多年，也读过几本优秀的进阶书籍，但没想到再一次聊起入门书籍的话题，是发生在出国工作后。Code Coverage 的考量，CI/CD 的实现和扩展，不同维度的测试手段，依赖注入等在工作和面试中碰到的问题，让我又找回当初困惑期的体验。我一边啃着 Google 的优秀项目实践案例，一边回想之前看过的书，发现一是自学的书里面其实没有太多相关的部分，二是有这些内容的书例如《Learning Android》也可能被我跳过，或因为快猛糙的实战中使用较少而遗忘。</p><p>学习的本质如此：我们既需要快猛糙的“速食”解决眼前问题，也要系统地、长期地查缺补漏，完善对一个领域的理解。如果有机会，最佳的办法当然是在一开始就“愚笨”地完成每一个章节的阅读和练习，而不跳过你觉得“用不到”的基础知识。回头看，我认为没有一本书入门书籍或者在线教程可以完整 Cover 目前复杂的 Android 工程化流程以及常见需求，但是多读多看可以很大程度上解决我们的困惑。举个例子，先看《Android 编程权威指南（第四版）》可以 Cover 大量 Android 开发基础概念和细致的讲解，包含 UI/存储/网络/测试（包括依赖解耦注入）/无障碍/本地化等；再看《第一行代码（第三版）》，有更实用化的角度去增强初学者对常用控件/SDK 的组合，节奏逐步加快；最后可以借助 Android 官方最新的 Demo App 进一步巩固。没有人规定初学者应该只看一本书，也因为不存在完美的“入门图书”，所以结合多本图书、官方 Sample/Tutorial 的系统学习，加上大量的练习我觉得才能真正地完成“入门”。</p><p>编程和写作有些许相似，阅读和见识是关键的一环。学涵柏老师的写作课时，他总结了几个经验：</p><ul>  <li>区分式阅读：基本原理与通史是为树根；期刊、新闻、报道等是为枝干；日常资讯则为枝叶。</li>  <li>提炼观点，学会联想，多记录多写作。</li></ul><p>Android 初学者可以活用借鉴：</p><ul>  <li>多读：入门书籍/教程的侧重点各有不同，可结合学习；</li>  <li>多看：经典的官方 Demo App；</li>  <li>多练：大量的 App 开发实战，没有真实项目的同学可找一些仿写的项目，跟着做。</li></ul><p>回到《Android 编程权威指南（第四版）》，年初时图灵的编辑英子问我有没有兴趣为它写推荐语，第一次听到时确实有点慌。不过在我拿到书稿花了几天阅读后，发现了它的几个重要特点：</p><ul>  <li>基于 Kotlin 和 Jetpack 编写，紧跟开发最新趋势；</li>  <li>测试、无障碍等章节给初学者启蒙了良好代码设计的重要性，也给图书本身增添了温度；</li>  <li>译者明发哥的行文清爽、舒畅。</li></ul><p><img src=\"https://2bab-images.lastmayday.com/blog/android-programming-4.jpg?imageslim\" alt=\"\" /></p><p>没有告诉明发哥的是，我第一次“认识”他是在 2019 年 8 月，《Kotlin 权威编程指南》首发的时候。当时我刚刚在自己的项目中尝试 Kotlin，马上入职的新工作也都是 Kotlin Base 的项目；而网络上的入门教程有些零散，我看到图灵上线一本新的 Kotlin 图书包含了不少详细的 Sample，立马下了单。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/Screenshot%202021-05-02%20at%204.05.14%20PM.png?imageslim\" alt=\"\" /></p><p>是好书，把我们联系在一起。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2021/05/01/thoughts-on-android-programming-guide",
            
            
            
            "tags": ["Android","阅读分享"],
            
            "date_published": "2021-05-01T00:00:00+00:00",
            "date_modified": "2021-05-01T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2021/02/14/android-build-script-debug-support",
            "title": "构建指北 #9 Gradle 脚本调试",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。本文想讨论下目前 IDEA / Android Studio 对 *.gradle.kts 脚本调试的支持情况。可调试能力关于可调试能力的定义，举个栗子，我们在常见的 build.gradle.kts 添加多种脚本片段，包括但不限于属性声明、文件读取、操作 Gradle 相关 API、操作 AGP 相关 API 等等，然后里打上多个断点，编译时 remote attach 上去，查看能否在正确的地方挂起，能否获取到当前上下文的信息，能否执行 Expression Evaluate 等操作。具体到测试的点：  android { default { ... } } 闭包内的上下文信息；  dependencies { ... } 闭包内的上下文信息；  build.gradle.kts 脚本内的一小段自定义脚本，含属性定义，Gradle API 调用，AGP API 调用，这三个点的上下文信息；  /buildSrc 内的 prebuilt.gradle.kts 脚本内的一小段自定义脚本，同样上包含三个点；  /buildScr 内的一个自定义插件，运行插件 apply 方法时的上下文信息（作为调试能力完备的一个参照物）。我前后做了两次实验，半年前用的 Android Studio 4.0 + IDEA 2020.1，第二次是最近用的 Android Studio 4.2.0-beta04 + IDEA 2021.1.EAP，下方的测试结果均使用第二次的 IDE 版本加上：  Android Gradle Plugin 4.1.1  Kotlin 1.4.30  Gradle 6.8.2这里我们以 Kotlin DSL 为主，Groovy DSL 的情况可参考自行分析。多模块 Android 工程第一个测试我们用的多模块（并且是多 Application）的一个工程，结果如下：            序号      测试项      IDEA &amp; Android Studio                  1      android { default { ... } }      Y              2      dependencies { ... }      Y              3      build.gradle.kts                     3.1             N              3.2             Y              3.3             Y              4      prebuilt.gradle.kts                     4.1             N              4.2             Y              4.3             Y              5      plugin      Y      快速小结：  两个 IDE 的结果完全一致（虽然 AS 是社区版但并不意外）；  3.1 和 4.1 的断点可以被正确识别但无法获取上下文；  在对 build.gradle.kts 进行断点调试时，必须手动指定当前的 source 具体为哪一个脚本，如上图的下拉菜单；判断依据是当前 debug 面板的 Variables 里 this 对象提供的上下文信息，比如这里 this 指向了 DefaultConfig，而我们在多个脚本内只对 app module 的 defaultConfig 进行了断点，故选择 app；  这个测试中 Gradle 脚本的调试支持还是不够完善。单模块 Kotlin 工程接下来我们测试下一个简单的 Kotlin 工程：            序号      测试项      IDEA &amp; Android Studio                  1      java { ... }      Y              2      dependencies { ... }      Y              3      build.gradle.kts                     3.1             N              3.2             Y              3.3             N/A              4      prebuilt.gradle.kts                     4.1             N              4.2             Y              4.3             N/A              5      plugin      Y      结果和前一个多模块的 Android 工程并无差别。常见调试问题再列几个常见的问题供大家参考：断点飞线在遇到的一些简单需求时，例如修改生成的 APK 名称，我们经常直接在 build.gradle.kts 中进行脚本编写和调试。调试过程中虽然你在 AS 或者 IDEA 中看上去断点是打上了，但是执行过程中各种无法匹配源码从而飞线乱跳的情况层出不穷，这时候你需要使用上述小结里的方法手动指定对应的脚本。IDEA 对 Android Plugin 的支持需要注意的是，一般 IDEA 对新功能的支持会更快一些，但是对 Android Gradle Plugin 的支持会比 Android Studio 慢一拍。例如当前 4.1.1 版本的 Android Studio 发布后，IDEA 才宣布我们将在 2020.3.2 支持 4.1 （但实际测试并不支持 4.1.1，issue 里写的 2021.1.EAP 才支持）使用 Plugin 包装早期基于 Groovy DSL + build.gradle 的脚本（大概在 AGP 2.x 时期），调试的支持更差。但有一种曲线救国的方法支持上述第三个测试点：把 build.gradle 内的自定脚本块封装成一个 Plugin。但目前 AS 4.2.0-beta04 或 IDEA 2021.1.EAP 中测试都不可行的。而 Kotlin DSL 这边虽然 API 介绍中看上去支持，但实际上插件无法被创建导致脚本编译不通过，也就无从谈起 Debug 了，这里给出一个 issue 参考链接。build.gradle(.kts) 在 IDE 中显示了 Run 按钮另外，有些同学可能在 build.gradle + IDEA 2020.x 的环境看到过如下的一个『运行按钮』和『菜单』，好像运行一个单元测试或者一个 Java main 方法一样：不过其原理与手动执行 Gradle Sync / Build 的过程应该是一致的，并且没有改变我们的测试结果。总结Gradle 脚本（特指 *.gradle.kts，不过 *.gradle 应该也差不多） 目前调试的支持上比较弱，复杂的逻辑尽量使用 buildSrc 内预编译插件/独立插件，其拥有完整调试的能力。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>本文想讨论下目前 IDEA / Android Studio 对 *.gradle.kts 脚本调试的支持情况。</p><h2 id=\"可调试能力\">可调试能力</h2><p>关于可调试能力的定义，举个栗子，我们在常见的 <code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code> 添加多种脚本片段，包括但不限于属性声明、文件读取、操作 Gradle 相关 API、操作 AGP 相关 API 等等，然后里打上多个断点，编译时 remote attach 上去，查看<strong>能否在正确的地方挂起，能否获取到当前上下文的信息，能否执行 Expression Evaluate 等操作</strong>。</p><p>具体到测试的点：</p><ol>  <li><code class=\"language-plaintext highlighter-rouge\">android { default { ... } }</code> 闭包内的上下文信息；</li>  <li><code class=\"language-plaintext highlighter-rouge\">dependencies { ... }</code> 闭包内的上下文信息；</li>  <li><code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code> 脚本内的一小段自定义脚本，含属性定义，Gradle API 调用，AGP API 调用，这三个点的上下文信息；</li>  <li><code class=\"language-plaintext highlighter-rouge\">/buildSrc</code> 内的 <code class=\"language-plaintext highlighter-rouge\">prebuilt.gradle.kts</code> 脚本内的一小段自定义脚本，同样上包含三个点；</li>  <li><code class=\"language-plaintext highlighter-rouge\">/buildScr</code> 内的一个自定义插件，运行插件 apply 方法时的上下文信息（作为调试能力完备的一个参照物）。</li></ol><p>我前后做了两次实验，半年前用的 Android Studio 4.0 + IDEA 2020.1，第二次是最近用的 Android Studio 4.2.0-beta04 + IDEA 2021.1.EAP，下方的测试结果均使用第二次的 IDE 版本加上：</p><ul>  <li>Android Gradle Plugin 4.1.1</li>  <li>Kotlin 1.4.30</li>  <li>Gradle 6.8.2</li></ul><p>这里我们以 Kotlin DSL 为主，Groovy DSL 的情况可参考自行分析。</p><h2 id=\"多模块-android-工程\">多模块 Android 工程</h2><p>第一个测试我们用的多模块（并且是多 Application）的一个工程，结果如下：</p><table>  <thead>    <tr>      <th style=\"text-align: center\">序号</th>      <th style=\"text-align: center\">测试项</th>      <th style=\"text-align: center\">IDEA &amp; Android Studio</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\">1</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">android { default { ... } }</code></td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">2</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">dependencies { ... }</code></td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">3</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code></td>      <td style=\"text-align: center\"> </td>    </tr>    <tr>      <td style=\"text-align: center\">3.1</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N</td>    </tr>    <tr>      <td style=\"text-align: center\">3.2</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">3.3</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">4</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">prebuilt.gradle.kts</code></td>      <td style=\"text-align: center\"> </td>    </tr>    <tr>      <td style=\"text-align: center\">4.1</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N</td>    </tr>    <tr>      <td style=\"text-align: center\">4.2</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">4.3</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">5</td>      <td style=\"text-align: center\">plugin</td>      <td style=\"text-align: center\">Y</td>    </tr>  </tbody></table><p><img src=\"https://2bab-images.lastmayday.com/blog/Screenshot%202021-02-15%20at%2010.30.01%20AM.png?imageslim\" alt=\"\" /></p><p>快速小结：</p><ul>  <li>两个 IDE 的结果完全一致（虽然 AS 是社区版但并不意外）；</li>  <li>3.1 和 4.1 的断点可以被正确识别但无法获取上下文；</li>  <li><strong>在对 <code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code> 进行断点调试时，必须手动指定当前的 source 具体为哪一个脚本，如上图的下拉菜单；判断依据是当前 debug 面板的 Variables 里 this 对象提供的上下文信息，比如这里 this 指向了 DefaultConfig，而我们在多个脚本内只对 app module 的 defaultConfig 进行了断点，故选择 <code class=\"language-plaintext highlighter-rouge\">app</code></strong>；</li>  <li><strong>这个测试中 Gradle 脚本的调试支持还是不够完善。</strong></li></ul><h2 id=\"单模块-kotlin-工程\">单模块 Kotlin 工程</h2><p>接下来我们测试下一个简单的 Kotlin 工程：</p><table>  <thead>    <tr>      <th style=\"text-align: center\">序号</th>      <th style=\"text-align: center\">测试项</th>      <th style=\"text-align: center\">IDEA &amp; Android Studio</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\">1</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">java { ... }</code></td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">2</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">dependencies { ... }</code></td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">3</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code></td>      <td style=\"text-align: center\"> </td>    </tr>    <tr>      <td style=\"text-align: center\">3.1</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N</td>    </tr>    <tr>      <td style=\"text-align: center\">3.2</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">3.3</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N/A</td>    </tr>    <tr>      <td style=\"text-align: center\">4</td>      <td style=\"text-align: center\"><code class=\"language-plaintext highlighter-rouge\">prebuilt.gradle.kts</code></td>      <td style=\"text-align: center\"> </td>    </tr>    <tr>      <td style=\"text-align: center\">4.1</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N</td>    </tr>    <tr>      <td style=\"text-align: center\">4.2</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">Y</td>    </tr>    <tr>      <td style=\"text-align: center\">4.3</td>      <td style=\"text-align: center\"> </td>      <td style=\"text-align: center\">N/A</td>    </tr>    <tr>      <td style=\"text-align: center\">5</td>      <td style=\"text-align: center\">plugin</td>      <td style=\"text-align: center\">Y</td>    </tr>  </tbody></table><p>结果和前一个多模块的 Android 工程并无差别。</p><h2 id=\"常见调试问题\">常见调试问题</h2><p>再列几个常见的问题供大家参考：</p><h3 id=\"断点飞线\">断点飞线</h3><p>在遇到的一些简单需求时，例如修改生成的 APK 名称，我们经常直接在 <code class=\"language-plaintext highlighter-rouge\">build.gradle.kts</code> 中进行脚本编写和调试。<strong>调试过程中虽然你在 AS 或者 IDEA 中看上去断点是打上了，但是执行过程中各种无法匹配源码从而飞线乱跳的情况层出不穷，这时候你需要使用上述小结里的方法手动指定对应的脚本。</strong></p><h3 id=\"idea-对-android-plugin-的支持\">IDEA 对 Android Plugin 的支持</h3><p>需要注意的是，一般 IDEA 对新功能的支持会更快一些，但是对 Android Gradle Plugin 的支持会比 Android Studio 慢一拍。例如当前 4.1.1 版本的 Android Studio 发布后，IDEA 才宣布我们将在 2020.3.2 支持 4.1 （但实际测试并不支持 4.1.1，<a href=\"https://youtrack.jetbrains.com/issue/IDEA-252775\">issue</a> 里写的 2021.1.EAP 才支持）</p><h3 id=\"使用-plugin-包装\">使用 Plugin 包装</h3><p>早期基于 Groovy DSL + <code class=\"language-plaintext highlighter-rouge\">build.gradle</code> 的脚本（大概在 AGP 2.x 时期），调试的支持更差。但有一种曲线救国的方法支持上述第三个测试点：把 <code class=\"language-plaintext highlighter-rouge\">build.gradle</code> 内的自定脚本块封装成一个 Plugin。但目前 AS 4.2.0-beta04 或 IDEA 2021.1.EAP 中测试都不可行的。而 Kotlin DSL 这边虽然 API 介绍中看上去支持，但实际上插件无法被创建导致脚本编译不通过，也就无从谈起 Debug 了，这里给出一个 <a href=\"https://github.com/gradle/gradle/issues/13667\">issue</a> 参考链接。</p><p><img src=\"https://2bab-images.lastmayday.com/blog/Screenshot%202021-02-15%20at%204.54.37%20PM.png?imageslim\" alt=\"\" /></p><h3 id=\"buildgradlekts-在-ide-中显示了-run-按钮\">build.gradle(.kts) 在 IDE 中显示了 Run 按钮</h3><p>另外，有些同学可能在 <code class=\"language-plaintext highlighter-rouge\">build.gradle</code> + IDEA 2020.x 的环境看到过如下的一个『运行按钮』和『菜单』，好像运行一个单元测试或者一个 Java main 方法一样：</p><p><img src=\"https://2bab-images.lastmayday.com/blog/Screenshot%202020-07-03%20at%203.12.07%20PM.png?imageslim\" alt=\"\" /></p><p>不过其原理与手动执行 Gradle Sync / Build 的过程应该是一致的，并且没有改变我们的测试结果。</p><h2 id=\"总结\">总结</h2><p>Gradle 脚本（特指 <code class=\"language-plaintext highlighter-rouge\">*.gradle.kts</code>，不过 <code class=\"language-plaintext highlighter-rouge\">*.gradle</code> 应该也差不多） 目前调试的支持上比较弱，复杂的逻辑尽量使用 <code class=\"language-plaintext highlighter-rouge\">buildSrc</code> 内预编译插件/独立插件，其拥有完整调试的能力。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2021/02/14/android-build-script-debug-support",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2021-02-14T00:00:00+00:00",
            "date_modified": "2021-02-14T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2020/03/20/daily-of-agp-appplugin-delegate",
            "title": "构建指北 #8 AppPlugin 加了代理？",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。问题回顾这两天在维护 ScratchPaper ，更新依赖的 AGP（Android Gradle Plugin）版本到 3.6.1。升级的过程中发现，原本项目使用到的对 AppPlugin 的 Hook 点失效：  回顾下，大约是在 3.3.x-3.5.x 的版本迭代里，启用了对 BuildToolInfo 类的反射获取，其目的是为了获取到 Aapt2 可执行文件的所在路径，从而支持自定义重新生成 App Icon 对应的二进制文件图标。package me.xx2bab.scratchpaper.utilsimport com.android.build.gradle.AppPluginimport com.android.build.gradle.BasePluginimport com.android.build.gradle.internal.scope.GlobalScopeimport com.android.sdklib.BuildToolInfoimport org.gradle.api.Projectclass AndroidPluginUtils(val project: Project) {    @Throws(Exception::class)    fun buildToolInfo(): BuildToolInfo {        val basePlugin = project.plugins.findPlugin(AppPlugin::class.java) as BasePlugin&lt;*&gt;        val scope = getField(BasePlugin::class.java, basePlugin,                \"globalScope\") as GlobalScope        return scope.sdkComponents.buildToolInfoProvider.get()    }    fun &lt;T&gt; getField(clazz: Class&lt;T&gt;, instance: T, fieldName: String): Any {        val field = clazz.declaredFields.filter { it.name == fieldName }[0]        field.isAccessible = true        return field.get(instance) as Any    }}让我们把项目依赖的 AGP 版本升级到 3.6.1，解决掉升级带来的常见编译错误后，跑个 Demo 试试：  FAILURE: Build failed with an exception.  * What went wrong:  Execution failed for task ‘:app:processDemoDebugResources’.  Index: 0, Size: 0  …  Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0  at me.xx2bab.scratchpaper.utils.AndroidPluginUtils.getField(AndroidPluginUtils.kt:21)  at me.xx2bab.scratchpaper.utils.AndroidPluginUtils.buildToolInfo(AndroidPluginUtils.kt:15)  at me.xx2bab.scratchpaper.utils.Aapt2Utils.compileResDir(Aapt2Utils.kt:13)奇了怪了，为什么 globalScope 字段反射失败了？问题分析 &amp; 源码重现第一时间，当然是查看 AppPlugin 和 BasePlugin 的源码，看看该字段是否已被移除或改名了。然而惊讶的发现，BasePlugin 和 AppPlugin 下竟然空空荡荡：package com.android.build.gradleimport org.gradle.api.Project/** * The plugin applied with `com.android.application' */class AppPlugin: BasePlugin() {    override fun apply(project: Project) {        super.apply(project)        project.apply(INTERNAL_PLUGIN_ID)    }}private val INTERNAL_PLUGIN_ID = mapOf(\"plugin\" to \"com.android.internal.application\")真正有作用的代码只是一行内部插件的引入，插件名是 com.android.internal.application。顺藤摸瓜，去 META-INF 的插件注册目录看看，// com.android.internal.application.propertiesimplementation-class=com.android.build.gradle.internal.plugins.AppPlugin竟然出现了另外一个 AppPlugin，查看对应的源码，发现之前版本的 AppPlugin BasePlugin 等等类多数被移动到 com.android.build.gradle.internal.plugins 包下，而现在 com.android.build.gradle 包下的各类 Plugin 很多只是代理了内部的各类插件。之后，我想去找找有没有对这块改变的说明，毕竟目前的注释过于简单，没有对代理的意义做过多的说明。上 GoogleSource 翻到了这块相关的 commit 信息：  New public plugin and move existing to internal.  All current plugin classes are considered public APIbecause of how Gradle allows finding plugins. Thereforewe need these classes to not change.  However, we also want to have plugin authors target gradle-apiinstead of the ‘gradle’ artifact. This change forks the currentplugin classes into a new set of public class (name unchanged)and the actual implementations as private, internal classes.  The new public plugins delegate to the internal pluginsby applying them as separate “internal” plugins. For nowthe public plugins stay in gradle-core but we’ll move themto gradle-api at some point. This is currently limited bythe presence of getExtension on BasePlugin, both of which arenow deprecated.  Because our classes have no other public API this should notbreak anything.简单来说，他们想把 gradle-core 和 gradle-api 进行区分，并让插件作者们依赖于 com.android.tools.build:gradle-api 而不是 com.android.tools.build:gradle。这个代理目前只是为了维持原有的逻辑不变，同时占个桩表示我们要开始干活了。有趣的是，原本的插件代码多使用 Java 编写，现在的这些代理类均使用 Kotlin，这也同样印证了 AGP 一轮改革的开始。解决方案由于原有的逻辑都还存在于 internal 的 plugin 中，我们只要简单地替换 import 的路径即可：import com.android.build.gradle.internal.plugins.AppPluginimport com.android.build.gradle.internal.plugins.BasePlugin通过 findPlugin 即可找到老版本的 AppPlugin 等插件。具体的修改信息可以参考这次迭代的 commit message。结论不确定之后基于 AGP 的 Hook 是否还像之前一样可操作，目前看来版本迭代的类变化更加的频繁，我自己维护的基于 AGP 的 Plugins 可能也会增加维护成本。之前考虑过的开发一个第三方的 AGP 的 Polyfill 也必须得操作起来了，分离关注点，减少插件开发和维护成本，在插件上集中注意力实现一个点的目标。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><h3 id=\"问题回顾\">问题回顾</h3><p>这两天在维护 <a href=\"https://github.com/2BAB/ScratchPaper\">ScratchPaper</a> ，更新依赖的 AGP（Android Gradle Plugin）版本到 <code class=\"language-plaintext highlighter-rouge\">3.6.1</code>。升级的过程中发现，原本项目使用到的对 <code class=\"language-plaintext highlighter-rouge\">AppPlugin</code> 的 Hook 点失效：</p><blockquote>  <p>回顾下，大约是在 3.3.x-3.5.x 的版本迭代里，启用了对 <code class=\"language-plaintext highlighter-rouge\">BuildToolInfo</code> 类的反射获取，其目的是为了获取到 Aapt2 可执行文件的所在路径，从而支持自定义重新生成 App Icon 对应的二进制文件图标。</p></blockquote><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">package</span> <span class=\"nn\">me.xx2bab.scratchpaper.utils</span><span class=\"k\">import</span> <span class=\"nn\">com.android.build.gradle.AppPlugin</span><span class=\"k\">import</span> <span class=\"nn\">com.android.build.gradle.BasePlugin</span><span class=\"k\">import</span> <span class=\"nn\">com.android.build.gradle.internal.scope.GlobalScope</span><span class=\"k\">import</span> <span class=\"nn\">com.android.sdklib.BuildToolInfo</span><span class=\"k\">import</span> <span class=\"nn\">org.gradle.api.Project</span><span class=\"kd\">class</span> <span class=\"nc\">AndroidPluginUtils</span><span class=\"p\">(</span><span class=\"kd\">val</span> <span class=\"py\">project</span><span class=\"p\">:</span> <span class=\"nc\">Project</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nd\">@Throws</span><span class=\"p\">(</span><span class=\"nc\">Exception</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">)</span>    <span class=\"k\">fun</span> <span class=\"nf\">buildToolInfo</span><span class=\"p\">():</span> <span class=\"nc\">BuildToolInfo</span> <span class=\"p\">{</span>        <span class=\"kd\">val</span> <span class=\"py\">basePlugin</span> <span class=\"p\">=</span> <span class=\"n\">project</span><span class=\"p\">.</span><span class=\"n\">plugins</span><span class=\"p\">.</span><span class=\"nf\">findPlugin</span><span class=\"p\">(</span><span class=\"nc\">AppPlugin</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"nc\">BasePlugin</span><span class=\"p\">&lt;</span><span class=\"err\">*</span><span class=\"p\">&gt;</span>        <span class=\"kd\">val</span> <span class=\"py\">scope</span> <span class=\"p\">=</span> <span class=\"nf\">getField</span><span class=\"p\">(</span><span class=\"nc\">BasePlugin</span><span class=\"o\">::</span><span class=\"k\">class</span><span class=\"p\">.</span><span class=\"n\">java</span><span class=\"p\">,</span> <span class=\"n\">basePlugin</span><span class=\"p\">,</span>                <span class=\"s\">\"globalScope\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"nc\">GlobalScope</span>        <span class=\"k\">return</span> <span class=\"n\">scope</span><span class=\"p\">.</span><span class=\"n\">sdkComponents</span><span class=\"p\">.</span><span class=\"n\">buildToolInfoProvider</span><span class=\"p\">.</span><span class=\"k\">get</span><span class=\"p\">()</span>    <span class=\"p\">}</span>    <span class=\"k\">fun</span> <span class=\"p\">&lt;</span><span class=\"nc\">T</span><span class=\"p\">&gt;</span> <span class=\"nf\">getField</span><span class=\"p\">(</span><span class=\"n\">clazz</span><span class=\"p\">:</span> <span class=\"nc\">Class</span><span class=\"p\">&lt;</span><span class=\"nc\">T</span><span class=\"p\">&gt;,</span> <span class=\"n\">instance</span><span class=\"p\">:</span> <span class=\"nc\">T</span><span class=\"p\">,</span> <span class=\"n\">fieldName</span><span class=\"p\">:</span> <span class=\"nc\">String</span><span class=\"p\">):</span> <span class=\"nc\">Any</span> <span class=\"p\">{</span>        <span class=\"kd\">val</span> <span class=\"py\">field</span> <span class=\"p\">=</span> <span class=\"n\">clazz</span><span class=\"p\">.</span><span class=\"n\">declaredFields</span><span class=\"p\">.</span><span class=\"nf\">filter</span> <span class=\"p\">{</span> <span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"p\">==</span> <span class=\"n\">fieldName</span> <span class=\"p\">}[</span><span class=\"mi\">0</span><span class=\"p\">]</span>        <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">isAccessible</span> <span class=\"p\">=</span> <span class=\"k\">true</span>        <span class=\"k\">return</span> <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"k\">get</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"nc\">Any</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p>让我们把项目依赖的 AGP 版本升级到 <code class=\"language-plaintext highlighter-rouge\">3.6.1</code>，解决掉升级带来的常见编译错误后，跑个 Demo 试试：</p><blockquote>  <p>FAILURE: Build failed with an exception.</p>  <p>* What went wrong:</p>  <p>Execution failed for task ‘:app:processDemoDebugResources’.</p>  <p>Index: 0, Size: 0</p>  <p>…</p>  <p>Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0</p>  <p>at me.xx2bab.scratchpaper.utils.AndroidPluginUtils.getField(AndroidPluginUtils.kt:21)</p>  <p>at me.xx2bab.scratchpaper.utils.AndroidPluginUtils.buildToolInfo(AndroidPluginUtils.kt:15)</p>  <p>at me.xx2bab.scratchpaper.utils.Aapt2Utils.compileResDir(Aapt2Utils.kt:13)</p></blockquote><p><strong>奇了怪了，为什么 <code class=\"language-plaintext highlighter-rouge\">globalScope</code> 字段反射失败了？</strong></p><h3 id=\"问题分析--源码重现\">问题分析 &amp; 源码重现</h3><p>第一时间，当然是查看 <code class=\"language-plaintext highlighter-rouge\">AppPlugin</code> 和 <code class=\"language-plaintext highlighter-rouge\">BasePlugin</code> 的源码，看看该字段是否已被移除或改名了。然而惊讶的发现，<code class=\"language-plaintext highlighter-rouge\">BasePlugin</code> 和 <code class=\"language-plaintext highlighter-rouge\">AppPlugin</code> 下竟然空空荡荡：</p><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">package</span> <span class=\"nn\">com.android.build.gradle</span><span class=\"k\">import</span> <span class=\"nn\">org.gradle.api.Project</span><span class=\"cm\">/** * The plugin applied with `com.android.application' */</span><span class=\"kd\">class</span> <span class=\"nc\">AppPlugin</span><span class=\"p\">:</span> <span class=\"nc\">BasePlugin</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">override</span> <span class=\"k\">fun</span> <span class=\"nf\">apply</span><span class=\"p\">(</span><span class=\"n\">project</span><span class=\"p\">:</span> <span class=\"nc\">Project</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"k\">super</span><span class=\"p\">.</span><span class=\"nf\">apply</span><span class=\"p\">(</span><span class=\"n\">project</span><span class=\"p\">)</span>        <span class=\"n\">project</span><span class=\"p\">.</span><span class=\"nf\">apply</span><span class=\"p\">(</span><span class=\"nc\">INTERNAL_PLUGIN_ID</span><span class=\"p\">)</span>    <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"k\">private</span> <span class=\"kd\">val</span> <span class=\"py\">INTERNAL_PLUGIN_ID</span> <span class=\"p\">=</span> <span class=\"nf\">mapOf</span><span class=\"p\">(</span><span class=\"s\">\"plugin\"</span> <span class=\"n\">to</span> <span class=\"s\">\"com.android.internal.application\"</span><span class=\"p\">)</span></code></pre></div></div><p>真正有作用的代码只是一行内部插件的引入，插件名是 <code class=\"language-plaintext highlighter-rouge\">com.android.internal.application</code>。顺藤摸瓜，去 <code class=\"language-plaintext highlighter-rouge\">META-INF</code> 的插件注册目录看看，</p><div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// com.android.internal.application.propertiesimplementation-class=com.android.build.gradle.internal.plugins.AppPlugin</code></pre></div></div><p>竟然出现了另外一个 <code class=\"language-plaintext highlighter-rouge\">AppPlugin</code>，查看对应的源码，发现之前版本的 <code class=\"language-plaintext highlighter-rouge\">AppPlugin</code> <code class=\"language-plaintext highlighter-rouge\">BasePlugin</code> 等等类多数被移动到 <code class=\"language-plaintext highlighter-rouge\">com.android.build.gradle.internal.plugins</code> 包下，而现在 <code class=\"language-plaintext highlighter-rouge\">com.android.build.gradle</code> 包下的各类 Plugin 很多只是代理了内部的各类插件。</p><p>之后，我想去找找有没有对这块改变的说明，毕竟目前的注释过于简单，没有对代理的意义做过多的说明。上 <a href=\"https://android.googlesource.com/platform/tools/base/+/ecdfaee5fbdfa69e82bb9266b6742d9c3db27880\">GoogleSource</a> 翻到了这块相关的 commit 信息：</p><blockquote>  <p>New public plugin and move existing to internal.</p>  <p>All current plugin classes are considered public APIbecause of how Gradle allows finding plugins. Thereforewe need these classes to not change.</p>  <p>However, we also want to have plugin authors target gradle-apiinstead of the ‘gradle’ artifact. This change forks the currentplugin classes into a new set of public class (name unchanged)and the actual implementations as private, internal classes.</p>  <p>The new public plugins delegate to the internal pluginsby applying them as separate “internal” plugins. For nowthe public plugins stay in gradle-core but we’ll move themto gradle-api at some point. This is currently limited bythe presence of getExtension on BasePlugin, both of which arenow deprecated.</p>  <p>Because our classes have no other public API this should notbreak anything.</p></blockquote><p>简单来说，他们想把 <code class=\"language-plaintext highlighter-rouge\">gradle-core</code> 和 <code class=\"language-plaintext highlighter-rouge\">gradle-api</code> 进行区分，并让插件作者们依赖于 <code class=\"language-plaintext highlighter-rouge\">com.android.tools.build:gradle-api</code> 而不是 <code class=\"language-plaintext highlighter-rouge\">com.android.tools.build:gradle</code>。这个代理目前只是为了维持原有的逻辑不变，同时占个桩表示我们要开始干活了。有趣的是，原本的插件代码多使用 Java 编写，现在的这些代理类均使用 Kotlin，这也同样印证了 AGP 一轮改革的开始。</p><h3 id=\"解决方案\">解决方案</h3><p>由于原有的逻辑都还存在于 internal 的 plugin 中，我们只要简单地替换 import 的路径即可：</p><div class=\"language-kotlin highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"nn\">com.android.build.gradle.internal.plugins.AppPlugin</span><span class=\"k\">import</span> <span class=\"nn\">com.android.build.gradle.internal.plugins.BasePlugin</span></code></pre></div></div><p>通过 <code class=\"language-plaintext highlighter-rouge\">findPlugin</code> 即可找到老版本的 AppPlugin 等插件。具体的修改信息可以参考这次迭代的 <a href=\"https://github.com/2BAB/ScratchPaper/commit/17f3e83615ca95104b735f6c541ac65df8e4962c\">commit message</a>。</p><h3 id=\"结论\">结论</h3><p>不确定之后基于 AGP 的 Hook 是否还像之前一样可操作，目前看来版本迭代的类变化更加的频繁，我自己维护的基于 AGP 的 Plugins 可能也会增加维护成本。之前考虑过的开发一个第三方的 AGP 的 Polyfill 也必须得操作起来了，分离关注点，减少插件开发和维护成本，在插件上集中注意力实现一个点的目标。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2020/03/20/daily-of-agp-appplugin-delegate",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2020-03-20T00:00:00+00:00",
            "date_modified": "2020-03-20T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2019/05/24/diy-4k-24inch-monitor",
            "title": "DIY 24 寸的 4K 显示器",
            "summary": null,
            "content_text": "这两天苹果上架了新款的 23.8 寸 LG UltraFine 4K 显示器，看了下边框还是那么的粗，Hmmm 还是桌上的这台自制 4K 显示器舒服。正好有朋友也想试试，于是想到记录一下折腾的过程，虽然大部分的工作量都是朋友 @Can 帮忙完成的哈哈。先列一下配置单和链接：            部件      型号      链接      参考价格                  面板      LM238WR3-SSB1      http://www.panelook.cn/LM238WR3-SSB1_LG%20Display_23.8_LCM_invitemdetail_cn_167827.html      ￥600-750              驱动板      N/A      https://item.taobao.com/item.htm?id=575821521733      ￥400              驱动板外壳      N/A      https://item.taobao.com/item.htm?id=575219610220      ￥40              背盖      http://2bab-images.lastmayday.com/2019-05-23-diy-4k-monitor-LM238WR3-spec.pdf      http://2bab-images.lastmayday.com/2019-05-23-diy-4k-monitor-backpanel.dwg      ￥60              电源      N/A      https://shop108273173.taobao.com/index.htm      ￥50              总计                    ￥1200 左右      面板一直想买的是 24 寸的 4K 屏幕，奈何市面上多数 4K 的屏幕都是 27 寸。具体来说：  27 寸对我来说太大了，而且家里没那么大，办公桌还得放不止一台显示器，不然其实我会入手 Dell U2718Q 或者 LG 27UL850，各方面都比较符合我的要求；  24 寸的选择里，大牌基本上只有 Dell P2415Q，可以说是市面上第一款消费级的 4K 24寸，奈何 P 系列的跑马灯边框实在是受不了，整体效果（可视角、色彩、白平衡）也和 U 系列有些差距，两千多块都花了，肯定想更一步到位了；  其他的特别选择，包括 LG UltraFine 4K@21”/5K@27”，也主要是尺寸 + 边框问题，价格上 21 寸的那款还算可以接受了；嗯，废话这么多，事实上我最想要的参数是：  4K@24寸  全玻璃覆盖的隐藏式边框（窄边框）  国际大厂的质量保证，比如 LG、Samsung 的屏所以决定 DIY 的时候，面板也就定下 LG LM238WR3-SSB1 了。关于面板的参数查找，可以去各大屏库网站查阅，比如：  http://www.panelook.com/LM238WR3-SSB1_LG%20Display_23.8_LCM_overview_29420.html  https://www.lcds-display.com/products/LM238WR3-SSB1_LG-Display.html这块面板的参数对比 LG UltraFine 5k@27 (LM270QQ2-SPA1) 也丝毫不逊色，有些地方甚至还要好于 UltraFine（比如 10bit 色彩，更高对比度等等）。（PS. 购买链接里请自行 QQ 微信 与供应商联系）调试中的面板...驱动板 &amp; 驱动板外壳（含按键）&amp; 电源驱动板是除面板外的最重要部件之一啦，一般用的都是第三方的自研驱动板。基本上我们也是在网上搜了一圈，看了下大家评价比较好的几款，最后选定的这个参数有：  2K@144Hz  4K@60Hz  DP1.2 * 2 &amp; HDMI2.0 * 2  2K 下的 HDR上述的购买链接大家可以发现其实板子和它的外壳、电源是一家店，买外壳的时候商量下不要背板和遥控器，就可以用便宜的价格拿到所需的部件了。（电源就买的时候找老板要一个对应的即可）事实上这个驱动板和外壳是 LG LM270WR3SSA1 的第三方标准套件，喜欢 27 寸的其实可以搜到很多这个型号的 DIY 教程，这边就直接复用了省的再去瞎折腾，反正是同一个厂商近乎相同型号的面板。显示器背盖为了让显示器能够支撑起来，以及能把驱动板安装在显示器上，我们还需要一个背盖。我在网上找了个这块面板的具体结构图（背盖-型号那栏可以下载 PDF），大佬照着这个直接撸了个 CAD 的工图 Orz，然后随手找了个淘宝店打印了一块亚克力来用。需要说明的是，这个 CAD 的图有个 bug 就是没有考虑好跟驱动板外壳的兼容性，所以最后大佬用 502 帮我把驱动盒子粘上去了哈哈哈哈。有相关专业经验的朋友可以先买了驱动盒子后再研究怎么改进一下背盖的 CAD 图。安装了背壳和驱动盒子成品插两根排线，拧几个螺丝，组装起来（需要具体步骤的话去色魔张大妈看看），最后贴了个丑爆的膜（请勿模仿）。有条件的可以去淘宝租个红蜘蛛较色仪，大概几十块钱就可以使颜色更准确。总结：参数图里都有，4K@60Hz 稳！欢迎关注我的公众号和微博。",
            "content_html": "<p>这两天苹果上架了新款的 23.8 寸 LG UltraFine 4K 显示器，看了下边框还是那么的粗，Hmmm 还是桌上的这台自制 4K 显示器舒服。正好有朋友也想试试，于是想到记录一下折腾的过程，虽然大部分的工作量都是朋友 @Can 帮忙完成的哈哈。</p><!--more--><p>先列一下配置单和链接：</p><table>  <thead>    <tr>      <th>部件</th>      <th>型号</th>      <th>链接</th>      <th>参考价格</th>    </tr>  </thead>  <tbody>    <tr>      <td>面板</td>      <td>LM238WR3-SSB1</td>      <td>http://www.panelook.cn/LM238WR3-SSB1_LG%20Display_23.8_LCM_invitemdetail_cn_167827.html</td>      <td>￥600-750</td>    </tr>    <tr>      <td>驱动板</td>      <td>N/A</td>      <td>https://item.taobao.com/item.htm?id=575821521733</td>      <td>￥400</td>    </tr>    <tr>      <td>驱动板外壳</td>      <td>N/A</td>      <td>https://item.taobao.com/item.htm?id=575219610220</td>      <td>￥40</td>    </tr>    <tr>      <td>背盖</td>      <td>http://2bab-images.lastmayday.com/2019-05-23-diy-4k-monitor-LM238WR3-spec.pdf</td>      <td>http://2bab-images.lastmayday.com/2019-05-23-diy-4k-monitor-backpanel.dwg</td>      <td>￥60</td>    </tr>    <tr>      <td>电源</td>      <td>N/A</td>      <td>https://shop108273173.taobao.com/index.htm</td>      <td>￥50</td>    </tr>    <tr>      <td>总计</td>      <td> </td>      <td> </td>      <td>￥1200 左右</td>    </tr>  </tbody></table><h3 id=\"面板\">面板</h3><p>一直想买的是 24 寸的 4K 屏幕，奈何市面上多数 4K 的屏幕都是 27 寸。具体来说：</p><ul>  <li>27 寸对我来说太大了，而且家里没那么大，办公桌还得放不止一台显示器，不然其实我会入手 <strong>Dell U2718Q</strong> 或者 <strong>LG 27UL850</strong>，各方面都比较符合我的要求；</li>  <li>24 寸的选择里，大牌基本上只有 <strong>Dell P2415Q</strong>，可以说是市面上第一款消费级的 4K 24寸，奈何 P 系列的跑马灯边框实在是受不了，整体效果（可视角、色彩、白平衡）也和 U 系列有些差距，两千多块都花了，肯定想更一步到位了；</li>  <li>其他的特别选择，包括 <strong>LG UltraFine 4K@21”/5K@27”</strong>，也主要是尺寸 + 边框问题，价格上 21 寸的那款还算可以接受了；</li></ul><p>嗯，废话这么多，事实上我最想要的参数是：</p><ul>  <li>4K@24寸</li>  <li>全玻璃覆盖的隐藏式边框（窄边框）</li>  <li>国际大厂的质量保证，比如 LG、Samsung 的屏</li></ul><p>所以决定 DIY 的时候，面板也就定下 <strong>LG LM238WR3-SSB1</strong> 了。关于面板的参数查找，可以去各大屏库网站查阅，比如：</p><ul>  <li>http://www.panelook.com/LM238WR3-SSB1_LG%20Display_23.8_LCM_overview_29420.html</li>  <li>https://www.lcds-display.com/products/LM238WR3-SSB1_LG-Display.html</li></ul><p>这块面板的参数<a href=\"http://www.panelook.com/modelcompare.php?ids=29420,33044\">对比</a> <strong>LG UltraFine 5k@27 (LM270QQ2-SPA1)</strong> 也丝毫不逊色，有些地方甚至还要好于 UltraFine（比如 10bit 色彩，更高对比度等等）。（PS. 购买链接里请自行 QQ 微信 与供应商联系）</p><p><img src=\"http://2bab-images.lastmayday.com/blog/diy-4k-24inch-monitor-1.jpg?imageslim\" alt=\"调试中的面板\" /></p><div style=\"text-align:center;\"><i>调试中的面板...</i></div><h3 id=\"驱动板--驱动板外壳含按键-电源\">驱动板 &amp; 驱动板外壳（含按键）&amp; 电源</h3><p>驱动板是除面板外的最重要部件之一啦，一般用的都是第三方的自研驱动板。基本上我们也是在网上搜了一圈，看了下大家评价比较好的几款，最后选定的这个参数有：</p><ul>  <li>2K@144Hz</li>  <li>4K@60Hz</li>  <li>DP1.2 * 2 &amp; HDMI2.0 * 2</li>  <li>2K 下的 HDR</li></ul><p>上述的购买链接大家可以发现其实板子和它的外壳、电源是一家店，买外壳的时候商量下不要背板和遥控器，就可以用便宜的价格拿到所需的部件了。（电源就买的时候找老板要一个对应的即可）</p><p>事实上这个驱动板和外壳是 <strong>LG LM270WR3SSA1</strong> 的第三方标准套件，喜欢 27 寸的其实可以搜到很多这个型号的 DIY 教程，这边就直接复用了省的再去瞎折腾，反正是同一个厂商近乎相同型号的面板。</p><h3 id=\"显示器背盖\">显示器背盖</h3><p>为了让显示器能够支撑起来，以及能把驱动板安装在显示器上，我们还需要一个背盖。我在网上找了个这块面板的具体结构图（背盖-型号那栏可以下载 PDF），大佬照着这个直接撸了个 CAD 的工图 Orz，然后随手找了个淘宝店打印了一块亚克力来用。</p><p>需要说明的是，这个 CAD 的图有个 bug 就是没有考虑好跟驱动板外壳的兼容性，所以最后大佬用 502 帮我把驱动盒子粘上去了哈哈哈哈。有相关专业经验的朋友可以先买了驱动盒子后再研究怎么改进一下背盖的 CAD 图。</p><p><img src=\"http://2bab-images.lastmayday.com/blog/diy-4k-24inch-monitor-2.jpg?imageslim\" alt=\"安装了背壳和驱动盒子\" /></p><div style=\"text-align:center;\"><i>安装了背壳和驱动盒子</i></div><h3 id=\"成品\">成品</h3><p>插两根排线，拧几个螺丝，组装起来（需要具体步骤的话去色魔张大妈看看），最后贴了个丑爆的膜（请勿模仿）。有条件的可以去淘宝租个红蜘蛛较色仪，大概几十块钱就可以使颜色更准确。</p><p><img src=\"http://2bab-images.lastmayday.com/blog/diy-4k-24inch-monitor-3.jpg?imageslim\" alt=\"\" /></p><p><img src=\"http://2bab-images.lastmayday.com/blog/diy-4k-24inch-monitor-4.JPG?imageslim\" alt=\"\" /></p><p><strong>总结：参数图里都有，4K@60Hz 稳！</strong></p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2019/05/24/diy-4k-24inch-monitor",
            
            
            
            
            
            "date_published": "2019-05-24T00:00:00+00:00",
            "date_modified": "2019-05-24T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2019/05/14/git-repos-merge",
            "title": "合并两个 Git Repo",
            "summary": null,
            "content_text": "手头的项目之前是拆分成两个 repo 进行维护的，这里称之为 A 和 B 好了。B 是一个公共的基础代码库，设计之初被多个项目进行引用。随着几个项目的共同迭代，可共享的代码块越来越少，B 的维护从一个分支变成了每个项目一个分支。接手这个项目后觉得这个维护模式太复杂了，于是连同其他项目把 B 上自己的分支迁移走，彻底废弃 B repo。如果不考虑 commit history，把代码从 B 的项目分支直接拷贝过来 A 即可，这边我们考虑的是迁移带历史记录的整个分支。我尝试了两种办法：  添加新的 remote，拉取对应分支，merge 两个分支  添加新的 remote，拉取对应分支，rebase 两个分支对于 merge，由于两个分支没有任何的 commit tree 关联，会出现 unrelated-histories 的错误，所以一开始放弃了这个办法。对于 rebase，由于记录较多，且两个项目有部分代码分别在两边出现过（包名类名都相同），所以 rebase 的过程中不断有冲突要解决，时间成本巨大，且不知道大量的冲突调整后会不会有问题，所以也只能作罢。最后回头来看 merge 的错误，发现其实有一个 --allow-unrelated-histories 的参数可以绕过检查，然后问题就迎刃而解了。// Add Core repo as a remote source of this repo$ git remote add core YOUR_GIT_REPO// Fetch the branch we need to local: $ git fetch core development-a:a-core// Clean up the folder, only remains Core module that we need // Merge with the flag --allow-unrelated-histories (or it will throw unrelated-histories error)$ git merge a-core --allow-unrelated-histories // Modify build script to match the new structure...事实上，这个问题的根本在我们拥有了一个超级大的 common 模块。这也是很多 App 在迭代发展变大的过程中必经的一个问题，解决的办法也不难，就是在一个公共的功能成熟的时候（比如从 0.1 到 1.0 了）就把它独立出来，其他项目独立引用这个单独的小模块，或者如果在一开始就确定了它可以作为一个独立的模块（比如独立存储），那就不要把代码和其他公共模块混在一起。具体操作上通常有两种：  要么把这个 common repo 变成一个 monorepo 的结构，上层的业务项目虽然需要 pull 这个 repo，但是引用时是完全按照细分的每个模块进行引用  要么把 common repo 完全拆分开成独立模块，独立进行维护，上层不同的业务项目只引用具体需要的二进制版本国内例如淘系的 App 比较倾向于第二种，而国外的公司比如 Google 更多会采用第一种，各有优劣吧。欢迎关注我的公众号和微博。",
            "content_html": "<p>手头的项目之前是拆分成两个 repo 进行维护的，这里称之为 A 和 B 好了。B 是一个公共的基础代码库，设计之初被多个项目进行引用。随着几个项目的共同迭代，可共享的代码块越来越少，B 的维护从一个分支变成了每个项目一个分支。接手这个项目后觉得这个维护模式太复杂了，于是连同其他项目把 B 上自己的分支迁移走，彻底废弃 B repo。</p><!--more--><p>如果不考虑 commit history，把代码从 B 的项目分支直接拷贝过来 A 即可，这边我们考虑的是迁移带历史记录的整个分支。我尝试了两种办法：</p><ul>  <li>添加新的 remote，拉取对应分支，<code class=\"language-plaintext highlighter-rouge\">merge</code> 两个分支</li>  <li>添加新的 remote，拉取对应分支，<code class=\"language-plaintext highlighter-rouge\">rebase</code> 两个分支</li></ul><p>对于 <code class=\"language-plaintext highlighter-rouge\">merge</code>，由于两个分支没有任何的 commit tree 关联，会出现 <code class=\"language-plaintext highlighter-rouge\">unrelated-histories</code> 的错误，所以一开始放弃了这个办法。</p><p>对于 <code class=\"language-plaintext highlighter-rouge\">rebase</code>，由于记录较多，且两个项目有部分代码分别在两边出现过（包名类名都相同），所以 <code class=\"language-plaintext highlighter-rouge\">rebase</code> 的过程中不断有冲突要解决，时间成本巨大，且不知道大量的冲突调整后会不会有问题，所以也只能作罢。</p><p>最后回头来看 <code class=\"language-plaintext highlighter-rouge\">merge</code> 的错误，发现其实有一个 <code class=\"language-plaintext highlighter-rouge\">--allow-unrelated-histories</code> 的参数可以绕过检查，然后问题就迎刃而解了。</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// Add Core repo as a remote <span class=\"nb\">source </span>of this repo<span class=\"nv\">$ </span>git remote add core YOUR_GIT_REPO// Fetch the branch we need to <span class=\"nb\">local</span>: <span class=\"nv\">$ </span>git fetch core development-a:a-core// Clean up the folder, only remains Core module that we need // Merge with the flag <span class=\"nt\">--allow-unrelated-histories</span> <span class=\"o\">(</span>or it will throw unrelated-histories error<span class=\"o\">)</span><span class=\"nv\">$ </span>git merge a-core <span class=\"nt\">--allow-unrelated-histories</span> // Modify build script to match the new structure...</code></pre></div></div><p>事实上，这个问题的根本在我们拥有了一个超级大的 <code class=\"language-plaintext highlighter-rouge\">common</code> 模块。这也是很多 App 在迭代发展变大的过程中必经的一个问题，解决的办法也不难，就是在一个公共的功能成熟的时候（比如从 0.1 到 1.0 了）就把它独立出来，其他项目独立引用这个单独的小模块，或者如果在一开始就确定了它可以作为一个独立的模块（比如独立存储），那就不要把代码和其他公共模块混在一起。具体操作上通常有两种：</p><ul>  <li>要么把这个 <code class=\"language-plaintext highlighter-rouge\">common</code> repo 变成一个 <code class=\"language-plaintext highlighter-rouge\">monorepo</code> 的结构，上层的业务项目虽然需要 pull 这个 repo，但是引用时是完全按照细分的每个模块进行引用</li>  <li>要么把 <code class=\"language-plaintext highlighter-rouge\">common</code> repo 完全拆分开成独立模块，独立进行维护，上层不同的业务项目只引用具体需要的二进制版本</li></ul><p>国内例如淘系的 App 比较倾向于第二种，而国外的公司比如 Google 更多会采用第一种，各有优劣吧。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2019/05/14/git-repos-merge",
            
            
            
            
            
            "date_published": "2019-05-14T00:00:00+00:00",
            "date_modified": "2019-05-14T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2019/05/14/blog-migration-2019",
            "title": "博客迁移 #2019",
            "summary": null,
            "content_text": "Hmmm 有很长一段时间没有更新博客了，一方面是确实懒，只有私底下还持续在写的一些 Gradle 的文章，但打算做成一个完整的知识图谱所以还没发出来；另一方面老的博客系统确实有点麻烦，有时候不在自己的电脑上就没办法写东西了。所以能不能我用个浏览器就能写文章，就成为了此次的目标啦。列一下新的博客系统在用的一些服务和组件，以及选择的原因：  Hugo，从 Hexo 迁移过来的          Hexo 的版本改动兼容性比较垃圾 =。=      Hexo 打包要超久        CloudFlare，从 DNSPod 迁移过来的          不想使用国内的服务，比如新的控制台需要注册腾讯云绑定微信      DNSPod 在新加坡打不开，用阿里云跳板机翻回去也几乎不可用，可能是因为被腾讯收购了所以只去维护新的控制台了吧        Github，从 Coding 迁移过来的          不想使用国内的服务，比如 Coding 并没有 Travis 这种免费的 CI，而新系统使用 Travis 自动 Generate 静态站点      Github Pages 会成为我的备选博客托管服务器        CodingPages，维持不变          虽然是一个国内的服务，但是 Coding Pages 的服务器多半是香港新加坡美国的机器，也不需要备案，基于维持国内外访问的速度考虑目前还在使用        Qiniu，维持不变          其实 18 年的时候由于七牛测试域名回收的原因，我把图床改成过 Sina，但是鉴于 Sina 从 19 年  4 月起禁用外链了，所以又迁移回 lastmayday 的免费域名仓库下      不过出于上述相同的原因，其实我本来是打算购入 AWS 香港新节点的 S3，但是需要手写一个 PicGo 插件以及没有好用的 Web 控制台的原因，所以暂时搁浅了…      So，目前写文章的新流程是：  本地操作，Clone Github 仓库的 source 分支，写文章 + PicGo 传图，commit &amp; push，Travis CI 自动部署到 Github Pages 和 CodingPages  在线操作，直接上 Github 新建个文件就可以写了，用七牛的 Web 控制台传图，Travis CI 自动部署到 Github Pages 和 CodingPages嗯，舒服！后续还缺的操作嘛：  看需不需要 edns-client-subnet 分流国内外访问的服务器  如果 Coding Pages 速度不再有优势，那就切到 Github Pages 上  如果七牛不再有免费流量或者对域名和区域有限制，就切到 AWS-S3 的香港服务欢迎关注我的公众号和微博。",
            "content_html": "<p>Hmmm 有很长一段时间没有更新博客了，一方面是确实懒，只有私底下还持续在写的一些 Gradle 的文章，但打算做成一个完整的知识图谱所以还没发出来；另一方面老的博客系统确实有点麻烦，有时候不在自己的电脑上就没办法写东西了。所以能不能我用个浏览器就能写文章，就成为了此次的目标啦。</p><!--more--><p>列一下新的博客系统在用的一些服务和组件，以及选择的原因：</p><ul>  <li><strong>Hugo</strong>，从 Hexo 迁移过来的    <ul>      <li>Hexo 的版本改动兼容性比较垃圾 =。=</li>      <li>Hexo 打包要超久</li>    </ul>  </li>  <li><strong>CloudFlare</strong>，从 DNSPod 迁移过来的    <ul>      <li>不想使用国内的服务，比如新的控制台需要注册腾讯云绑定微信</li>      <li>DNSPod 在新加坡打不开，用阿里云跳板机翻回去也几乎不可用，可能是因为被腾讯收购了所以只去维护新的控制台了吧</li>    </ul>  </li>  <li><strong>Github</strong>，从 Coding 迁移过来的    <ul>      <li>不想使用国内的服务，比如 Coding 并没有 Travis 这种免费的 CI，而新系统使用 Travis 自动 Generate 静态站点</li>      <li>Github Pages 会成为我的备选博客托管服务器</li>    </ul>  </li>  <li><strong>CodingPages</strong>，维持不变    <ul>      <li>虽然是一个国内的服务，但是 Coding Pages 的服务器多半是香港新加坡美国的机器，也不需要备案，基于维持国内外访问的速度考虑目前还在使用</li>    </ul>  </li>  <li><strong>Qiniu</strong>，维持不变    <ul>      <li>其实 18 年的时候由于七牛测试域名回收的原因，我把图床改成过 Sina，但是鉴于 Sina 从 19 年  4 月起禁用外链了，所以又迁移回 lastmayday 的免费域名仓库下</li>      <li>不过出于上述相同的原因，其实我本来是打算购入 AWS 香港新节点的 S3，但是需要手写一个 PicGo 插件以及没有好用的 Web 控制台的原因，所以暂时搁浅了…</li>    </ul>  </li></ul><p>So，目前写文章的新流程是：</p><ul>  <li>本地操作，Clone Github 仓库的 source 分支，写文章 + PicGo 传图，commit &amp; push，Travis CI 自动部署到 Github Pages 和 CodingPages</li>  <li>在线操作，直接上 Github 新建个文件就可以写了，用七牛的 Web 控制台传图，Travis CI 自动部署到 Github Pages 和 CodingPages</li></ul><p>嗯，舒服！后续还缺的操作嘛：</p><ul>  <li>看需不需要 edns-client-subnet 分流国内外访问的服务器</li>  <li>如果 Coding Pages 速度不再有优势，那就切到 Github Pages 上</li>  <li>如果七牛不再有免费流量或者对域名和区域有限制，就切到 AWS-S3 的香港服务</li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2019/05/14/blog-migration-2019",
            
            
            
            
            
            "date_published": "2019-05-14T00:00:00+00:00",
            "date_modified": "2019-05-14T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/10/16/plugadget-note-8-package-plugin-java-code",
            "title": "插件化笔记 #8 - 插件的代码编译",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes背景为什么打包还要讲？因为我发现大家都没说过这回事啊…而且有些开源的插件化框架并没有看到有仔细处理这块，导致自己研究的时候很困惑。具体来说，打包这块也是分两块，插件代码和插件资源的打包，这节先看插件代码的打包。一般地，我们的插件，和普通的 Android Library 不同，是直接声明成 Application。因为只有这样，才能简单地借助原有的（Application）打包插件来打出 Dex 和资源编译。而打包 Application，对于插件而言，会打入很多不必要的二方、三方依赖。有人会说，用 provided 声明插件模块的依赖不就好了，但这仅仅只能是解决 .jar 的模块，.aar 的依赖是不支持 provided 的。所以我们要解决的问题，也就很明显了，实现一个通用的打包仲裁：  Atlas、VirtualApk 等方案，都是把大部分的依赖打到主工程，插件本身只打入一些只有本插件才会用到的依赖；但他们的实现有所不同：          Atlas 添加了 bundleCompile、providedCompile 的 scope，插件方可以更友好地去声明依赖的形式；      VirtualApk 只是对主工程的依赖作分析，主工程有的就不打进去，主工程没有的就打进去，相对来讲比较粗暴；        不同的方案其实主要是自由度的选择不同，没有说好坏之分；  实现原理上，这里以 VirtualApk 为例，基于 Transform 来做，下面就看一下最基本的实现。Transform API  To insert a transform into a build, you simply create a new class implementing one of the Transform interfaces, and register it with android.registerTransform(theTransform) or android.registerTransform(theTransform, dependencies).  A Transform that processes intermediary build artifacts.For each added transform, a new task is created. The action of adding a transform takes care of handling dependencies between the tasks. This is done based on what the transform processes. The output of the transform becomes consumable by other transforms and these tasks get automatically linked together.  The Transform indicates what it applies to (content, scope) and what it generates (content).  A transform receives input as a collection TransformInput, which is composed of JarInputs and DirectoryInputs. Both provide information about the QualifiedContent.Scopes and QualifiedContent.ContentTypes associated with their particular content.  The output is handled by TransformOutputProvider which allows creating new self-contained content, each associated with their own Scopes and Content Types. The content handled by TransformInput/Output is managed by the transform system, and their location is not configurable.  It is best practice to write into as many outputs as Jar/Folder Inputs have been received by the transform. Combining all the inputs into a single output prevents downstream transform from processing limited scopes.  While it’s possible to differentiate different Content Types by file extension, it’s not possible to do so for Scopes. Therefore if a transform request a Scope but the only available Output contains more than the requested Scope, the build will fail.If a transform request a single content type but the only available content includes more than the requested type, the input file/folder will contain all the files of all the types, but the transform should only read, process and output the type(s) it requested.  Additionally, a transform can indicate secondary inputs/outputs. These are not handled by upstream or downstream transforms, and are not restricted by type handled by transform. They can be anything.  It’s up to each transform to manage where these files are, and to make sure that these files are generated before the transform is called. This is done through additional parameters when register the transform.  These secondary inputs/outputs allow a transform to read but not process any content. This can be achieved by having getScopes() return an empty list and use getReferencedScopes() to indicate what to read instead.根据插件包名的打包过滤器在插件打包时，引入下面这段脚本 (app/build.gradle)，用来过滤掉除了插件包名以外的其他类库和文件。////////////////////////////////// Class Filter ///////////////////////////////////////import com.android.build.api.transform.*import com.android.build.gradle.internal.pipeline.TransformManagerimport groovy.io.FileTypeimport org.apache.commons.io.FileUtilsclass StripClassAndResTransform extends Transform {    private Project project    StripClassAndResTransform(Project project) {        this.project = project    }    @Override    String getName() {        return 'stripClassAndRes'    }    @Override    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {        return TransformManager.CONTENT_JARS    }    @Override    Set&lt;QualifiedContent.Scope&gt; getScopes() {        return TransformManager.SCOPE_FULL_PROJECT    }    @Override    boolean isIncremental() {        return false    }    @Override    void transform(final TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {        def applicationId = 'com/example/multiclassloader'        if (!isIncremental()) {            transformInvocation.outputProvider.deleteAll()        }        transformInvocation.inputs.each {            it.directoryInputs.each { directoryInput -&gt;                directoryInput.file.traverse (type: FileType.FILES){                    def entryName = it.path.substring(directoryInput.file.path.length() + 1)                    def destName = directoryInput.name + '/' + entryName                    def dest = transformInvocation.outputProvider.getContentLocation(                            destName, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)                    // check whether it is a bundle-file                    if (entryName.contains(applicationId)) {                        FileUtils.copyFile(it, dest)                    }                }            }            it.jarInputs.each { jarInput -&gt;                // we don't need libs currently            }        }    }}project.android.registerTransform(new StripClassAndResTransform(project))最后要做的就是，正常地打包 ./gradlew assembleDebug （工程名是 pluginByApk），然后看看打出来的 Apk 中的 Dex 文件是否包含了其他的依赖（例如 Support 包的文件），再用上一节的 Demo 测试一下即可（即 push 这个插件 apk 到 Downloads 文件夹，修改 bundleClassloader 加载的 apk 文件）。参考资料  https://afterecho.uk/blog/create-a-standalone-gradle-plugin-for-android-part-4-the-transform-api.html  https://github.com/didi/VirtualAPK/blob/HEAD/virtualapk-gradle-plugin/src/main/groovy/com.didi.virtualapk/transform/StripClassAndResTransform.groovy  http://google.github.io/android-gradle-dsl/javadoc/current/欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><h2 id=\"背景\">背景</h2><p>为什么打包还要讲？因为我发现大家都没说过这回事啊…而且有些开源的插件化框架并没有看到有仔细处理这块，导致自己研究的时候很困惑。具体来说，打包这块也是分两块，插件代码和插件资源的打包，这节先看插件代码的打包。</p><p>一般地，我们的插件，和普通的 Android Library 不同，是直接声明成 Application。因为只有这样，才能简单地借助原有的（Application）打包插件来打出 Dex 和资源编译。而打包 Application，对于插件而言，会打入很多不必要的二方、三方依赖。有人会说，用 provided 声明插件模块的依赖不就好了，但这仅仅只能是解决 .jar 的模块，.aar 的依赖是不支持 provided 的。所以我们要解决的问题，也就很明显了，实现一个通用的打包仲裁：</p><!--more--><ul>  <li>Atlas、VirtualApk 等方案，都是把大部分的依赖打到主工程，插件本身只打入一些只有本插件才会用到的依赖；但他们的实现有所不同：    <ul>      <li>Atlas 添加了 bundleCompile、providedCompile 的 scope，插件方可以更友好地去声明依赖的形式；</li>      <li>VirtualApk 只是对主工程的依赖作分析，主工程有的就不打进去，主工程没有的就打进去，相对来讲比较粗暴；</li>    </ul>  </li>  <li>不同的方案其实主要是自由度的选择不同，没有说好坏之分；</li>  <li>实现原理上，这里以 VirtualApk 为例，基于 Transform 来做，下面就看一下最基本的实现。</li></ul><h2 id=\"transform-api\">Transform API</h2><blockquote>  <p>To insert a transform into a build, you simply create a new class implementing one of the Transform interfaces, and register it with android.registerTransform(theTransform) or android.registerTransform(theTransform, dependencies).</p>  <p>A Transform that processes intermediary build artifacts.For each added transform, a new task is created. The action of adding a transform takes care of handling dependencies between the tasks. This is done based on what the transform processes. The output of the transform becomes consumable by other transforms and these tasks get automatically linked together.</p>  <p>The Transform indicates what it applies to (content, scope) and what it generates (content).</p>  <p>A transform receives input as a collection TransformInput, which is composed of JarInputs and DirectoryInputs. Both provide information about the QualifiedContent.Scopes and QualifiedContent.ContentTypes associated with their particular content.</p>  <p>The output is handled by TransformOutputProvider which allows creating new self-contained content, each associated with their own Scopes and Content Types. The content handled by TransformInput/Output is managed by the transform system, and their location is not configurable.</p>  <p>It is best practice to write into as many outputs as Jar/Folder Inputs have been received by the transform. Combining all the inputs into a single output prevents downstream transform from processing limited scopes.</p>  <p>While it’s possible to differentiate different Content Types by file extension, it’s not possible to do so for Scopes. Therefore if a transform request a Scope but the only available Output contains more than the requested Scope, the build will fail.If a transform request a single content type but the only available content includes more than the requested type, the input file/folder will contain all the files of all the types, but the transform should only read, process and output the type(s) it requested.</p>  <p>Additionally, a transform can indicate secondary inputs/outputs. These are not handled by upstream or downstream transforms, and are not restricted by type handled by transform. They can be anything.</p>  <p>It’s up to each transform to manage where these files are, and to make sure that these files are generated before the transform is called. This is done through additional parameters when register the transform.</p>  <p>These secondary inputs/outputs allow a transform to read but not process any content. This can be achieved by having getScopes() return an empty list and use getReferencedScopes() to indicate what to read instead.</p></blockquote><h2 id=\"根据插件包名的打包过滤器\">根据插件包名的打包过滤器</h2><p>在插件打包时，引入下面这段脚本 (app/build.gradle)，用来过滤掉除了插件包名以外的其他类库和文件。</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">////////////////////////////////// Class Filter ///////////////////////////////////////</span><span class=\"kn\">import</span> <span class=\"nn\">com.android.build.api.transform.*</span><span class=\"kn\">import</span> <span class=\"nn\">com.android.build.gradle.internal.pipeline.TransformManager</span><span class=\"kn\">import</span> <span class=\"nn\">groovy.io.FileType</span><span class=\"kn\">import</span> <span class=\"nn\">org.apache.commons.io.FileUtils</span><span class=\"kd\">class</span> <span class=\"nc\">StripClassAndResTransform</span> <span class=\"kd\">extends</span> <span class=\"nc\">Transform</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"nc\">Project</span> <span class=\"n\">project</span>    <span class=\"nf\">StripClassAndResTransform</span><span class=\"o\">(</span><span class=\"nc\">Project</span> <span class=\"n\">project</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">project</span> <span class=\"o\">=</span> <span class=\"n\">project</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"nc\">String</span> <span class=\"nf\">getName</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"err\">'</span><span class=\"n\">stripClassAndRes</span><span class=\"err\">'</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"nc\">Set</span><span class=\"o\">&lt;</span><span class=\"nc\">QualifiedContent</span><span class=\"o\">.</span><span class=\"na\">ContentType</span><span class=\"o\">&gt;</span> <span class=\"nf\">getInputTypes</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"nc\">TransformManager</span><span class=\"o\">.</span><span class=\"na\">CONTENT_JARS</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"nc\">Set</span><span class=\"o\">&lt;</span><span class=\"nc\">QualifiedContent</span><span class=\"o\">.</span><span class=\"na\">Scope</span><span class=\"o\">&gt;</span> <span class=\"nf\">getScopes</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"nc\">TransformManager</span><span class=\"o\">.</span><span class=\"na\">SCOPE_FULL_PROJECT</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kt\">boolean</span> <span class=\"nf\">isIncremental</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"kc\">false</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kt\">void</span> <span class=\"nf\">transform</span><span class=\"o\">(</span><span class=\"kd\">final</span> <span class=\"nc\">TransformInvocation</span> <span class=\"n\">transformInvocation</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">TransformException</span><span class=\"o\">,</span> <span class=\"nc\">InterruptedException</span><span class=\"o\">,</span> <span class=\"nc\">IOException</span> <span class=\"o\">{</span>        <span class=\"n\">def</span> <span class=\"n\">applicationId</span> <span class=\"o\">=</span> <span class=\"err\">'</span><span class=\"n\">com</span><span class=\"o\">/</span><span class=\"n\">example</span><span class=\"o\">/</span><span class=\"n\">multiclassloader</span><span class=\"err\">'</span>        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">isIncremental</span><span class=\"o\">())</span> <span class=\"o\">{</span>            <span class=\"n\">transformInvocation</span><span class=\"o\">.</span><span class=\"na\">outputProvider</span><span class=\"o\">.</span><span class=\"na\">deleteAll</span><span class=\"o\">()</span>        <span class=\"o\">}</span>        <span class=\"n\">transformInvocation</span><span class=\"o\">.</span><span class=\"na\">inputs</span><span class=\"o\">.</span><span class=\"na\">each</span> <span class=\"o\">{</span>            <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"na\">directoryInputs</span><span class=\"o\">.</span><span class=\"na\">each</span> <span class=\"o\">{</span> <span class=\"n\">directoryInput</span> <span class=\"o\">-&gt;</span>                <span class=\"n\">directoryInput</span><span class=\"o\">.</span><span class=\"na\">file</span><span class=\"o\">.</span><span class=\"na\">traverse</span> <span class=\"o\">(</span><span class=\"nl\">type:</span> <span class=\"nc\">FileType</span><span class=\"o\">.</span><span class=\"na\">FILES</span><span class=\"o\">){</span>                    <span class=\"n\">def</span> <span class=\"n\">entryName</span> <span class=\"o\">=</span> <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"na\">path</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">directoryInput</span><span class=\"o\">.</span><span class=\"na\">file</span><span class=\"o\">.</span><span class=\"na\">path</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>                    <span class=\"n\">def</span> <span class=\"n\">destName</span> <span class=\"o\">=</span> <span class=\"n\">directoryInput</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">+</span> <span class=\"sc\">'/'</span> <span class=\"o\">+</span> <span class=\"n\">entryName</span>                    <span class=\"n\">def</span> <span class=\"n\">dest</span> <span class=\"o\">=</span> <span class=\"n\">transformInvocation</span><span class=\"o\">.</span><span class=\"na\">outputProvider</span><span class=\"o\">.</span><span class=\"na\">getContentLocation</span><span class=\"o\">(</span>                            <span class=\"n\">destName</span><span class=\"o\">,</span> <span class=\"n\">directoryInput</span><span class=\"o\">.</span><span class=\"na\">contentTypes</span><span class=\"o\">,</span> <span class=\"n\">directoryInput</span><span class=\"o\">.</span><span class=\"na\">scopes</span><span class=\"o\">,</span> <span class=\"nc\">Format</span><span class=\"o\">.</span><span class=\"na\">DIRECTORY</span><span class=\"o\">)</span>                    <span class=\"c1\">// check whether it is a bundle-file</span>                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">entryName</span><span class=\"o\">.</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">applicationId</span><span class=\"o\">))</span> <span class=\"o\">{</span>                        <span class=\"nc\">FileUtils</span><span class=\"o\">.</span><span class=\"na\">copyFile</span><span class=\"o\">(</span><span class=\"n\">it</span><span class=\"o\">,</span> <span class=\"n\">dest</span><span class=\"o\">)</span>                    <span class=\"o\">}</span>                <span class=\"o\">}</span>            <span class=\"o\">}</span>            <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"na\">jarInputs</span><span class=\"o\">.</span><span class=\"na\">each</span> <span class=\"o\">{</span> <span class=\"n\">jarInput</span> <span class=\"o\">-&gt;</span>                <span class=\"c1\">// we don't need libs currently</span>            <span class=\"o\">}</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">android</span><span class=\"o\">.</span><span class=\"na\">registerTransform</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">StripClassAndResTransform</span><span class=\"o\">(</span><span class=\"n\">project</span><span class=\"o\">))</span></code></pre></div></div><p>最后要做的就是，正常地打包 <code class=\"language-plaintext highlighter-rouge\">./gradlew assembleDebug</code> （工程名是 pluginByApk），然后看看打出来的 Apk 中的 Dex 文件是否包含了其他的依赖（例如 Support 包的文件），再用上一节的 Demo 测试一下即可（即 push 这个插件 apk 到 Downloads 文件夹，修改 bundleClassloader 加载的 apk 文件）。</p><h2 id=\"参考资料\">参考资料</h2><ul>  <li><a href=\"https://afterecho.uk/blog/create-a-standalone-gradle-plugin-for-android-part-4-the-transform-api.html\">https://afterecho.uk/blog/create-a-standalone-gradle-plugin-for-android-part-4-the-transform-api.html</a></li>  <li><a href=\"https://github.com/didi/VirtualAPK/blob/HEAD/virtualapk-gradle-plugin/src/main/groovy/com.didi.virtualapk/transform/StripClassAndResTransform.groovy\">https://github.com/didi/VirtualAPK/blob/HEAD/virtualapk-gradle-plugin/src/main/groovy/com.didi.virtualapk/transform/StripClassAndResTransform.groovy</a></li>  <li><a href=\"http://google.github.io/android-gradle-dsl/javadoc/current/\">http://google.github.io/android-gradle-dsl/javadoc/current/</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/10/16/plugadget-note-8-package-plugin-java-code",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2017-10-16T00:00:00+00:00",
            "date_modified": "2017-10-16T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/10/16/plugadget-note-7-multiclassloader",
            "title": "插件化笔记 #7 - MultiClassloader",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes为什么要有 Multi Classloader如上篇所说，我们不管要起 Activity、Service，其实都是需要注入自定义的 Classloader。而 Service 没有一个很好的简单注入点，所以才有了 Hook 上层 Classloader 的方案。这种方案有两种，都是解决多 Dex 加载的情况（不管插件化与否其实只要方法数超 65535 都是需要做多 Dex 加载）：  单一 Classloader：就是上篇说到的 MultiDex 使用的反射注入 DexPathList 的前部，这种是利用了 BaseDexClassloader 的 findClass 特性，由前往后查找 Dex 文件并加载 Class；  多 Classloader：利用双亲委派的 Classloader 机制，使得我们的 Classloader 可以优先于系统 Classloader 查找到 Class 并返回，通常会伴随着每个模块一个 Classloader，再由一个 HookClassloader 统一 Dispatch；目前淘宝、微店等都是使用多 Classloader 形式来实现 Dex 文件的动态加载，隔离性强、鲁棒性好，但实现上有所不同：  淘宝的 Atlas 做的是替换应用直接使用的 PathClassloader；  微店、Instant-Run 使用的是替换 PathClassloader 的 parent；本系列的尿性就是要简单，稳定，尽量不 Hook 任何系统服务，所以下面以替换 PathClassloader 的 parent 思路来讲：替换 PathClassloader 的 parent很明显我们应该在应用还没启动的时候就把这事干了，所以参考 Instant-Run，Hook 时机在 Application 的 attachBaseContext 里：public class MultiClassloaderApplication extends Application {    @Override    protected void attachBaseContext(Context base) {        super.attachBaseContext(base);        replacePathClassloaderParent(base);    }    private void replacePathClassloaderParent(Context context) {        ClassLoader pathClassloader = context.getClassLoader();        DispatchClassloader dispatchClassloader = new DispatchClassloader(pathClassloader, context);        final Class&lt;?&gt; clz = ClassLoader.class;        try {            final Field parentField = clz.getDeclaredField(\"parent\");            parentField.setAccessible(true);            parentField.set(pathClassloader, dispatchClassloader);        } catch (Exception e) {            e.printStackTrace();        }    }}实现 Multi Classloader[DispatchClassloader.java]public class DispatchClassloader extends ClassLoader {    private BundleClassloader dexClassLoader;    private Context context;    private ClassLoader origin;    public DispatchClassloader(ClassLoader origin, Context context) {        super(origin.getParent());        this.origin = origin;        this.context = context;        installDex();    }    private void installDex() {        // 这里目前只装载了一个测试 Dex，正常情况下需要装载某个目录下的所有 dex 文件（通常每个 Bundle 有一个 Dex）        File optimizedDexOutputPath = new File(                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS) + \"/7-MultiClassloader.dex\");        File dexOutputDir = context.getDir(\"dex\", 0);        dexClassLoader = new BundleClassloader(                optimizedDexOutputPath.getAbsolutePath(),                dexOutputDir.getAbsolutePath(),                null,                origin);    }    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        // 需要在这里遍历所有 Bundle 的 Classloader，或者用包名等来做查找分发        Class&lt;?&gt; clz = dexClassLoader.findClass(name);        return clz;    }}[BundleClassloader.java]public class BundleClassloader extends DexClassLoader {    public BundleClassloader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {        super(dexPath, optimizedDirectory, librarySearchPath, parent);    }        // 仅仅是用来改写 protected 签名    @Override    public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        return super.findClass(name);    }}几个注意点：  根据参考资料里 Google 的一段注释，如果不用 BundleClassloader 做查找转发的话，还有些隐藏 Bug。反正我们的目的本来就是需要多个 Classloader 的，就顺水推舟了；  请复写 findClass 而不是 loadClass，减少不必要的改动；  findClass 默认 protected 的，所以需要继承 DexClassloader 改写 findClass 的签名；Demo 工程打包过程：  先切到 /host 工程中，./gradlew installDebug 安装宿主工程；  再切到 /plugin 工程中，按 之前文章（Android插件化笔记-2-LoadPluginClass）打包 Dex 的办法打出插件 Dex 文件并重命名为「7-MultiClassloader.dex」；  adb push 该文件到手机的 /sdcard/Downloads/目录下  启动宿主工程，toast 出 3.14 即为成功；参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  http://blog.csdn.net/xiangzhihong8/article/details/64906131  https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/IncrementalClassLoader.java  https://juejin.im/entry/59ca1d2d6fb9a00a616f496c  https://mp.weixin.qq.com/s/p8-ABKDpMLm6T4lJdK8Y3Q欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><h2 id=\"为什么要有-multi-classloader\">为什么要有 Multi Classloader</h2><p>如上篇所说，我们不管要起 Activity、Service，其实都是需要注入自定义的 Classloader。而 Service 没有一个很好的简单注入点，所以才有了 Hook 上层 Classloader 的方案。这种方案有两种，都是解决多 Dex 加载的情况（不管插件化与否其实只要方法数超 65535 都是需要做多 Dex 加载）：</p><ol>  <li>单一 Classloader：就是上篇说到的 MultiDex 使用的反射注入 DexPathList 的前部，这种是利用了 BaseDexClassloader 的 findClass 特性，由前往后查找 Dex 文件并加载 Class；</li>  <li>多 Classloader：利用双亲委派的 Classloader 机制，使得我们的 Classloader 可以优先于系统 Classloader 查找到 Class 并返回，通常会伴随着每个模块一个 Classloader，再由一个 HookClassloader 统一 Dispatch；</li></ol><!--more--><p>目前淘宝、微店等都是使用多 Classloader 形式来实现 Dex 文件的动态加载，隔离性强、鲁棒性好，但实现上有所不同：</p><ol>  <li>淘宝的 Atlas 做的是替换应用直接使用的 PathClassloader；</li>  <li>微店、Instant-Run 使用的是替换 PathClassloader 的 parent；</li></ol><p>本系列的尿性就是要简单，稳定，尽量不 Hook 任何系统服务，所以下面以替换 PathClassloader 的 parent 思路来讲：</p><h2 id=\"替换-pathclassloader-的-parent\">替换 PathClassloader 的 parent</h2><p>很明显我们应该在应用还没启动的时候就把这事干了，所以参考 Instant-Run，Hook 时机在 Application 的 <code class=\"language-plaintext highlighter-rouge\">attachBaseContext</code> 里：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MultiClassloaderApplication</span> <span class=\"kd\">extends</span> <span class=\"nc\">Application</span> <span class=\"o\">{</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">attachBaseContext</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">attachBaseContext</span><span class=\"o\">(</span><span class=\"n\">base</span><span class=\"o\">);</span>        <span class=\"n\">replacePathClassloaderParent</span><span class=\"o\">(</span><span class=\"n\">base</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">replacePathClassloaderParent</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"nc\">ClassLoader</span> <span class=\"n\">pathClassloader</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getClassLoader</span><span class=\"o\">();</span>        <span class=\"nc\">DispatchClassloader</span> <span class=\"n\">dispatchClassloader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">DispatchClassloader</span><span class=\"o\">(</span><span class=\"n\">pathClassloader</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">);</span>        <span class=\"kd\">final</span> <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">clz</span> <span class=\"o\">=</span> <span class=\"nc\">ClassLoader</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">;</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"kd\">final</span> <span class=\"nc\">Field</span> <span class=\"n\">parentField</span> <span class=\"o\">=</span> <span class=\"n\">clz</span><span class=\"o\">.</span><span class=\"na\">getDeclaredField</span><span class=\"o\">(</span><span class=\"s\">\"parent\"</span><span class=\"o\">);</span>            <span class=\"n\">parentField</span><span class=\"o\">.</span><span class=\"na\">setAccessible</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>            <span class=\"n\">parentField</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">pathClassloader</span><span class=\"o\">,</span> <span class=\"n\">dispatchClassloader</span><span class=\"o\">);</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><h2 id=\"实现-multi-classloader\">实现 Multi Classloader</h2><p>[DispatchClassloader.java]</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DispatchClassloader</span> <span class=\"kd\">extends</span> <span class=\"nc\">ClassLoader</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"nc\">BundleClassloader</span> <span class=\"n\">dexClassLoader</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">origin</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"nf\">DispatchClassloader</span><span class=\"o\">(</span><span class=\"nc\">ClassLoader</span> <span class=\"n\">origin</span><span class=\"o\">,</span> <span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">origin</span><span class=\"o\">.</span><span class=\"na\">getParent</span><span class=\"o\">());</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">origin</span> <span class=\"o\">=</span> <span class=\"n\">origin</span><span class=\"o\">;</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">context</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">;</span>        <span class=\"n\">installDex</span><span class=\"o\">();</span>    <span class=\"o\">}</span>    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">installDex</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"c1\">// 这里目前只装载了一个测试 Dex，正常情况下需要装载某个目录下的所有 dex 文件（通常每个 Bundle 有一个 Dex）</span>        <span class=\"nc\">File</span> <span class=\"n\">optimizedDexOutputPath</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">File</span><span class=\"o\">(</span>                <span class=\"nc\">Environment</span><span class=\"o\">.</span><span class=\"na\">getExternalStoragePublicDirectory</span><span class=\"o\">(</span><span class=\"nc\">Environment</span><span class=\"o\">.</span><span class=\"na\">DIRECTORY_DOWNLOADS</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"s\">\"/7-MultiClassloader.dex\"</span><span class=\"o\">);</span>        <span class=\"nc\">File</span> <span class=\"n\">dexOutputDir</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getDir</span><span class=\"o\">(</span><span class=\"s\">\"dex\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>        <span class=\"n\">dexClassLoader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">BundleClassloader</span><span class=\"o\">(</span>                <span class=\"n\">optimizedDexOutputPath</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>                <span class=\"n\">dexOutputDir</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>                <span class=\"kc\">null</span><span class=\"o\">,</span>                <span class=\"n\">origin</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">findClass</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">ClassNotFoundException</span> <span class=\"o\">{</span>        <span class=\"c1\">// 需要在这里遍历所有 Bundle 的 Classloader，或者用包名等来做查找分发</span>        <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">clz</span> <span class=\"o\">=</span> <span class=\"n\">dexClassLoader</span><span class=\"o\">.</span><span class=\"na\">findClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>        <span class=\"k\">return</span> <span class=\"n\">clz</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>[BundleClassloader.java]</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BundleClassloader</span> <span class=\"kd\">extends</span> <span class=\"nc\">DexClassLoader</span> <span class=\"o\">{</span>    <span class=\"kd\">public</span> <span class=\"nf\">BundleClassloader</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">dexPath</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">optimizedDirectory</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">librarySearchPath</span><span class=\"o\">,</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">parent</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">dexPath</span><span class=\"o\">,</span> <span class=\"n\">optimizedDirectory</span><span class=\"o\">,</span> <span class=\"n\">librarySearchPath</span><span class=\"o\">,</span> <span class=\"n\">parent</span><span class=\"o\">);</span>    <span class=\"o\">}</span>        <span class=\"c1\">// 仅仅是用来改写 protected 签名</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">public</span> <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">findClass</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">ClassNotFoundException</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">findClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p><strong>几个注意点</strong>：</p><ol>  <li>根据参考资料里 Google 的一段注释，如果不用 BundleClassloader 做查找转发的话，还有些隐藏 Bug。反正我们的目的本来就是需要多个 Classloader 的，就顺水推舟了；</li>  <li>请复写 findClass 而不是 loadClass，减少不必要的改动；</li>  <li>findClass 默认 protected 的，所以需要继承 DexClassloader 改写 findClass 的签名；</li></ol><p><strong>Demo 工程打包过程</strong>：</p><ul>  <li>先切到 /host 工程中，<code class=\"language-plaintext highlighter-rouge\">./gradlew installDebug</code> 安装宿主工程；</li>  <li>再切到 /plugin 工程中，按 <a href=\"http://2bab.me/2016/09/18/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E7%AC%94%E8%AE%B0-2-LoadPluginClass/\">之前文章（Android插件化笔记-2-LoadPluginClass）</a>打包 Dex 的办法打出插件 Dex 文件并重命名为「7-MultiClassloader.dex」；</li>  <li>adb push 该文件到手机的 /sdcard/Downloads/目录下</li>  <li>启动宿主工程，toast 出 3.14 即为成功；</li></ul><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li><a href=\"http://blog.csdn.net/xiangzhihong8/article/details/64906131\">http://blog.csdn.net/xiangzhihong8/article/details/64906131</a></li>  <li><a href=\"https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/IncrementalClassLoader.java\">https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/instant-run/instant-run-server/src/main/java/com/android/tools/fd/runtime/IncrementalClassLoader.java</a></li>  <li><a href=\"https://juejin.im/entry/59ca1d2d6fb9a00a616f496c\">https://juejin.im/entry/59ca1d2d6fb9a00a616f496c</a></li>  <li><a href=\"https://mp.weixin.qq.com/s/p8-ABKDpMLm6T4lJdK8Y3Q\">https://mp.weixin.qq.com/s/p8-ABKDpMLm6T4lJdK8Y3Q</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/10/16/plugadget-note-7-multiclassloader",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2017-10-16T00:00:00+00:00",
            "date_modified": "2017-10-16T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/09/19/daily-of-agp-debuggable-not-work",
            "title": "构建指北 #7 debuggable 属性无效",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。问题回顾不久前，在接手手头上这个老工程时，发现 build.gradle 中设置 debuggable 属性是无效的，只能手动在 AndroidManifest.xml 的 application 节点写死该属性（之前团队里就这样默默干了两年，发版前去掉这个属性，发版后再加上…），最近得空花了两三个周末研究了下缘由。默认看此文章的人已经知道这点：  Android 系统判断一个 App 是否可 Debug 的标准是，AndroidManifest.xml 中的  application 节点是否存在 debuggable 属性，并且其值为 true。（可参考官方文档）问题分析 &amp; 源码重现0x01从 buildType 的 debuggable 属性开始分析追踪，既然我们知道 debuggable 其实会作用于 Manifest 的属性，那就找找跟 Manifest 相关的流程。先后看了 Android Gradle Plugin 中 process{variant}Manifest、process{variant}Resources、package{variant} 等 task 的流程，没有发现什么异常（此处不一一展开）。不过倒是对他们的中间生成产物有了些了解：  process{variant}Manifest 的 AndroidManifest.xml 中间产物位于  ./app/build/intermediates/manifests 中，分为 instant-run 和 其他 variant （debug、release、etc.）等各种文件夹；  process{variant}Resources 的 AndroidManifest.xml 位于 ./app/build/intermediates/res/resources-debug.ap_ 的压缩包中（事实上一开始没有看这个 task，是在看其他 task 的中间产物时发现这个 task 其实有 AndroidManifest.xml 的产物）；  package{variant} 的 AndroidManifest.xml 其实就是最后 apk 包中的文件了；除此之外，没看到有直接对 AndroidManifest.xml 中写入 debuggable 的操作（merge 除外）。0x02拿一个新建的工程和问题工程作比对发现：  新建工程：process{variant}Manifest 的产物中没有  debuggable 的属性，却在 process{variant}Resources 的产物中出现了该属性（debug 状态下为 true），说明内部操作发生在这一步；  问题工程：在所有 task 的  AndroidManifest.xml 产物中，均未出现 debuggable 的值；看来还得再翻翻 process{variant}Resources，这其中主要是调用 aapt 相关的操作，仔细查看发现如下关键代码：// AaptV1.java @Override@NonNullprotected ProcessInfoBuilder makePackageProcessBuilder(@NonNull AaptPackageConfig config)        throws AaptException {    ProcessInfoBuilder builder = new ProcessInfoBuilder();    /*     * AaptPackageProcessBuilder had this code below, but nothing was ever added to     * mEnvironment.     */    //builder.addEnvironments(mEnvironment);    builder.setExecutable(getAaptExecutablePath());    builder.addArgs(\"package\");    ...(省略无关紧要的一部分代码)        // 在此处注入了 buildType 的 debuggable 属性    if (config.isDebuggable()) {        builder.addArgs(\"--debug-mode\");    }    ...    return builder;}可以看到，在处理 aapt 的输入参数时带上了 debug 参数，随即便是调用 aapt 的外部过程，不在 Android Gradle Plugin 的控制范围内。0x03找出 Android SDK 源码，编译一个自己的 aapt（具体可以参考这里），别忘了在关键地方加上一些 log：  先是入口文件，找到对应读取 --debug-mode 的地方，会暂存于一个 bundle 中，并且参数获取正确，为 true，[Main.cpp]:if (strcmp(cp, \"-debug-mode\") == 0) {    fprintf(stderr, \"AAPTDEBUG: set debug == true\");    bundle.setDebugMode(true);}  再者，找到 bundle-&gt;getDebugMode() 的地方，发现这里就是核心部分了，真正把 debuggable 的结果写入到 AndroidManifest.xml 中；但是这里出现错误了—— application 节点获取不到，为 null，[Resource.cpp]：status_t massageManifest(Bundle* bundle, sp&lt;XMLNode&gt; root)    {    root = root-&gt;searchElement(String16(), String16(\"manifest\"));    if (root == NULL) {        fprintf(stderr, \"No &lt;manifest&gt; tag.\\n\");        return UNKNOWN_ERROR;    }        // ...        fprintf(stderr, \"AAPTDEBUG: bundle-&gt;getDebugMode()\");    if (bundle-&gt;getDebugMode()) {        fprintf(stderr, \"AAPTDEBUG: bundle-&gt;getDebugMode() - true\");        sp&lt;XMLNode&gt; application = root-&gt;getChildElement(String16(), String16(\"application\"));        if (application == NULL) {            fprintf(stderr, \"AAPTDEBUG: application == NULL\"); // 问题出处，打印出了这行 log        }        if (application != NULL) {            fprintf(stderr, \"AAPTDEBUG: application != NULL\");            if (!addTagAttribute(application, RESOURCES_ANDROID_NAMESPACE, \"debuggable\", \"true\",                        errorOnFailedInsert)) {                    fprintf(stderr, \"AAPTDEBUG: error on insert\");                return UNKNOWN_ERROR;            }        }    }        // ...}  看看 getChildElement() 的实现，发现上面的代码只会从 root 节点（也就是 manifest 节点）出发去找一级子节点，没有深入地递归查找，如果 application 不是 manifest 的一级子节点，则找不到，[XMLNode.cpp]：sp&lt;XMLNode&gt; XMLNode::getChildElement(const String16&amp; tagNamespace, const String16&amp; tagName)    {    printf(\"AAPTDEBUG: root -&gt; %s\\n\", String8(mElementName).string());    for (size_t i=0; i&lt;mChildren.size(); i++) {        sp&lt;XMLNode&gt; child = mChildren.itemAt(i);        if (child-&gt;getType() == XMLNode::TYPE_ELEMENT) {            printf(\"AAPTDEBUG: getChildElement-&gt; %s\\n\", String8(child-&gt;mElementName).string());        }            if (child-&gt;getType() == XMLNode::TYPE_ELEMENT                &amp;&amp; child-&gt;mNamespaceUri == tagNamespace                &amp;&amp; child-&gt;mElementName == tagName) {            return child;        }    }        return NULL;}  那最后的问题就只有，为什么 application 节点不是 manifest 的一级子节点，查一下编译出来的二进制 Manifest（./app/build/intermediates/res/resources-debug.ap_ ，为避免敏感信息，这里用 DebuggableTest 工程做示例）：  真相大白，application 的直接父节点是 namespace！0x04查看各类依赖库的 Manifest（build-cache/exploded-aar），查看 Manifest 的合并日志（app/build/outputs/logs/manifest-merger-{variant}-report），结合之前写的一个 Manifest Precheck 插件 Seal，发现会碰到这个问题，有两种可能：  依赖库本身对 namespace 的声明不只在 manifest 节点，例如在 application 节点声明了 android 的 namespace，可以参考我 pub 的这个  DebuggableTest 工程；  对 Manifest 合并前（即执行 process{variant}Manifest 前），如果有例如 Seal 这种对依赖库的 Manifest 做清洗工作，并且很巧你也用了 groovy.util 下的 XML 类库做 XML 解析和输出，那么恭喜你，这个库有几率会导致你的各种节点出现重复的 namespace，比如 uses-sdk 、application，不过我还没认真去排查到底什么情况下会出现这样的问题，目前实验中也只有少量的样本会这样，暂时没发现他们的共通点。解决方案      使用自定义的 aapt，改一行代码即可解决此类问题：将搜索 application 节点的方法从 sp&lt;XMLNode&gt; XMLNode::getChildElement(const String16&amp; tagNamespace, const String16&amp; tagName) 改为另外一个内建的方法 sp&lt;XMLNode&gt; XMLNode::searchElement(const String16&amp; tagNamespace, const String16&amp; tagName)，原因是 searchElement 的实现是会 for 循环查找所有深度子节点：     // Resource.cpp  status_t massageManifest(Bundle* bundle, sp&lt;XMLNode&gt; root)  {      root = root-&gt;searchElement(String16(), String16(\"manifest\"));      if (root == NULL) {          fprintf(stderr, \"No &lt;manifest&gt; tag.\\n\");          return UNKNOWN_ERROR;      }          ...          fprintf(stderr, \"AAPTDEBUG: bundle-&gt;getDebugMode()\");      if (bundle-&gt;getDebugMode()) {          fprintf(stderr, \"AAPTDEBUG: bundle-&gt;getDebugMode() - true\");          // 改掉查找方法！          sp&lt;XMLNode&gt; application = root-&gt;searchElement(String16(), String16(\"application\"));           ...      }      ... }    // XMLNode.cpp  sp&lt;XMLNode&gt; XMLNode::searchElement(const String16&amp; tagNamespace, const String16&amp; tagName)  {          if (getType() == XMLNode::TYPE_ELEMENT              &amp;&amp; mNamespaceUri == tagNamespace              &amp;&amp; mElementName == tagName) {          return this;      }      // 递归实现避免上述问题      for (size_t i=0; i&lt;mChildren.size(); i++) {          sp&lt;XMLNode&gt; found = mChildren.itemAt(i)-&gt;searchElement(tagNamespace, tagName);          if (found != NULL) {              return found;          }      }          return NULL;  }            或者使用新版的 Seal 插件 v1.1.0 ，增加了一个配置项 xmlnsSweep，会在执行 process{variant}Manifest 之后，对其产物进行 xmlns 的清洗，避免在 manifest 节点外出现不必要的 namespace 声明，详细使用说明请参考 Seal 仓库的 README（注意，目前使用 Seal 请一定要开启并配置 xmlnsSweep，因为不能保证所有的依赖库都不会在 Precheck 中出问题）  结论这大概是我今年研究过的最麻烦的问题了，链路长，大坑小坑不断，有 Google 挖的，有 Groovy 挖的，目前正在去给他们提 issue 的路上…铛！更新 issue 地址： https://issuetracker.google.com/issues/66074488 ！欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><h3 id=\"问题回顾\">问题回顾</h3><p>不久前，在接手手头上这个老工程时，发现 <code class=\"language-plaintext highlighter-rouge\">build.gradle</code> 中设置 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 属性是无效的，只能手动在 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 的 <code class=\"language-plaintext highlighter-rouge\">application</code> 节点写死该属性（之前团队里就这样默默干了两年，发版前去掉这个属性，发版后再加上…），最近得空花了两三个周末研究了下缘由。</p><p>默认看此文章的人已经知道这点：</p><blockquote>  <p>Android 系统判断一个 App 是否可 Debug 的标准是，AndroidManifest.xml 中的  application 节点是否存在 debuggable 属性，并且其值为 true。（可参考<a href=\"https://developer.android.com/guide/topics/manifest/application-element.html#android:debuggable\">官方文档</a>）</p></blockquote><!--more--><h3 id=\"问题分析--源码重现\">问题分析 &amp; 源码重现</h3><h4 id=\"0x01\">0x01</h4><p>从 <code class=\"language-plaintext highlighter-rouge\">buildType</code> 的 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 属性开始分析追踪，既然我们知道 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 其实会作用于 Manifest 的属性，那就找找跟 Manifest 相关的流程。先后看了 Android Gradle Plugin 中 <code class=\"language-plaintext highlighter-rouge\">process{variant}Manifest</code>、<code class=\"language-plaintext highlighter-rouge\">process{variant}Resources</code>、<code class=\"language-plaintext highlighter-rouge\">package{variant}</code> 等 task 的流程，没有发现什么异常（此处不一一展开）。不过倒是对他们的中间生成产物有了些了解：</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">process{variant}Manifest</code> 的 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 中间产物位于  ./app/build/intermediates/manifests 中，分为 instant-run 和 其他 variant （debug、release、etc.）等各种文件夹；</li>  <li><code class=\"language-plaintext highlighter-rouge\">process{variant}Resources</code> 的 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 位于 ./app/build/intermediates/res/resources-debug.ap_ 的压缩包中（事实上一开始没有看这个 task，是在看其他 task 的中间产物时发现这个 task 其实有 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 的产物）；</li>  <li><code class=\"language-plaintext highlighter-rouge\">package{variant}</code> 的 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 其实就是最后 apk 包中的文件了；</li></ul><p>除此之外，没看到有直接对 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 中写入 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 的操作（merge 除外）。</p><h4 id=\"0x02\">0x02</h4><p>拿一个新建的工程和问题工程作比对发现：</p><ul>  <li>新建工程：<code class=\"language-plaintext highlighter-rouge\">process{variant}Manifest</code> 的产物中没有  <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 的属性，却在 <code class=\"language-plaintext highlighter-rouge\">process{variant}Resources</code> 的产物中出现了该属性（debug 状态下为 true），说明内部操作发生在这一步；</li>  <li>问题工程：在所有 task 的  <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 产物中，均未出现 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 的值；</li></ul><p>看来还得再翻翻 <code class=\"language-plaintext highlighter-rouge\">process{variant}Resources</code>，这其中主要是调用 aapt 相关的操作，仔细查看发现如下关键代码：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// AaptV1.java </span><span class=\"nd\">@Override</span><span class=\"nd\">@NonNull</span><span class=\"kd\">protected</span> <span class=\"nc\">ProcessInfoBuilder</span> <span class=\"nf\">makePackageProcessBuilder</span><span class=\"o\">(</span><span class=\"nd\">@NonNull</span> <span class=\"nc\">AaptPackageConfig</span> <span class=\"n\">config</span><span class=\"o\">)</span>        <span class=\"kd\">throws</span> <span class=\"nc\">AaptException</span> <span class=\"o\">{</span>    <span class=\"nc\">ProcessInfoBuilder</span> <span class=\"n\">builder</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">ProcessInfoBuilder</span><span class=\"o\">();</span>    <span class=\"cm\">/*     * AaptPackageProcessBuilder had this code below, but nothing was ever added to     * mEnvironment.     */</span>    <span class=\"c1\">//builder.addEnvironments(mEnvironment);</span>    <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">setExecutable</span><span class=\"o\">(</span><span class=\"n\">getAaptExecutablePath</span><span class=\"o\">());</span>    <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">addArgs</span><span class=\"o\">(</span><span class=\"s\">\"package\"</span><span class=\"o\">);</span>    <span class=\"o\">...(</span><span class=\"n\">省略无关紧要的一部分代码</span><span class=\"o\">)</span>        <span class=\"c1\">// 在此处注入了 buildType 的 debuggable 属性</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">isDebuggable</span><span class=\"o\">())</span> <span class=\"o\">{</span>        <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">addArgs</span><span class=\"o\">(</span><span class=\"s\">\"--debug-mode\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"o\">...</span>    <span class=\"k\">return</span> <span class=\"n\">builder</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p>可以看到，在处理 aapt 的输入参数时带上了 debug 参数，随即便是调用 aapt 的外部过程，不在 Android Gradle Plugin 的控制范围内。</p><h4 id=\"0x03\">0x03</h4><p>找出 Android SDK 源码，编译一个自己的 aapt（具体可以参考<a href=\"http://2bab.me/2017/09/19/android-source-development-notes-3/\">这里</a>），别忘了在关键地方加上一些 log：</p><ul>  <li>先是入口文件，找到对应读取 <code class=\"language-plaintext highlighter-rouge\">--debug-mode</code> 的地方，会暂存于一个 bundle 中，并且参数获取正确，为 true，[Main.cpp]:</li></ul><div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strcmp</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">,</span> <span class=\"s\">\"-debug-mode\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: set debug == true\"</span><span class=\"p\">);</span>    <span class=\"n\">bundle</span><span class=\"p\">.</span><span class=\"n\">setDebugMode</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span><span class=\"p\">}</span></code></pre></div></div><ul>  <li>再者，找到 <code class=\"language-plaintext highlighter-rouge\">bundle-&gt;getDebugMode()</code> 的地方，发现这里就是核心部分了，真正把 <code class=\"language-plaintext highlighter-rouge\">debuggable</code> 的结果写入到 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> 中；但是这里出现错误了—— <strong>application 节点获取不到，为 null</strong>，[Resource.cpp]：</li></ul><div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">status_t</span> <span class=\"nf\">massageManifest</span><span class=\"p\">(</span><span class=\"n\">Bundle</span><span class=\"o\">*</span> <span class=\"n\">bundle</span><span class=\"p\">,</span> <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">root</span><span class=\"p\">)</span>    <span class=\"p\">{</span>    <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">-&gt;</span><span class=\"n\">searchElement</span><span class=\"p\">(</span><span class=\"n\">String16</span><span class=\"p\">(),</span> <span class=\"n\">String16</span><span class=\"p\">(</span><span class=\"s\">\"manifest\"</span><span class=\"p\">));</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"No &lt;manifest&gt; tag.</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>        <span class=\"k\">return</span> <span class=\"n\">UNKNOWN_ERROR</span><span class=\"p\">;</span>    <span class=\"p\">}</span>        <span class=\"c1\">// ...</span>        <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: bundle-&gt;getDebugMode()\"</span><span class=\"p\">);</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">bundle</span><span class=\"o\">-&gt;</span><span class=\"n\">getDebugMode</span><span class=\"p\">())</span> <span class=\"p\">{</span>        <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: bundle-&gt;getDebugMode() - true\"</span><span class=\"p\">);</span>        <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">application</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">-&gt;</span><span class=\"n\">getChildElement</span><span class=\"p\">(</span><span class=\"n\">String16</span><span class=\"p\">(),</span> <span class=\"n\">String16</span><span class=\"p\">(</span><span class=\"s\">\"application\"</span><span class=\"p\">));</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">application</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: application == NULL\"</span><span class=\"p\">);</span> <span class=\"c1\">// 问题出处，打印出了这行 log</span>        <span class=\"p\">}</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">application</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: application != NULL\"</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">addTagAttribute</span><span class=\"p\">(</span><span class=\"n\">application</span><span class=\"p\">,</span> <span class=\"n\">RESOURCES_ANDROID_NAMESPACE</span><span class=\"p\">,</span> <span class=\"s\">\"debuggable\"</span><span class=\"p\">,</span> <span class=\"s\">\"true\"</span><span class=\"p\">,</span>                        <span class=\"n\">errorOnFailedInsert</span><span class=\"p\">))</span> <span class=\"p\">{</span>                    <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: error on insert\"</span><span class=\"p\">);</span>                <span class=\"k\">return</span> <span class=\"n\">UNKNOWN_ERROR</span><span class=\"p\">;</span>            <span class=\"p\">}</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span>        <span class=\"c1\">// ...</span><span class=\"p\">}</span></code></pre></div></div><ul>  <li>看看 <code class=\"language-plaintext highlighter-rouge\">getChildElement()</code> 的实现，发现上面的代码只会从 root 节点（也就是 manifest 节点）出发去找一级子节点，没有深入地递归查找，如果 application 不是 manifest 的一级子节点，则找不到，[XMLNode.cpp]：</li></ul><div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">XMLNode</span><span class=\"o\">::</span><span class=\"n\">getChildElement</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">String16</span><span class=\"o\">&amp;</span> <span class=\"n\">tagNamespace</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">String16</span><span class=\"o\">&amp;</span> <span class=\"n\">tagName</span><span class=\"p\">)</span>    <span class=\"p\">{</span>    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"AAPTDEBUG: root -&gt; %s</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">String8</span><span class=\"p\">(</span><span class=\"n\">mElementName</span><span class=\"p\">).</span><span class=\"n\">string</span><span class=\"p\">());</span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">mChildren</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"n\">mChildren</span><span class=\"p\">.</span><span class=\"n\">itemAt</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">getType</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">XMLNode</span><span class=\"o\">::</span><span class=\"n\">TYPE_ELEMENT</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"AAPTDEBUG: getChildElement-&gt; %s</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">String8</span><span class=\"p\">(</span><span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">mElementName</span><span class=\"p\">).</span><span class=\"n\">string</span><span class=\"p\">());</span>        <span class=\"p\">}</span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">getType</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">XMLNode</span><span class=\"o\">::</span><span class=\"n\">TYPE_ELEMENT</span>                <span class=\"o\">&amp;&amp;</span> <span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">mNamespaceUri</span> <span class=\"o\">==</span> <span class=\"n\">tagNamespace</span>                <span class=\"o\">&amp;&amp;</span> <span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">mElementName</span> <span class=\"o\">==</span> <span class=\"n\">tagName</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"k\">return</span> <span class=\"n\">child</span><span class=\"p\">;</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span>        <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p><img src=\"http://2bab-images.lastmayday.com/blog/2017-09-19-gradle-daily-crash-debuggable-not-work-2.jpg?imageslim\" alt=\"\" /></p><ul>  <li>那最后的问题就只有，为什么 application 节点不是 manifest 的一级子节点，查一下编译出来的二进制 Manifest（./app/build/intermediates/res/resources-debug.ap_ ，为避免敏感信息，这里用 <a href=\"https://github.com/2BAB/DebuggableTest\">DebuggableTest</a> 工程做示例）：</li></ul><p><img src=\"http://2bab-images.lastmayday.com/blog/2017-09-19-gradle-daily-crash-debuggable-not-work-1.jpg?imageslim\" alt=\"\" /></p><ul>  <li>真相大白，application 的直接父节点是 namespace！</li></ul><h4 id=\"0x04\">0x04</h4><p>查看各类依赖库的 Manifest（build-cache/exploded-aar），查看 Manifest 的合并日志（app/build/outputs/logs/manifest-merger-{variant}-report），结合之前写的一个 Manifest Precheck 插件 <a href=\"https://github.com/2BAB/Seal\">Seal</a>，发现会碰到这个问题，有两种可能：</p><ol>  <li>依赖库本身对 namespace 的声明不只在 manifest 节点，例如在 application 节点声明了 android 的 namespace，可以参考我 pub 的这个  <a href=\"https://github.com/2BAB/DebuggableTest\">DebuggableTest</a> 工程；</li>  <li>对 Manifest 合并前（即执行 <code class=\"language-plaintext highlighter-rouge\">process{variant}Manifest</code> 前），如果有例如 <a href=\"https://github.com/2BAB/Seal\">Seal</a> 这种对依赖库的 Manifest 做清洗工作，<strong>并且很巧你也用了 <code class=\"language-plaintext highlighter-rouge\">groovy.util</code> 下的 XML 类库做 XML 解析和输出，那么恭喜你，这个库有几率会导致你的各种节点出现重复的 namespace，比如 uses-sdk 、application</strong>，不过我还没认真去排查到底什么情况下会出现这样的问题，目前实验中也只有少量的样本会这样，暂时没发现他们的共通点。</li></ol><h3 id=\"解决方案\">解决方案</h3><ul>  <li>    <p>使用自定义的 aapt，改一行代码即可解决此类问题：将搜索 application 节点的方法从 <code class=\"language-plaintext highlighter-rouge\">sp&lt;XMLNode&gt; XMLNode::getChildElement(const String16&amp; tagNamespace, const String16&amp; tagName)</code> 改为另外一个内建的方法 <code class=\"language-plaintext highlighter-rouge\">sp&lt;XMLNode&gt; XMLNode::searchElement(const String16&amp; tagNamespace, const String16&amp; tagName)</code>，原因是 searchElement 的实现是会 for 循环查找所有深度子节点：</p>    <div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"c1\">// Resource.cpp</span>  <span class=\"n\">status_t</span> <span class=\"nf\">massageManifest</span><span class=\"p\">(</span><span class=\"n\">Bundle</span><span class=\"o\">*</span> <span class=\"n\">bundle</span><span class=\"p\">,</span> <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">root</span><span class=\"p\">)</span>  <span class=\"p\">{</span>      <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">-&gt;</span><span class=\"n\">searchElement</span><span class=\"p\">(</span><span class=\"n\">String16</span><span class=\"p\">(),</span> <span class=\"n\">String16</span><span class=\"p\">(</span><span class=\"s\">\"manifest\"</span><span class=\"p\">));</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>          <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"No &lt;manifest&gt; tag.</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>          <span class=\"k\">return</span> <span class=\"n\">UNKNOWN_ERROR</span><span class=\"p\">;</span>      <span class=\"p\">}</span>          <span class=\"p\">...</span>          <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: bundle-&gt;getDebugMode()\"</span><span class=\"p\">);</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">bundle</span><span class=\"o\">-&gt;</span><span class=\"n\">getDebugMode</span><span class=\"p\">())</span> <span class=\"p\">{</span>          <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">\"AAPTDEBUG: bundle-&gt;getDebugMode() - true\"</span><span class=\"p\">);</span>          <span class=\"c1\">// 改掉查找方法！</span>          <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">application</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">-&gt;</span><span class=\"n\">searchElement</span><span class=\"p\">(</span><span class=\"n\">String16</span><span class=\"p\">(),</span> <span class=\"n\">String16</span><span class=\"p\">(</span><span class=\"s\">\"application\"</span><span class=\"p\">));</span>           <span class=\"p\">...</span>      <span class=\"p\">}</span>      <span class=\"p\">...</span> <span class=\"p\">}</span>    <span class=\"c1\">// XMLNode.cpp</span>  <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">XMLNode</span><span class=\"o\">::</span><span class=\"n\">searchElement</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">String16</span><span class=\"o\">&amp;</span> <span class=\"n\">tagNamespace</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">String16</span><span class=\"o\">&amp;</span> <span class=\"n\">tagName</span><span class=\"p\">)</span>  <span class=\"p\">{</span>          <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">getType</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">XMLNode</span><span class=\"o\">::</span><span class=\"n\">TYPE_ELEMENT</span>              <span class=\"o\">&amp;&amp;</span> <span class=\"n\">mNamespaceUri</span> <span class=\"o\">==</span> <span class=\"n\">tagNamespace</span>              <span class=\"o\">&amp;&amp;</span> <span class=\"n\">mElementName</span> <span class=\"o\">==</span> <span class=\"n\">tagName</span><span class=\"p\">)</span> <span class=\"p\">{</span>          <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">;</span>      <span class=\"p\">}</span>      <span class=\"c1\">// 递归实现避免上述问题</span>      <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">mChildren</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>          <span class=\"n\">sp</span><span class=\"o\">&lt;</span><span class=\"n\">XMLNode</span><span class=\"o\">&gt;</span> <span class=\"n\">found</span> <span class=\"o\">=</span> <span class=\"n\">mChildren</span><span class=\"p\">.</span><span class=\"n\">itemAt</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">searchElement</span><span class=\"p\">(</span><span class=\"n\">tagNamespace</span><span class=\"p\">,</span> <span class=\"n\">tagName</span><span class=\"p\">);</span>          <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">found</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>              <span class=\"k\">return</span> <span class=\"n\">found</span><span class=\"p\">;</span>          <span class=\"p\">}</span>      <span class=\"p\">}</span>          <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>  <span class=\"p\">}</span></code></pre></div>    </div>  </li>  <li>    <p>或者使用新版的 <a href=\"https://github.com/2BAB/Seal\">Seal</a> 插件 v1.1.0 ，增加了一个配置项 <code class=\"language-plaintext highlighter-rouge\">xmlnsSweep</code>，会在执行 <code class=\"language-plaintext highlighter-rouge\">process{variant}Manifest</code> 之后，对其产物进行 xmlns 的清洗，避免在 manifest 节点外出现不必要的 namespace 声明，详细使用说明请参考 <a href=\"https://github.com/2BAB/Seal\">Seal</a> 仓库的 README（注意，目前使用 Seal 请一定要开启并配置 <code class=\"language-plaintext highlighter-rouge\">xmlnsSweep</code>，因为不能保证所有的依赖库都不会在 Precheck 中出问题）</p>  </li></ul><h3 id=\"结论\">结论</h3><p>这大概是我今年研究过的最麻烦的问题了，链路长，大坑小坑不断，有 Google 挖的，有 Groovy 挖的，目前正在去给他们提 issue 的路上…</p><p>铛！更新 issue 地址： <a href=\"https://issuetracker.google.com/issues/66074488\">https://issuetracker.google.com/issues/66074488</a> ！</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/09/19/daily-of-agp-debuggable-not-work",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-09-19T00:00:00+00:00",
            "date_modified": "2017-09-19T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/09/19/android-source-development-notes-3",
            "title": "Android 源码笔记 #3 - Aapt 编译",
            "summary": null,
            "content_text": "碰到个问题，需要 debug aapt 里的一些东西，本来以为按照 Android源码笔记-1-编译&amp;烧录的一些坑 的办法去设置环境再把 make 命令目标改一下即可，但是发现还是有些小问题，写下记录一哈。先来结论，源码准备的步骤不叙，正确的步骤是：$ make clobber$ source build/envsetup.sh$ lunch sdk-eng $ make -j9 aapt              Google 爸爸的完整教程在此，一开始确实没发现；  注意，lunch、make 的目标和编译 ROM 不同；  由于是要编译一个自己用的 aapt，所以最好是备份一个 aapt，但是直接在源码目录 copy 一份会有报错，正确的姿势参考这个，当然，我偷懒直接拷了一份到非源码目录下的位置；  以 Mac 为例，生成产物的路径是 /pathToYourAndroidSource/out/host/darwin-x86/bin/aapt（一开始用的 /pathToYourAndroidSource/out/target 里的产物发现会出现 cannot execute binary file，正常在 Mac 上使用的 aapt 的格式是 Mach-O 的可执行文件，但是这个 aapt 是 elf-32 的，也就是 32位 的 linux 下执行的，暂时没去了解是编译出其他平台的版本还是中间产物）欢迎关注我的公众号和微博。",
            "content_html": "<p>碰到个问题，需要 debug aapt 里的一些东西，本来以为按照 <a href=\"http://2bab.me/2017/03/10/android-source-development-notes-1\">Android源码笔记-1-编译&amp;烧录的一些坑</a> 的办法去设置环境再把 <code class=\"language-plaintext highlighter-rouge\">make</code> 命令目标改一下即可，但是发现还是有些小问题，写下记录一哈。</p><p>先来结论，源码准备的步骤不叙，正确的步骤是：</p><div class=\"language-shell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span>make clobber<span class=\"nv\">$ </span><span class=\"nb\">source </span>build/envsetup.sh<span class=\"nv\">$ </span>lunch sdk-eng <span class=\"nv\">$ </span>make <span class=\"nt\">-j9</span> aapt            </code></pre></div></div><!--more--><ol>  <li>Google 爸爸的完整教程<a href=\"https://android.googlesource.com/platform/sdk/+/master/docs/howto_build_SDK.txt\">在此</a>，一开始确实没发现；</li>  <li>注意，lunch、make 的目标和编译 ROM 不同；</li>  <li>由于是要编译一个自己用的 aapt，所以最好是备份一个 aapt，但是直接在源码目录 copy 一份会有报错，正确的姿势<a href=\"http://blog.csdn.net/sbsujjbcy/article/details/51418336\">参考这个</a>，当然，我偷懒直接拷了一份到非源码目录下的位置；</li>  <li>以 Mac 为例，生成产物的路径是 <code class=\"language-plaintext highlighter-rouge\">/pathToYourAndroidSource/out/host/darwin-x86/bin/aapt</code>（一开始用的 <code class=\"language-plaintext highlighter-rouge\">/pathToYourAndroidSource/out/target</code> 里的产物发现会出现 <code class=\"language-plaintext highlighter-rouge\">cannot execute binary file</code>，正常在 Mac 上使用的 aapt 的格式是 Mach-O 的可执行文件，但是这个 aapt 是 elf-32 的，也就是 32位 的 linux 下执行的，暂时没去了解是编译出其他平台的版本还是中间产物）</li></ol><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/09/19/android-source-development-notes-3",
            
            
            
            "tags": ["Android","Framework","源码"],
            
            "date_published": "2017-09-19T00:00:00+00:00",
            "date_modified": "2017-09-19T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/08/16/daily-of-agp-class-not-found-of-jdk",
            "title": "构建指北 #6 JDK 内的某个包失踪了",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。最近在改一个之前的 Annotation Processor，想要实现一个这样的需求：对一个 Class 所 implement 的 interface 做判断——这些 interface 是否 extends 自一个统一的父 Interface。于是 Debug + Evaluate Expression 挖一下 TypeElement 的实例里都有些啥，看看有没好使的 API。  typeElement.getInterfaces() 可以拿到当前元素的 List，这个一目了然；  List 里的 typeMirror，其实质是 com.sun.tools.javac.code.Type$ClassType 类型；  进一步，在 Evaluate Expression 里瞎蒙会发现 ((Type.ClassType)mirror).interfaces_field 我们可以拿到上层具体的 Interface 信息，嗯，基本达到我们的目的了；有了刚刚的实验，就快速写出一个测试代码。接着编译打包——竟然报错（请无视它是个中文错误 =。=）：  错误：程序包 com.sun.tools.javac.code 不存在错误：找不到符号符号：类 Type明明 IDE （Android Studio）识别了，这个类也是个 JDK 自带的工具类，为何不存在？唯一能想到的原因就是编译时 JDK 的所有包并不是都已加入到 classpath 里。在 Google 的过程中，也发现过类似的问题，但是仔细检查了 IDE 的 Boot JDK 配置，Gradle 的 JAVA_HOME 配置，都没有错。好吧，可能这是个不为人知的某种默认操作…Google 没有明确的答案，问了很多师兄也只说碰到过类似的问题，最后还是靠自己引包解决（如果有了解内情的同学欢迎给我发邮件讨论！）。这边先给出一个我的解法：// 手动加入 tools.jar 到 compile// 使用 Gradle 提供的环境变量，避免自己写大量兼容性代码compile files(org.gradle.internal.jvm.Jvm.current().toolsJar)// 类似的环境变量 Gradle 还提供了一些// import org.gradle.internal.jvm.Jvm// println Jvm.current().javaHome// println Jvm.current().javacExecutable// println Jvm.current().javadocExecutable...咳咳，话说回来，即便解决了包的问题，上面那个找上层 Interface的办法也是有问题的，因为((Type.ClassType)mirror).interfaces_field  找出来的 interface type 是无法再向上查找 interfaces_field 的，找到的会是空值（没兴趣去看为什么了…）解决办法也是有的：TypeElement typeElement = elementUtils.getTypeElement(interfaceCanonicalName);List&lt;? extends TypeMirror&gt; interfaces = typeElement.getInterfaces();...循环用 elementUtils.getTypeElement(interfaceCanonicalName) 一路往上取 Interface 即可（还是靠自己之前的积累才蒙到..orz）。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>最近在改一个之前的 Annotation Processor，想要实现一个这样的需求：对一个 Class 所 implement 的 interface 做判断——这些 interface 是否 extends 自一个统一的父 Interface。于是 Debug + Evaluate Expression 挖一下 <code class=\"language-plaintext highlighter-rouge\">TypeElement</code> 的实例里都有些啥，看看有没好使的 API。</p><!--more--><ol>  <li><code class=\"language-plaintext highlighter-rouge\">typeElement.getInterfaces()</code> 可以拿到当前元素的 List<TypeMirror>，这个一目了然；</TypeMirror></li>  <li>List 里的 typeMirror，其实质是 <code class=\"language-plaintext highlighter-rouge\">com.sun.tools.javac.code.Type$ClassType</code> 类型；</li>  <li>进一步，在 Evaluate Expression 里瞎蒙会发现 <code class=\"language-plaintext highlighter-rouge\">((Type.ClassType)mirror).interfaces_field</code> 我们可以拿到上层具体的 Interface 信息，嗯，基本达到我们的目的了；</li></ol><p>有了刚刚的实验，就快速写出一个测试代码。接着编译打包——竟然报错（请无视它是个中文错误 =。=）：</p><blockquote>  <p>错误：程序包 com.sun.tools.javac.code 不存在错误：找不到符号符号：类 Type</p></blockquote><p>明明 IDE （Android Studio）识别了，这个类也是个 JDK 自带的工具类，为何不存在？唯一能想到的原因就是编译时 JDK 的所有包并不是都已加入到 classpath 里。在 Google 的过程中，也发现过<a href=\"https://stackoverflow.com/questions/10314904/no-com-sun-tools-javac-in-jdk7\">类似的问题</a>，但是仔细检查了 IDE 的 Boot JDK 配置，Gradle 的 JAVA_HOME 配置，都没有错。好吧，可能这是个不为人知的某种默认操作…</p><p>Google 没有明确的答案，问了很多师兄也只说碰到过类似的问题，最后还是靠自己引包解决（如果有了解内情的同学欢迎给我发邮件讨论！）。这边先给出一个我的解法：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 手动加入 tools.jar 到 compile</span><span class=\"c1\">// 使用 Gradle 提供的环境变量，避免自己写大量兼容性代码</span><span class=\"n\">compile</span> <span class=\"nf\">files</span><span class=\"o\">(</span><span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">gradle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">jvm</span><span class=\"o\">.</span><span class=\"na\">Jvm</span><span class=\"o\">.</span><span class=\"na\">current</span><span class=\"o\">().</span><span class=\"na\">toolsJar</span><span class=\"o\">)</span><span class=\"c1\">// 类似的环境变量 Gradle 还提供了一些</span><span class=\"c1\">// import org.gradle.internal.jvm.Jvm</span><span class=\"c1\">// println Jvm.current().javaHome</span><span class=\"c1\">// println Jvm.current().javacExecutable</span><span class=\"c1\">// println Jvm.current().javadocExecutable</span><span class=\"o\">...</span></code></pre></div></div><p>咳咳，话说回来，即便解决了包的问题，上面那个找上层 Interface的办法也是有问题的，因为<code class=\"language-plaintext highlighter-rouge\">((Type.ClassType)mirror).interfaces_field</code>  找出来的 interface type 是无法再向上查找 interfaces_field 的，找到的会是空值（没兴趣去看为什么了…）解决办法也是有的：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">TypeElement</span> <span class=\"n\">typeElement</span> <span class=\"o\">=</span> <span class=\"n\">elementUtils</span><span class=\"o\">.</span><span class=\"na\">getTypeElement</span><span class=\"o\">(</span><span class=\"n\">interfaceCanonicalName</span><span class=\"o\">);</span><span class=\"nc\">List</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"nc\">TypeMirror</span><span class=\"o\">&gt;</span> <span class=\"n\">interfaces</span> <span class=\"o\">=</span> <span class=\"n\">typeElement</span><span class=\"o\">.</span><span class=\"na\">getInterfaces</span><span class=\"o\">();</span><span class=\"o\">...</span></code></pre></div></div><p>循环用 <code class=\"language-plaintext highlighter-rouge\">elementUtils.getTypeElement(interfaceCanonicalName)</code> 一路往上取 Interface 即可（还是靠自己之前的积累才蒙到..orz）。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/08/16/daily-of-agp-class-not-found-of-jdk",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-08-16T00:00:00+00:00",
            "date_modified": "2017-08-16T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/06/21/daily-of-agp-buildscript-block-execute-order",
            "title": "构建指北 #5 含 buildscript 的脚本执行顺序",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。最近在改一个裹脚布项目，对打包脚本升级的要求是「循序渐进」（工期紧，稳定为主）——Debug 下用新版的 Gradle Plugin，Release 用旧版的。嗯，很自然会想到改动 root project 下的 build.gradle，加一段判断：// apply isDebug() method from utils.gradleapply from: project.getRootProject().rootDir.absolutePath + '/scripts/utils.gradle'def gradlePluginVersion = isDebug() ? '2.3.3' : '2.0.0'buildscript {    repositories {        jcenter()        mavenLocal()        mavenCentral()    }    dependencies {        // use outer variable        classpath \"com.android.tools.build:gradle:$gradlePluginVersion\"        classpath ...    }}...但是运行报错：  Could not get unknown property ‘gradlePluginVersion’ for object of type  org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.竟然找不到这个变量，不太合理呃，之前在各种脚本里定义依赖的时候也这样干过，没问题呀？神秘的 buildscript blockGoogle 翻一下，发现还是有一些类似的问题，但多数是在研究怎么让 buildscript 引入的 deps 可以被一些自定义的脚本找到的问题。读读官方文档，我们知道 buildscript() 是创建了 ScriptHandler 实例：  The closure passed to the buildscript() method configures a ScriptHandler instance. You declare the build script classpath by adding dependencies to the classpath configuration. This is the same way you declare, for example, the Java compilation classpath. You can use any of the dependency types described in Section 25.4, “How to declare your dependencies”, except project dependencies.  Having declared the build script classpath, you can use the classes in your build script as you would any other classes on the classpath.而 ScriptHandler 的源码注释写的是：  To declare the script classpath, you use the DependencyHandler provided by getDependencies() to attach dependencies to the “classpath” configuration. These dependencies are resolved just prior to script compilation, and assembled into the classpath for the script.也就是说，buildscript block 的执行是优于其他脚本的（但我猜应该有一个例外是 init script，后面有空再写一篇）。其实很好理解，因为这货定义的是 classpath 依赖，我们编译用到的的 Android Gradle Plugin 等等都是从这里引入的，如果 buildscript 不是优于其他脚本执行，那才会有问题嘞！撸个测试代码println 'Hello First Line'buildscript {    println 'Hello Second Line'    repositories {        ...    }    dependencies {        ...    }}afterEvaluate { project -&gt;    println 'Hello Third Line'}加 --info 执行这个脚本构建，可以看到如下输出：Starting BuildSettings evaluated using settings file '/Path/To/Your/Project/settings.gradle'.Projects loaded. Root project using build file '/Path/To/Your/Project/build.gradle'.Included projects: [root project 'Your-Project', project ':app']Evaluating root project 'Your-Project' using build file '/Path/To/Your/Project/build.gradle'.Hello Second Line/Path/To/Your/ProjectCreating new cache for metadata-2.23/module-metadata, path /Users/2bab/.gradle/caches/modules-2/metadata-2.23/module-metadata.bin, access org.gradle.cache.internal.DefaultCacheAccess@24473bd5Creating new cache for metadata-2.23/artifact-at-repository, path /Users/2bab/.gradle/caches/modules-2/metadata-2.23/artifact-at-repository.bin, access org.gradle.cache.internal.DefaultCacheAccess@24473bd5Hello First LineHello Third LineEvaluating project ':app' using build file '/Path/To/Your/Project/app/build.gradle'.可以看到执行顺序是 2-&gt;1-&gt;3，即先执行 Evaluate build.gradle，然后发生 2 的执行（也就是先执行 buildscript block），然后再顺序执行该脚本的其他代码 1（以及后续的代码如果有的话），Evaluate 结束执行 3。断点 Gradle 源码：1.DefaultScriptRunnerFactory.ScriptRunnerImpl.run() -&gt;@Overridepublic void run(Object target, ServiceRegistry scriptServices) throws GradleScriptException {    if (!compiledScript.getRunDoesSomething()) {        return;    }        ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();    T script = getScript();    script.init(target, scriptServices);    Thread.currentThread().setContextClassLoader(script.getContextClassloader());    script.getStandardOutputCapture().start();    try {        script.run();    } catch (Throwable e) {        throw new GradleScriptException(String.format(\"A problem occurred evaluating %s.\", script), e);    } finally {        script.getStandardOutputCapture().stop();        Thread.currentThread().setContextClassLoader(originalLoader);    }}2.ProjectScript.buildscript() -&gt;public void buildscript(Closure configureClosure) {    getScriptTarget().buildscript(configureClosure);}遗憾的是 script.run() 的过程暂时还没找到对应的实现，猜测和 Java 找 main 方法思路类似吧。但是通过比对 调用 ProjectScript.buildscript() 该方法的时机 和 测试代码打印的 log，会发现：断到该方法调用时，还没有任何的 log 输出（也就是 buildscript 确实是优先执行的），如果在 buildscript 闭包开始做任何操作，比如 apply 一个脚本，那么会立马走到对应的 apply 方法中。解法有了上面的测试，知道了 buildscript block 的优先执行，所以问题也就简单解决了——把 buildscript 相关逻辑的脚本放到 block 内；此外，如果 block 内的东西还需要暴露给其他脚本，依旧是可以用 ext 来做 export 的：buildscript {    apply from: project.getRootProject().rootDir.absolutePath + '/scripts/utils.gradle'    def gradlePluginVersion = isDebug() ? '2.3.3' : '2.0.0'    ext.gradlePluginVersion = gradlePluginVersion        repositories {        jcenter()        mavenLocal()        mavenCentral()    }    dependencies {        classpath \"com.android.tools.build:gradle:$gradlePluginVersion\"        ...    }}欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>最近在改一个裹脚布项目，对打包脚本升级的要求是「循序渐进」（工期紧，稳定为主）——Debug 下用新版的 Gradle Plugin，Release 用旧版的。嗯，很自然会想到改动 root project 下的 <code class=\"language-plaintext highlighter-rouge\">build.gradle</code>，加一段判断：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// apply isDebug() method from utils.gradle</span><span class=\"n\">apply</span> <span class=\"nl\">from:</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">getRootProject</span><span class=\"o\">().</span><span class=\"na\">rootDir</span><span class=\"o\">.</span><span class=\"na\">absolutePath</span> <span class=\"o\">+</span> <span class=\"s1\">'/scripts/utils.gradle'</span><span class=\"kt\">def</span> <span class=\"n\">gradlePluginVersion</span> <span class=\"o\">=</span> <span class=\"n\">isDebug</span><span class=\"o\">()</span> <span class=\"o\">?</span> <span class=\"s1\">'2.3.3'</span> <span class=\"o\">:</span> <span class=\"s1\">'2.0.0'</span><span class=\"k\">buildscript</span> <span class=\"o\">{</span>    <span class=\"k\">repositories</span> <span class=\"o\">{</span>        <span class=\"n\">jcenter</span><span class=\"o\">()</span>        <span class=\"n\">mavenLocal</span><span class=\"o\">()</span>        <span class=\"n\">mavenCentral</span><span class=\"o\">()</span>    <span class=\"o\">}</span>    <span class=\"k\">dependencies</span> <span class=\"o\">{</span>        <span class=\"c1\">// use outer variable</span>        <span class=\"n\">classpath</span> <span class=\"s2\">\"com.android.tools.build:gradle:$gradlePluginVersion\"</span>        <span class=\"n\">classpath</span> <span class=\"o\">...</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"o\">...</span></code></pre></div></div><!--more--><p>但是运行报错：</p><blockquote>  <p>Could not get unknown property ‘gradlePluginVersion’ for object of type  org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.</p></blockquote><p>竟然找不到这个变量，不太合理呃，之前在各种脚本里定义依赖的时候也这样干过，没问题呀？</p><h2 id=\"神秘的-buildscript-block\">神秘的 buildscript block</h2><p>Google 翻一下，发现还是有一些<a href=\"https://discuss.gradle.org/t/inherit-inject-buildscript-dependencies-into-custom-script-within-subproject/7175/9\">类似的问题</a>，但多数是在研究怎么让 buildscript 引入的 deps 可以被一些自定义的脚本找到的<a href=\"https://stackoverflow.com/questions/37058780/access-classpath-dependencies-defined-in-buildscript-block-in-applied-external-s\">问题</a>。</p><p>读读<a href=\"https://docs.gradle.org/3.3/userguide/organizing_build_logic.html#sec:build_script_external_dependencies\">官方文档</a>，我们知道 buildscript() 是创建了 ScriptHandler 实例：</p><blockquote>  <p>The closure passed to the buildscript() method configures a ScriptHandler instance. You declare the build script classpath by adding dependencies to the classpath configuration. This is the same way you declare, for example, the Java compilation classpath. You can use any of the dependency types described in Section 25.4, “How to declare your dependencies”, except project dependencies.</p></blockquote><blockquote>  <p>Having declared the build script classpath, you can use the classes in your build script as you would any other classes on the classpath.</p></blockquote><p>而 ScriptHandler 的源码注释写的是：</p><blockquote>  <p>To declare the script classpath, you use the DependencyHandler provided by getDependencies() to attach dependencies to the “classpath” configuration. <strong>These dependencies are resolved just prior to script compilation, and assembled into the classpath for the script.</strong></p></blockquote><p>也就是说，buildscript block 的执行是优于其他脚本的（但我猜应该有一个例外是 init script，后面有空再写一篇）。其实很好理解，因为这货定义的是 <strong>classpath</strong> 依赖，我们编译用到的的 <code class=\"language-plaintext highlighter-rouge\">Android Gradle Plugin</code> 等等都是从这里引入的，如果 buildscript 不是优于其他脚本执行，那才会有问题嘞！</p><h2 id=\"撸个测试代码\">撸个测试代码</h2><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">println</span> <span class=\"s1\">'Hello First Line'</span><span class=\"k\">buildscript</span> <span class=\"o\">{</span>    <span class=\"n\">println</span> <span class=\"s1\">'Hello Second Line'</span>    <span class=\"k\">repositories</span> <span class=\"o\">{</span>        <span class=\"o\">...</span>    <span class=\"o\">}</span>    <span class=\"k\">dependencies</span> <span class=\"o\">{</span>        <span class=\"o\">...</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"n\">afterEvaluate</span> <span class=\"o\">{</span> <span class=\"n\">project</span> <span class=\"o\">-&gt;</span>    <span class=\"n\">println</span> <span class=\"s1\">'Hello Third Line'</span><span class=\"o\">}</span></code></pre></div></div><p>加 <code class=\"language-plaintext highlighter-rouge\">--info</code> 执行这个脚本构建，可以看到如下输出：</p><div class=\"language-shell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Starting BuildSettings evaluated using settings file <span class=\"s1\">'/Path/To/Your/Project/settings.gradle'</span><span class=\"nb\">.</span>Projects loaded. Root project using build file <span class=\"s1\">'/Path/To/Your/Project/build.gradle'</span><span class=\"nb\">.</span>Included projects: <span class=\"o\">[</span>root project <span class=\"s1\">'Your-Project'</span>, project <span class=\"s1\">':app'</span><span class=\"o\">]</span>Evaluating root project <span class=\"s1\">'Your-Project'</span> using build file <span class=\"s1\">'/Path/To/Your/Project/build.gradle'</span><span class=\"nb\">.</span>Hello Second Line/Path/To/Your/ProjectCreating new cache <span class=\"k\">for </span>metadata-2.23/module-metadata, path /Users/2bab/.gradle/caches/modules-2/metadata-2.23/module-metadata.bin, access org.gradle.cache.internal.DefaultCacheAccess@24473bd5Creating new cache <span class=\"k\">for </span>metadata-2.23/artifact-at-repository, path /Users/2bab/.gradle/caches/modules-2/metadata-2.23/artifact-at-repository.bin, access org.gradle.cache.internal.DefaultCacheAccess@24473bd5Hello First LineHello Third LineEvaluating project <span class=\"s1\">':app'</span> using build file <span class=\"s1\">'/Path/To/Your/Project/app/build.gradle'</span><span class=\"nb\">.</span></code></pre></div></div><p><strong>可以看到执行顺序是 2-&gt;1-&gt;3，即先执行 Evaluate build.gradle，然后发生 2 的执行（也就是先执行 buildscript block），然后再顺序执行该脚本的其他代码 1（以及后续的代码如果有的话），Evaluate 结束执行 3。</strong></p><p>断点 Gradle 源码：</p><p>1.DefaultScriptRunnerFactory.ScriptRunnerImpl.run() -&gt;</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Override</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">(</span><span class=\"nc\">Object</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"nc\">ServiceRegistry</span> <span class=\"n\">scriptServices</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">GradleScriptException</span> <span class=\"o\">{</span>    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">compiledScript</span><span class=\"o\">.</span><span class=\"na\">getRunDoesSomething</span><span class=\"o\">())</span> <span class=\"o\">{</span>        <span class=\"k\">return</span><span class=\"o\">;</span>    <span class=\"o\">}</span>        <span class=\"nc\">ClassLoader</span> <span class=\"n\">originalLoader</span> <span class=\"o\">=</span> <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">getContextClassLoader</span><span class=\"o\">();</span>    <span class=\"no\">T</span> <span class=\"n\">script</span> <span class=\"o\">=</span> <span class=\"n\">getScript</span><span class=\"o\">();</span>    <span class=\"n\">script</span><span class=\"o\">.</span><span class=\"na\">init</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">scriptServices</span><span class=\"o\">);</span>    <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">setContextClassLoader</span><span class=\"o\">(</span><span class=\"n\">script</span><span class=\"o\">.</span><span class=\"na\">getContextClassloader</span><span class=\"o\">());</span>    <span class=\"n\">script</span><span class=\"o\">.</span><span class=\"na\">getStandardOutputCapture</span><span class=\"o\">().</span><span class=\"na\">start</span><span class=\"o\">();</span>    <span class=\"k\">try</span> <span class=\"o\">{</span>        <span class=\"n\">script</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Throwable</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">GradleScriptException</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">\"A problem occurred evaluating %s.\"</span><span class=\"o\">,</span> <span class=\"n\">script</span><span class=\"o\">),</span> <span class=\"n\">e</span><span class=\"o\">);</span>    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>        <span class=\"n\">script</span><span class=\"o\">.</span><span class=\"na\">getStandardOutputCapture</span><span class=\"o\">().</span><span class=\"na\">stop</span><span class=\"o\">();</span>        <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">().</span><span class=\"na\">setContextClassLoader</span><span class=\"o\">(</span><span class=\"n\">originalLoader</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>2.ProjectScript.buildscript() -&gt;</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">buildscript</span><span class=\"o\">(</span><span class=\"nc\">Closure</span> <span class=\"n\">configureClosure</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">getScriptTarget</span><span class=\"o\">().</span><span class=\"na\">buildscript</span><span class=\"o\">(</span><span class=\"n\">configureClosure</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p>遗憾的是 <code class=\"language-plaintext highlighter-rouge\">script.run()</code> 的过程暂时还没找到对应的实现，猜测和 Java 找 main 方法思路类似吧。但是通过比对 <strong>调用 <code class=\"language-plaintext highlighter-rouge\">ProjectScript.buildscript()</code> 该方法的时机</strong> 和 <strong>测试代码打印的 log</strong>，会发现：<strong>断到该方法调用时，还没有任何的 log 输出（也就是 buildscript 确实是优先执行的），如果在 buildscript 闭包开始做任何操作，比如 apply 一个脚本，那么会立马走到对应的 apply 方法中。</strong></p><h2 id=\"解法\">解法</h2><p>有了上面的测试，知道了 buildscript block 的优先执行，所以问题也就简单解决了——把 buildscript 相关逻辑的脚本放到 block 内；此外，如果 block 内的东西还需要暴露给其他脚本，依旧是可以用 <code class=\"language-plaintext highlighter-rouge\">ext</code> 来做 export 的：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">buildscript</span> <span class=\"o\">{</span>    <span class=\"n\">apply</span> <span class=\"nl\">from:</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">getRootProject</span><span class=\"o\">().</span><span class=\"na\">rootDir</span><span class=\"o\">.</span><span class=\"na\">absolutePath</span> <span class=\"o\">+</span> <span class=\"s1\">'/scripts/utils.gradle'</span>    <span class=\"kt\">def</span> <span class=\"n\">gradlePluginVersion</span> <span class=\"o\">=</span> <span class=\"n\">isDebug</span><span class=\"o\">()</span> <span class=\"o\">?</span> <span class=\"s1\">'2.3.3'</span> <span class=\"o\">:</span> <span class=\"s1\">'2.0.0'</span>    <span class=\"n\">ext</span><span class=\"o\">.</span><span class=\"na\">gradlePluginVersion</span> <span class=\"o\">=</span> <span class=\"n\">gradlePluginVersion</span>        <span class=\"k\">repositories</span> <span class=\"o\">{</span>        <span class=\"n\">jcenter</span><span class=\"o\">()</span>        <span class=\"n\">mavenLocal</span><span class=\"o\">()</span>        <span class=\"n\">mavenCentral</span><span class=\"o\">()</span>    <span class=\"o\">}</span>    <span class=\"k\">dependencies</span> <span class=\"o\">{</span>        <span class=\"n\">classpath</span> <span class=\"s2\">\"com.android.tools.build:gradle:$gradlePluginVersion\"</span>        <span class=\"o\">...</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/06/21/daily-of-agp-buildscript-block-execute-order",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-06-21T00:00:00+00:00",
            "date_modified": "2017-06-21T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/05/23/daily-of-agp-aar-replace-conflict",
            "title": "构建指北 #4 aar 和 tools:replace 冲突",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。最近做一些 SDK 升级时，有些包引入后会有诸如此类的报错：  AndroidManifest.xml:22:9-40 Error:    Attribute application@theme value=(@style/AppTheme) from AndroidManifest.xml:22:9-40    is also present at [some:libraries:version] AndroidManifest.xml:9:18-62 value=(@style/AnotherTheme).    Suggestion: add ‘tools:replace=”android:theme”’ to  element at AndroidManifest.xml:18:5-65:19 to override.这是一个很常见的错误了，照着提示做 replace 就 OK 了。但是当我加上 replace 的代码后，发现依旧报错：  Multiple entries with same key: @android:theme=REPLACE and android:theme=REPLACE.百思不得其解，查看了一下依赖库的 AndroidManifest.xml 源码，发现它也设置了tools:replace=\"android:theme\"，而 Manifest Merger 把这个视为冲突抛了出来。思考如果只是跟着 官方的 Manifest Merge，这个问题恐怕无解。StackOverflow 上也有人问过这个问题，但是没有更多的解法回复。为什么依赖库会想不开去设置 replace 属性呢？很大的一个可能是：他也碰到了他的依赖库和他的 Manifest 有冲突的情况。那么我们能做什么？我们始终还是想要把他的某些属性给替换掉的（theme/allowBackup/…），不管他是出于什么样的目的，都不能阻止我想打出包的心！解法通过简单的观察和源码查看，我们发现 merge 是发生在 process${variant}Manifest 这个 Task。那么就得想办法在执行这个任务之前 Precheck 一下所有依赖的 AndroidManifest.xml。Seal - A gradle plugin to do precheck of Android Manifest.我写了一个简易的插件来做这件事，目前支持两个功能：  删除 Application 节点的某些属性，如 debuggable、theme、allowBackup；  删除 Application 节点中 tools:replace 属性的某些值，如 android:icon、android:theme、android:allowBackup；这个插件不仅能解决上述提到的问题，还能顺带修复诸如下面这种 Warning：  Warning: AndroidManifest.xml already defines debuggable (in http://schemas.android.com/apk/res/android); using existing value in manifest.而我们所需要做的，仅仅是指定我们不需要 libraries 的那些属性：def projectRoot = project.getRootProject().rootDir.absolutePath// 依赖库的 Manifest 文件搜索路径// 1. Gradle plugin 2.3.0 或者更高版本，会默认开启 build-cache 功能，Release 版本的库会解压到这里// 2. 但是我们同样需要对 SNAPSHOT 的库做预检查，所以还需要加入 exploded-aar 的目录// 3. 有更多自定义的目录或者 module，请自行添加def manifestPath = [        // for AAR of Release        // see note below        projectRoot + '/build-cache',         // for AAR of SNAPSHOT        projectRoot + '/app/build/intermediates/exploded-aar']def removeAttrs = [        'android:debuggable']def replaceValues = [        'android:allowBackup']seal {    enabled = true    manifests = manifestPath    appAttrs {        enabled = true        attrsShouldRemove = removeAttrs    }    appReplaceValues {        enabled = true        valuesShouldRemove = replaceValues    }}需要注意的是，如果开启了 build-cache, Seal 建议你把 build-cache  的文件夹放在工程目录内（就是上面配置里的 build-cache 位置）。//gradle.propertiesandroid.buildCacheDir=./build-cache...更多信息，请参考 Github 仓库内的说明，欢迎大家提 PR 和 ISSUE。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>最近做一些 SDK 升级时，有些包引入后会有诸如此类的报错：</p><blockquote>  <p>AndroidManifest.xml:22:9-40 Error:    Attribute application@theme value=(@style/AppTheme) from AndroidManifest.xml:22:9-40    is also present at [some:libraries:version] AndroidManifest.xml:9:18-62 value=(@style/AnotherTheme).    Suggestion: add ‘tools:replace=”android:theme”’ to <application> element at AndroidManifest.xml:18:5-65:19 to override.</application></p></blockquote><p>这是一个很常见的错误了，照着提示做 <code class=\"language-plaintext highlighter-rouge\">replace</code> 就 OK 了。<strong>但是当我加上</strong> <code class=\"language-plaintext highlighter-rouge\">replace</code> <strong>的代码后，发现依旧报错：</strong></p><blockquote>  <p>Multiple entries with same key: @android:theme=REPLACE and android:theme=REPLACE.</p></blockquote><p><strong>百思不得其解，查看了一下依赖库的</strong> <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code> <strong>源码，发现它也设置了</strong><code class=\"language-plaintext highlighter-rouge\">tools:replace=\"android:theme\"</code><strong>，而 Manifest Merger 把这个视为冲突抛了出来。</strong></p><!--more--><h2 id=\"思考\">思考</h2><p>如果只是跟着 <a href=\"https://developer.android.com/studio/build/manifest-merge.html\">官方的 Manifest Merge</a>，这个问题恐怕无解。<a href=\"http://stackoverflow.com/questions/35131182/manifest-merge-in-android-studio\">StackOverflow</a> 上也有人问过这个问题，但是没有更多的解法回复。</p><p>为什么依赖库会想不开去设置 <code class=\"language-plaintext highlighter-rouge\">replace</code> 属性呢？很大的一个可能是：他也碰到了他的依赖库和他的 Manifest 有冲突的情况。那么我们能做什么？我们始终还是想要把他的某些属性给替换掉的（theme/allowBackup/…），不管他是出于什么样的目的，都不能阻止我想打出包的心！</p><h2 id=\"解法\">解法</h2><p>通过简单的观察和源码查看，我们发现 merge 是发生在 <code class=\"language-plaintext highlighter-rouge\">process${variant}Manifest</code> 这个 Task。那么就得想办法在执行这个任务之前 Precheck 一下所有依赖的 <code class=\"language-plaintext highlighter-rouge\">AndroidManifest.xml</code>。</p><p><a href=\"https://github.com/2BAB/Seal\">Seal - A gradle plugin to do precheck of Android Manifest.</a></p><p>我写了一个简易的插件来做这件事，目前支持两个功能：</p><ol>  <li>删除 Application 节点的某些属性，如 <code class=\"language-plaintext highlighter-rouge\">debuggable</code>、<code class=\"language-plaintext highlighter-rouge\">theme</code>、<code class=\"language-plaintext highlighter-rouge\">allowBackup</code>；</li>  <li>删除 Application 节点中 <code class=\"language-plaintext highlighter-rouge\">tools:replace</code> 属性的某些值，如 <code class=\"language-plaintext highlighter-rouge\">android:icon</code>、<code class=\"language-plaintext highlighter-rouge\">android:theme</code>、<code class=\"language-plaintext highlighter-rouge\">android:allowBackup</code>；</li></ol><p>这个插件不仅能解决上述提到的问题，还能顺带修复诸如下面这种 Warning：</p><blockquote>  <p>Warning: AndroidManifest.xml already defines debuggable (in http://schemas.android.com/apk/res/android); using existing value in manifest.</p></blockquote><p>而我们所需要做的，仅仅是指定我们不需要 libraries 的那些属性：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">def</span> <span class=\"n\">projectRoot</span> <span class=\"o\">=</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">getRootProject</span><span class=\"o\">().</span><span class=\"na\">rootDir</span><span class=\"o\">.</span><span class=\"na\">absolutePath</span><span class=\"c1\">// 依赖库的 Manifest 文件搜索路径</span><span class=\"c1\">// 1. Gradle plugin 2.3.0 或者更高版本，会默认开启 build-cache 功能，Release 版本的库会解压到这里</span><span class=\"c1\">// 2. 但是我们同样需要对 SNAPSHOT 的库做预检查，所以还需要加入 exploded-aar 的目录</span><span class=\"c1\">// 3. 有更多自定义的目录或者 module，请自行添加</span><span class=\"kt\">def</span> <span class=\"n\">manifestPath</span> <span class=\"o\">=</span> <span class=\"o\">[</span>        <span class=\"c1\">// for AAR of Release</span>        <span class=\"c1\">// see note below</span>        <span class=\"n\">projectRoot</span> <span class=\"o\">+</span> <span class=\"s1\">'/build-cache'</span><span class=\"o\">,</span>         <span class=\"c1\">// for AAR of SNAPSHOT</span>        <span class=\"n\">projectRoot</span> <span class=\"o\">+</span> <span class=\"s1\">'/app/build/intermediates/exploded-aar'</span><span class=\"o\">]</span><span class=\"kt\">def</span> <span class=\"n\">removeAttrs</span> <span class=\"o\">=</span> <span class=\"o\">[</span>        <span class=\"s1\">'android:debuggable'</span><span class=\"o\">]</span><span class=\"kt\">def</span> <span class=\"n\">replaceValues</span> <span class=\"o\">=</span> <span class=\"o\">[</span>        <span class=\"s1\">'android:allowBackup'</span><span class=\"o\">]</span><span class=\"n\">seal</span> <span class=\"o\">{</span>    <span class=\"n\">enabled</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>    <span class=\"n\">manifests</span> <span class=\"o\">=</span> <span class=\"n\">manifestPath</span>    <span class=\"n\">appAttrs</span> <span class=\"o\">{</span>        <span class=\"n\">enabled</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>        <span class=\"n\">attrsShouldRemove</span> <span class=\"o\">=</span> <span class=\"n\">removeAttrs</span>    <span class=\"o\">}</span>    <span class=\"n\">appReplaceValues</span> <span class=\"o\">{</span>        <span class=\"n\">enabled</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>        <span class=\"n\">valuesShouldRemove</span> <span class=\"o\">=</span> <span class=\"n\">replaceValues</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>需要注意的是，如果开启了 <code class=\"language-plaintext highlighter-rouge\">build-cache</code>, Seal 建议你把 build-cache  的文件夹放在工程目录内（就是上面配置里的 build-cache 位置）。</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//gradle.propertiesandroid.buildCacheDir=./build-cache...</code></pre></div></div><p>更多信息，请参考 Github 仓库内的说明，欢迎大家提 PR 和 ISSUE。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/05/23/daily-of-agp-aar-replace-conflict",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-05-23T00:00:00+00:00",
            "date_modified": "2017-05-23T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/04/14/daily-of-agp-aar-proguard",
            "title": "构建指北 #3 再谈 AAR 与混淆",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。之前写了篇文章讲到了由于 buildTypes 默认设置的原因导致  library module 无法 debug 的情况。事实上，当时只解决了打 Debug 包的情况，而忽略了打 Release 包时还埋了一个隐藏的问题。问题还原：我们在做全局的 rebuild 或者 assembleRelease 时，会出现有些类找不到的情况，而 assembleDebug 不会。仔细观察会发现，这些报错的类都是被外部 module 引用的部分，例如 module A 有类 Clazz，被 module B 引用，则 Clazz 报错。既然推断是互相引用时才会出问题，那基本可以判断 proguard 出问题了。把 module release 时的 proguard 关掉试试，果然不报错了！回想一下 Android 的打包顺序，应该是这样的：  分别打包各个的 library module（module 混淆）  整合解压所有的依赖，包括本地的依赖和远程的依赖，和 application module 一起打整包（整体混淆）那么，面对不同的情况，应该要有不同的混淆策略：      如果是本地的 library module：可以选择不在 library 做混淆，而只做全局的混淆，这样就不会出现上文的 module 相互引用找不到类的情况，并且只需要维护一份配置文件；        如果是输出到外部的 SDK，一般又分两种：                  闭源的：例如高德 SDK，友盟 SDK 等，一般会做 AAR 的混淆，但是会隔离出一个包或者一个类专门提供 API（也就是说明文档里的 API），这个包/类会 keep 住，但是大量的具体的实现会实施混淆，并且尽量把一些敏感内容、算法用 JNI 等方式去做调用。                    开源的：例如 Github 上的各类开源库，一般不做 AAR 的混淆，但是会提供一个 consumerProguardFiles 的配置项，用以保证库代码的关键部分不被混淆，如下（参考官方用户指南）         android {      defaultConfig {          consumerProguardFiles 'lib-proguard-rules.txt'      }      ...  }                    欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>之前写了篇<a href=\"http://2bab.me/2017/03/24/gradle-daily-crash-library-module-buildtypes/\">文章</a>讲到了由于 <code class=\"language-plaintext highlighter-rouge\">buildTypes</code> 默认设置的原因导致  library module 无法 debug 的情况。事实上，当时只解决了打 Debug 包的情况，而忽略了打 Release 包时还埋了一个隐藏的问题。</p><p>问题还原：我们在做全局的 <code class=\"language-plaintext highlighter-rouge\">rebuild</code> 或者 <code class=\"language-plaintext highlighter-rouge\">assembleRelease</code> 时，会出现有些类找不到的情况，而 <code class=\"language-plaintext highlighter-rouge\">assembleDebug</code> 不会。仔细观察会发现，这些报错的类都是被外部 module 引用的部分，例如 module A 有类 Clazz，被 module B 引用，则 Clazz 报错。</p><!--more--><p>既然推断是互相引用时才会出问题，那基本可以判断 proguard 出问题了。把 module release 时的 proguard 关掉试试，果然不报错了！回想一下 Android 的打包顺序，应该是这样的：</p><ol>  <li>分别打包各个的 library module（module 混淆）</li>  <li>整合解压所有的依赖，包括本地的依赖和远程的依赖，和 application module 一起打整包（整体混淆）</li></ol><p><strong>那么，面对不同的情况，应该要有不同的混淆策略：</strong></p><ul>  <li>    <p>如果是本地的 library module：可以选择不在 library 做混淆，而只做全局的混淆，这样就不会出现上文的 module 相互引用找不到类的情况，并且只需要维护一份配置文件；</p>  </li>  <li>    <p>如果是输出到外部的 SDK，一般又分两种：</p>    <ul>      <li>        <p>闭源的：例如高德 SDK，友盟 SDK 等，一般会做 AAR 的混淆，但是会隔离出一个包或者一个类专门提供 API（也就是说明文档里的 API），这个包/类会 keep 住，但是大量的具体的实现会实施混淆，并且尽量把一些敏感内容、算法用 JNI 等方式去做调用。</p>      </li>      <li>        <p>开源的：例如 Github 上的各类开源库，一般不做 AAR 的混淆，但是会提供一个 consumerProguardFiles 的配置项，用以保证库代码的关键部分不被混淆，如下（参考官方<a href=\"https://developer.android.com/studio/projects/android-library.html?hl=zh-cn\">用户指南</a>）</p>        <div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"n\">android</span> <span class=\"o\">{</span>      <span class=\"n\">defaultConfig</span> <span class=\"o\">{</span>          <span class=\"n\">consumerProguardFiles</span> <span class=\"s1\">'lib-proguard-rules.txt'</span>      <span class=\"o\">}</span>      <span class=\"o\">...</span>  <span class=\"o\">}</span></code></pre></div>        </div>      </li>    </ul>  </li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/04/14/daily-of-agp-aar-proguard",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-04-14T00:00:00+00:00",
            "date_modified": "2017-04-14T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/03/26/daily-of-agp-not-exploded-aar-2-3-0",
            "title": "构建指北 #2 AGP 2.3.0 再无 exploded-aar",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。升级 Android Gradle  Plugin 至 2.3.0 后，会发现 exploded-aar 这个 build 目录下的文件夹大部分情况下不存在了（但是仍然有时候会出现一两个 aar 的解压包，有些诡异）。这个改动最相关的原因是 2.3.0 默认开启了 Build Cache，具体在这里有说明。而我们之前有一个需求就是从 app module 的 exploded-aar 的 assets 中收集其他 module 的一些信息，现在也无法进行了。Google 一下会发现也有人怨声载道，并且有人给的解法是关掉 Build Cache。这显然是不满足我们提高生产力的需求滴，于是我研究了一下相关的源码。搜索 BuildCache 字样不难发现，Library 相关的 Task 中有这样一段代码：[-&gt;PrepareLibraryTask.java]/** * Returns {@code true} if the build cache should be used for the prepare-library task, and * {@code false} otherwise. */public static boolean shouldUseBuildCache(            boolean buildCacheEnabled, @NonNull MavenCoordinates mavenCoordinates) {    // We use the build cache only when it is enabled *and* the Maven artifact is not a snapshot    // version (to address http://b.android.com/228623)    return buildCacheEnabled &amp;&amp; !mavenCoordinates.getVersion().endsWith(\"-SNAPSHOT\");}所以第一个问题就解了，有用户提出 Cache 应该考虑到 Maven 仓库的发版习惯，对于 SNAPSHOT 这种经常会同版本多发版的情况需要忽略，采用降级方案（使用原来的 exploded-aar）。那指望从这里去解决问题是没救了，但是既然之前是从 assets 里做的数据收集，那从 raw 做是不是也可以？毕竟这是两个极其相似的文件夹，但是在打包过程中的处理却有些迥异。我们可以看到 raw 的 merge 结果其实是在 ./build/intermediates/res/merged/release/raw，并不走 exploded-aar，故这是一个兼容各个版本的一个取巧解决方案：如果你也需要在每个 library module 写入一些信息，并从 app module 做收集，那么 merged raw 是目前比较好使的一个暂存方案，就不要指望 exploded-aar 啦（除非你全部都发的是 SNAPSHOT）。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>升级 Android Gradle  Plugin 至 2.3.0 后，会发现 exploded-aar 这个 build 目录下的文件夹大部分情况下不存在了（但是仍然有时候会出现一两个 aar 的解压包，有些诡异）。这个改动最相关的原因是 2.3.0 默认开启了 Build Cache，具体在<a href=\"http://tools.android.com/tech-docs/build-cache\">这里</a>有说明。</p><!-- more --><p>而我们之前有一个需求就是从 app module 的 exploded-aar 的 assets 中收集其他 module 的一些信息，现在也无法进行了。Google 一下会发现也有人<a href=\"https://code.google.com/p/android/issues/detail?id=228404\">怨声载道</a>，并且有人给的<a href=\"http://likfe.com/2017/03/15/android-studio-exploded-aar/\">解法</a>是关掉 Build Cache。这显然是不满足我们提高生产力的需求滴，于是我研究了一下相关的源码。</p><p>搜索 BuildCache 字样不难发现，Library 相关的 Task 中有这样一段代码：</p><p>[-&gt;PrepareLibraryTask.java]</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/** * Returns {@code true} if the build cache should be used for the prepare-library task, and * {@code false} otherwise. */</span><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">boolean</span> <span class=\"nf\">shouldUseBuildCache</span><span class=\"o\">(</span>            <span class=\"kt\">boolean</span> <span class=\"n\">buildCacheEnabled</span><span class=\"o\">,</span> <span class=\"nd\">@NonNull</span> <span class=\"nc\">MavenCoordinates</span> <span class=\"n\">mavenCoordinates</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// We use the build cache only when it is enabled *and* the Maven artifact is not a snapshot</span>    <span class=\"c1\">// version (to address http://b.android.com/228623)</span>    <span class=\"k\">return</span> <span class=\"n\">buildCacheEnabled</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">mavenCoordinates</span><span class=\"o\">.</span><span class=\"na\">getVersion</span><span class=\"o\">().</span><span class=\"na\">endsWith</span><span class=\"o\">(</span><span class=\"s\">\"-SNAPSHOT\"</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p>所以第一个问题就解了，有用户提出 Cache 应该考虑到 Maven 仓库的发版习惯，对于 SNAPSHOT 这种经常会同版本多发版的情况需要忽略，采用降级方案（使用原来的 exploded-aar）。</p><p>那指望从这里去解决问题是没救了，但是既然之前是从 assets 里做的数据收集，那从 raw 做是不是也可以？毕竟这是两个极其相似的文件夹，但是在打包过程中的处理却有些迥异。</p><p>我们可以看到 raw 的 merge 结果其实是在 <code class=\"language-plaintext highlighter-rouge\">./build/intermediates/res/merged/release/raw</code>，并不走 exploded-aar，<strong>故这是一个兼容各个版本的一个取巧解决方案</strong>：如果你也需要在每个 library module 写入一些信息，并从 app module 做收集，那么 merged raw 是目前比较好使的一个暂存方案，就不要指望 exploded-aar 啦（除非你全部都发的是 SNAPSHOT）。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/03/26/daily-of-agp-not-exploded-aar-2-3-0",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-03-26T00:00:00+00:00",
            "date_modified": "2017-03-26T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/03/24/daily-of-agp-library-module-buildtypes",
            "title": "构建指北 #1 Library Module BuildTypes",
            "summary": null,
            "content_text": "『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。最近工作中换了一个工程，重新配了一遍 Gradle 的环境，然后发现所有的 Library Module 都无法 Debug 或者只能取到某些全局变量（局部变量找不到）。百思不得其解时，突然发现我明明打的是 Debug 包 assembleDebug，我的 Library Module 执行的却都是 transformClassesAndResourcesWithProguardForRelease。明明在这些 module 都配置了 debug 的 buildTypes，但却不生效，反而打了混淆的 release 包。debug {    debuggable true    jniDebuggable true    minifyEnabled false    zipAlignEnabled false    signingConfig signingConfigs.debug    ...}release {     debuggable false    jniDebuggable false    minifyEnabled true    zipAlignEnabled true    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard.cfg'    signingConfig signingConfigs.release}这个时候，@阿咏 给了我提示：http://stackoverflow.com/questions/28081846/use-different-build-types-of-library-module-in-android-app-module-in-android-stu。  Well, Gradle Android plugin simply can’t build the debug version of dependent library modules. This is a well-known, old issue and this is not resolved yet.原来这是有历史原因的，这东西就是这么设计滴（By Design），只能想办法绕一下。例如在这个问题下方的讨论里就提供了一种思路：android {    publishNonDefault true}dependencies {    releaseCompile project(path: ':yourLibrary', configuration: 'release')    debugCompile project(path: ':yourLibrary', configuration: 'debug')    // This is also possible    customCompile project(path: ':yourLibrary', configuration: 'custom')}不过，这样在有多个 Library Module 依赖的时候，显得不够优雅。这边我提供了一个自己的思路：android {    ...        buildTypes {        release {            debuggable isDebug()            minifyEnabled !isDebug()            zipAlignEnabled !isDebug()            proguardFiles getDefaultProguardFile('proguard-android.txt'), '../tools/proguard.cfg'            signingConfig signingConfigs.release        }    }        ...}def isDebug() {    if(gradle.startParameter.getTaskNames().size() == 0) { // for clean etc..        return true    }    return gradle.startParameter.getTaskNames().get(0).contains(\"Debug\")}我们就只提供一种 buildType，也就是默认的 release，然后把type 内的配置动态化即可。这种方案适合只有两三种 type 的情况，可以用少量的代码在 Library 内部就解决问题。欢迎关注我的公众号和微博。",
            "content_html": "<p><em>『构建指北』是探索 Android 构建相关的一系列文章，涵盖了 Gradle、Android Gradle Plugin、Kotlin Script 等工具，以及相关架构上的应用。以发现问题解决问题为出发点，传递新知提高生产效率为落脚点。</em></p><p>最近工作中换了一个工程，重新配了一遍 Gradle 的环境，然后发现所有的 Library Module 都无法 Debug 或者只能取到某些全局变量（局部变量找不到）。百思不得其解时，突然发现我明明打的是 Debug 包 <code class=\"language-plaintext highlighter-rouge\">assembleDebug</code>，我的 Library Module 执行的却都是 <code class=\"language-plaintext highlighter-rouge\">transformClassesAndResourcesWithProguardForRelease</code>。明明在这些 module 都配置了 <code class=\"language-plaintext highlighter-rouge\">debug</code> 的 <code class=\"language-plaintext highlighter-rouge\">buildTypes</code>，但却不生效，反而打了混淆的 release 包。</p><!-- more --><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">debug</span> <span class=\"o\">{</span>    <span class=\"n\">debuggable</span> <span class=\"kc\">true</span>    <span class=\"n\">jniDebuggable</span> <span class=\"kc\">true</span>    <span class=\"n\">minifyEnabled</span> <span class=\"kc\">false</span>    <span class=\"n\">zipAlignEnabled</span> <span class=\"kc\">false</span>    <span class=\"n\">signingConfig</span> <span class=\"n\">signingConfigs</span><span class=\"o\">.</span><span class=\"na\">debug</span>    <span class=\"o\">...</span><span class=\"o\">}</span><span class=\"n\">release</span> <span class=\"o\">{</span>     <span class=\"n\">debuggable</span> <span class=\"kc\">false</span>    <span class=\"n\">jniDebuggable</span> <span class=\"kc\">false</span>    <span class=\"n\">minifyEnabled</span> <span class=\"kc\">true</span>    <span class=\"n\">zipAlignEnabled</span> <span class=\"kc\">true</span>    <span class=\"n\">proguardFiles</span> <span class=\"nf\">getDefaultProguardFile</span><span class=\"o\">(</span><span class=\"s1\">'proguard-android.txt'</span><span class=\"o\">),</span> <span class=\"s1\">'proguard.cfg'</span>    <span class=\"n\">signingConfig</span> <span class=\"n\">signingConfigs</span><span class=\"o\">.</span><span class=\"na\">release</span><span class=\"o\">}</span></code></pre></div></div><p>这个时候，<a href=\"https://github.com/lomanyong\">@阿咏</a> 给了我提示：<a href=\"http://stackoverflow.com/questions/28081846/use-different-build-types-of-library-module-in-android-app-module-in-android-stu\">http://stackoverflow.com/questions/28081846/use-different-build-types-of-library-module-in-android-app-module-in-android-stu</a>。</p><blockquote>  <p>Well, Gradle Android plugin simply can’t build the debug version of dependent library modules. This is a well-known, old issue and this is not resolved yet.</p></blockquote><p>原来这是有历史原因的，这东西就是这么设计滴（By Design），只能想办法绕一下。例如在这个问题下方的讨论里就提供了一种思路：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">android</span> <span class=\"o\">{</span>    <span class=\"n\">publishNonDefault</span> <span class=\"kc\">true</span><span class=\"o\">}</span><span class=\"k\">dependencies</span> <span class=\"o\">{</span>    <span class=\"n\">releaseCompile</span> <span class=\"nf\">project</span><span class=\"o\">(</span><span class=\"nl\">path:</span> <span class=\"s1\">':yourLibrary'</span><span class=\"o\">,</span> <span class=\"nl\">configuration:</span> <span class=\"s1\">'release'</span><span class=\"o\">)</span>    <span class=\"n\">debugCompile</span> <span class=\"nf\">project</span><span class=\"o\">(</span><span class=\"nl\">path:</span> <span class=\"s1\">':yourLibrary'</span><span class=\"o\">,</span> <span class=\"nl\">configuration:</span> <span class=\"s1\">'debug'</span><span class=\"o\">)</span>    <span class=\"c1\">// This is also possible</span>    <span class=\"n\">customCompile</span> <span class=\"nf\">project</span><span class=\"o\">(</span><span class=\"nl\">path:</span> <span class=\"s1\">':yourLibrary'</span><span class=\"o\">,</span> <span class=\"nl\">configuration:</span> <span class=\"s1\">'custom'</span><span class=\"o\">)</span><span class=\"o\">}</span></code></pre></div></div><p><strong>不过，这样在有多个 Library Module 依赖的时候，显得不够优雅。这边我提供了一个自己的思路：</strong></p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">android</span> <span class=\"o\">{</span>    <span class=\"o\">...</span>        <span class=\"n\">buildTypes</span> <span class=\"o\">{</span>        <span class=\"n\">release</span> <span class=\"o\">{</span>            <span class=\"n\">debuggable</span> <span class=\"nf\">isDebug</span><span class=\"o\">()</span>            <span class=\"n\">minifyEnabled</span> <span class=\"o\">!</span><span class=\"n\">isDebug</span><span class=\"o\">()</span>            <span class=\"n\">zipAlignEnabled</span> <span class=\"o\">!</span><span class=\"n\">isDebug</span><span class=\"o\">()</span>            <span class=\"n\">proguardFiles</span> <span class=\"nf\">getDefaultProguardFile</span><span class=\"o\">(</span><span class=\"s1\">'proguard-android.txt'</span><span class=\"o\">),</span> <span class=\"s1\">'../tools/proguard.cfg'</span>            <span class=\"n\">signingConfig</span> <span class=\"n\">signingConfigs</span><span class=\"o\">.</span><span class=\"na\">release</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>        <span class=\"o\">...</span><span class=\"o\">}</span><span class=\"kt\">def</span> <span class=\"nf\">isDebug</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">gradle</span><span class=\"o\">.</span><span class=\"na\">startParameter</span><span class=\"o\">.</span><span class=\"na\">getTaskNames</span><span class=\"o\">().</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// for clean etc..</span>        <span class=\"k\">return</span> <span class=\"kc\">true</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">gradle</span><span class=\"o\">.</span><span class=\"na\">startParameter</span><span class=\"o\">.</span><span class=\"na\">getTaskNames</span><span class=\"o\">().</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">).</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"s2\">\"Debug\"</span><span class=\"o\">)</span><span class=\"o\">}</span></code></pre></div></div><p><strong>我们就只提供一种 buildType，也就是默认的 release，然后把type 内的配置动态化即可。这种方案适合只有两三种 type 的情况，可以用少量的代码在 Library 内部就解决问题。</strong></p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/03/24/daily-of-agp-library-module-buildtypes",
            
            
            
            "tags": ["Android","Gradle","Android Gradle Plugin","构建"],
            
            "date_published": "2017-03-24T00:00:00+00:00",
            "date_modified": "2017-03-24T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/03/10/android-source-development-notes-2",
            "title": "Android 源码笔记 #2 源码及 Framework 结构",
            "summary": null,
            "content_text": "源码结构框架图图片来自 Android Source Overview包说明下述说明引用自 Cloud Chou’s Tech Blog：  abi # 应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行  android # 存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码  bionic # bionic C库,Android没有使用标准的 glibc 库，而是自己重新实现了一套 C/C++库，包括 libc libdl libm libstdc++ libthread_db  bootable # 包含两个工程，recovery 和 diskinstaller，刷机或者系统升级都是由 Recovery完成的  build # Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析  cts # Android 兼容性测试套件标准  dalvik # dalvik Java 虚拟机，Android 用的 Java 虚拟机和 PC 上用的 JVM 不一样  development # 应用程序开发工具 有 eclipse 开发用的formatter配置  device # 设备相关配置文件，存放规则 device/$vendor/$product  docs # 网站文档  external # 用到的第三方库 象 busybox bash openssl 等工具都存放在该目录  filelist # 使用 godir 命令生成的索引文件  frameworks # 核心框架 —— Java 及 C++ 语言，可生成 framework.jar  gdk # glass 开发 sdk  hardware # 部分厂家开源的硬件适配层 HAL 代码  kernel # 内核源码目录 存放规则 kernel/$vendor/$product  libcore # 一些有用的库 像 xml Jason luni  libnativehelper # Support functions for Android’s class libraries  Makefile # 在顶层目录编译，利用的默认Makefile，它只是简单包含了 build/core/main.mk  ndk # ndk开发工具  packages # Android apk程序所在目录,象 settings，g- allery 等程序  pdk # Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase  prebuilt # x86和arm架构下预编译的一些资源  prebuilts # 有clang eclipse gcc misc ndk qemu-kernel sdk tools 等子目录，交叉编译工具链所在目录  sdk # sdk及模拟器  system # 核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd 也在 system/core 目录  tools # 有子目录 build 和 motodev，可能跟摩托罗拉有关  vendor # 设备制造商专用的配置存放目录，存放规则 vendor/$vendor/$product着重关心的如果不是像小米这样的有自己硬件的厂商，其实一般关心的层面在 Android Framework 和 Applications。映射到具体包就是 frameworks 和 packages。应用程序没啥好看的，每个版本也不尽相同，主要看看 frameworks，下面内容摘自 Git_Android 的 Android核心服务解析篇(二)——Android源码结构分析：应用程序框架是Android系统中的核心部分，也就是SDK部分，它会提供接口给应用程序使用，同时应用程序框架又会与系统服务，系统程序库，硬件抽象层的关联，所以其作用十分重大，应用程序框架的实现代码大部分都在/frameworks/base和/frameworks/av目录下。frameworks/base的目录结构如下所示：frameworks/base  api //全是XML文件，定义了API  cmds //Android中的重要命令（am，app_proce等）  core //核心库  data //声音字体等数据文件  docs //文档  drm //数字版权管理  graphics  //图形图像  icu4j //用于解决国际化问题  include //头文件  keystore  //数字签名证书相关  libs //库  location  //地理位置  media //多媒体  native //本地库  nfc-extras  //NFC相关  obex //蓝牙传输  opengl //OpenGL相关  packages  //设置，TTS,VPN程序  policy //锁屏界面相关  sax //XML解析器  services  //Android服务  telephony  //电话相关  test-runner  //测试相关  tests //测试相关  tools //工具  voip //可视通话  wifi //无线网络Android应用程序框架层的大部分实现代码被保存在/frameworks/base目录下，其实在这个目录中还有一个名为service的目录，里面的代码用于实现Android系统服务，其目录结构如下所示：frameworks/base/services  common_time  //日期时间相关的服务  input //输入系统服务  Java //其他重要服务的Java层  jni //其他重要服务的JNI层  tests //测试相关其中java和jni两个目录分别是一些其他的服务的Java层和JNI层实现，java目录下的目录结构以及其他Android系统服务的相关说明如下所示：frameworks/base/services/core/java/com/android/server  accessibility  am  connectivity  display  dreams  drm  input  location  net  pm  power  updates  usb\\——wm  AlarmManagerService.java//闹钟服务  AppWidgetService.java//应用程序小工具服务  AppWidgetServiceImpl.java  AttributeCache.java\\——BackupManagerService.java//备份服务  BatteryService.java//电池相关服务  BluetoothManagerService.java//蓝牙  BootReceiver.java  BrickReceiver.java  CertBlacklister.java  ClipboardService.java  CommonTimeManagementService.java//时间管理服务  ConnectivityService.java  CountryDetectorService.java  DevicePolicyManagerService.java  DeviceStorageMonitorService.java//设备存储器监听服务  DiskStatsService.java//磁盘状态服务  DockObserver.java//底座监视服务  DropBoxManagerService.java  EntropyMixer.java  EventLogTags.logtags  INativeDaemonConnectorCallbacks.java  InputMethodManagerService.java//输入法管理服务  IntentResolver.java  IntentResolverOld.java  LightsService.java  LocationManagerService.java//地理位置服务  MasterClearReceiver.java  MountService.java//挂载服务  NativeDaemonConnector.java  NativeDaemonConnectorException.java  NativeDaemonEvent.java  NetworkManagementService.java//网络管理服务  NetworkTimeUpdateService.java  NotificationManagerService.java//通知服务  NsdService.java  PackageManagerBackupAgent.java  PreferredComponent.java  ProcessMap.java  RandomBlock.java  RecognitionManagerService.java  SamplingProfilerService.java  SerialService.java//NFC相关  ServiceWatcher.java  ShutdownActivity.java  StatusBarManagerService.java//状态栏管理服务  SystemBackupAgent.java  SystemService.java  TelephonyRegistry.java  TextServicesManagerService.java  ThrottleService.java  TwilightCalculator.java  TwilightService.java  UiModeManagerService.java  UpdateLockService.java//锁屏更新服务  VibratorService.java//震动服务  WallpaperManagerService.java//壁纸服务  Watchdog.java//看门狗  WifiService.java//无线网络服务  WiredAccessoryManager.java//无线设备管理服务从上面的文件夹和文件可以看出，Android中涉及的服务种类有：界面，网络，电话等核心模块，这些专属服务是系统级别的服务，这些系统服务一般都会在Android系统启动的时候加载，在系统关闭的时候结束，受到系统的管理，应用程序并没有权力去打开或者关闭，它们会随着系统的运行一直在后台运行，供应用程序和其他组件来使用。另外，在framework/av/目录下面有一个services目录，在此目录中存放的是音频和照相机的服务的实现代码，此目录的具体结构如下所示：frameworks/av/services  audioflinger//音频管理服务  camera//照相机的管理服务av/services目录主要用来支持Android系统中的音频和照相机服务。媒体库：Android中的媒体库在2.3版之前是由OpenCore实现的，2.3版之后Stragefright被替换了,OpenCore成为新的多媒体的实现库。同时Android自带了一些音视频的管理库，用于管理多媒体的录制，播放，编码和解码等功能。Android的多媒体程序库的实现代码主要在/frameworks/av/media目录中，其目录结构如下：frameworks/av/media/  common_time  //时间相关  libeffects  //多媒体效果  libmedia  //多媒体录制，播放  libmedia_native  //里面只有一个Android。迥，用来编译native文件  libmediaplayerservice//多媒体播放服务的实现库  libstagefright  //Stagefright的实现库  mediaserver  //跨进程多媒体服务  mtp //MTP协议的实现（媒体传输协议）图层显示库：Android中的图层显示库主要负责对显示子系统的管理，负责图层的渲染，叠加，绘制等功能，提供了2D和3D图层的无缝融合，是整个Android系统显示的“大脑中枢”，其代码在/frameworks/native/services/surfaceflinger/目录下，其目录结构如下所示：frameworks/native/services/surfaceflinger/  DisplayHardware//显示底层相关  tests//测试  Android.mk//MakeFile文件  Barrier.h  Client.cpp//显示的客户端实现文件  Client.h  clz.cpp  clz.h  DdmConnection.cpp  DdmConnection.h  DisplayDevice.cpp//显示设备相关  DisplayDevice.h  EventThread.cpp//消息线程  EventThread.h  GLExtensions.cpp//OpenGL扩展  GLExtensions.h  Layer.cpp//图层相关  Layer.h  LayerBase.cpp//图层基类  LayerBase.h  LayerDim.cpp//图层相关  LayerDim.h  LayerScreenshot.cpp//图层相关  LayerScreenshot.h  MessageQueue.cpp//消息队列  MessageQueue.h  MODULE_LICENSE_APACHE2//证书  SurfaceFlinger.cpp//图层管理者，图层管理的核心类  SurfaceFlinger.h  SurfaceTextureLayer.cpp//文字图层  SurfaceTextureLayer.h  Transform.cpp  Transform.h3D图形库：Android中的3D图形渲染是采用OpenGL来实现的，OpenGl是开源的第三方图形渲染库，使用该库可以实现Android中的3D图形硬件加速或者3D图形软件加速功能，是一个非常重要的功能库。从Android 4.3开始，支持最新，最强大的OpenGL ES3.0.其实现代码在/frameworks/native/opengl中，其目录结构如下所示：frameworks/native/opengl/  include //OpenGL中的头文件  libagl //在Mac OS上的库  libs //OpenGL的接口和实现库  specs //OpenGL的文档  tests //测试相关  tools //工具库SQLite：SQLite是Android系统自带的一个轻量级关系数据库，其实现源代码已经在网上开源。SQLite的优点是操作方便，运行速度较快，占用资源较少等，比较适合在嵌入式设备上面使用。SQLite是Android系统自带的实现数据库功能的核心库，其代码实现分为Java和C两个部分，Java部分的代码位于/frameworks/base/core/java/android/database，主要是实现SQLite的框架和接口的实现，使用户开发应用程序时能很简单地操作数据库，并且捕获数据库异常。目录结构如下所示：frameworks/base/core/java/android/database/  sqlite//SQLite的框架文件  AbstractCursor.java//游标的抽象类  AbstractWindowedCursor.java  BulkCursorDescriptor.java  BulkCursorNative.java  BulkCursorToCursorAdaptor.java//游标适配器  CharArrayBuffer.java  ContentObservable.java  ContentObserver.java  CrossProcessCursor.java  CrossProcessCursorWrapper.java//CrossProcessCursor的封装类  Cursor.java//游标实现娄  CursorIndexOutOfBoundsException.java//游标出界异常  CursorJoiner.java  CursorToBulkCursorAdaptor.java//适配器  CursorWindow.java//游标窗口  CursorWindowAllocationException.java//游标窗口异常  CursorWrapper.java//游标封装类  DatabaseErrorHandler.java//数据库错误句柄  DatabaseUtils.java//数据库工具类  DataSetObservable.java  DataSetObserver.java  DefaultDatabaseErrorHandle.java//默认数据库错误句柄  IBulkCursor.java  IContentObserver.aidl//aidl用于跨进程通信  MatrixCursor.java  MergeCursor.java  Observable.java  package.html  SQLException.java//数据库异常  StaleDataException.java欢迎关注我的公众号和微博。",
            "content_html": "<h2 id=\"源码结构\">源码结构</h2><h3 id=\"框架图\">框架图</h3><p>图片来自 <a href=\"http://source.android.com/source/\">Android Source Overview</a></p><p><img src=\"http://2bab-images.lastmayday.com/blog/2017-03-10-android-source-development-notes-2-2.jpeg\" alt=\"\" /></p><!--more--><h3 id=\"包说明\">包说明</h3><p>下述说明引用自 <a href=\"http://www.cloudchou.com/android/post-136.html\">Cloud Chou’s Tech Blog</a>：</p><ul>  <li>abi # 应用二进制接口，不同的操作系统，应用二进制接口不同，因此linux上的二进制可执行文件在windows上无法执行</li>  <li>android # 存放了一些xml文件，用于描述工程路径及其对应的远程仓库地址，repo工具将使用这些信息同步代码</li>  <li>bionic # bionic C库,Android没有使用标准的 glibc 库，而是自己重新实现了一套 C/C++库，包括 libc libdl libm libstdc++ libthread_db</li>  <li>bootable # 包含两个工程，recovery 和 diskinstaller，刷机或者系统升级都是由 Recovery完成的</li>  <li>build # Android编译系统核心代码都存放在该目录，我们也将对该目录下的文件做详细分析</li>  <li>cts # Android 兼容性测试套件标准</li>  <li>dalvik # dalvik Java 虚拟机，Android 用的 Java 虚拟机和 PC 上用的 JVM 不一样</li>  <li>development # 应用程序开发工具 有 eclipse 开发用的formatter配置</li>  <li>device # 设备相关配置文件，存放规则 device/$vendor/$product</li>  <li>docs # 网站文档</li>  <li>external # 用到的第三方库 象 busybox bash openssl 等工具都存放在该目录</li>  <li>filelist # 使用 godir 命令生成的索引文件</li>  <li>frameworks # 核心框架 —— Java 及 C++ 语言，可生成 framework.jar</li>  <li>gdk # glass 开发 sdk</li>  <li>hardware # 部分厂家开源的硬件适配层 HAL 代码</li>  <li>kernel # 内核源码目录 存放规则 kernel/$vendor/$product</li>  <li>libcore # 一些有用的库 像 xml Jason luni</li>  <li>libnativehelper # Support functions for Android’s class libraries</li>  <li>Makefile # 在顶层目录编译，利用的默认Makefile，它只是简单包含了 build/core/main.mk</li>  <li>ndk # ndk开发工具</li>  <li>packages # Android apk程序所在目录,象 settings，g- allery 等程序</li>  <li>pdk # Platform Development Kit The goal of the PDK release is to help chipset vendors and OEMs to migrate to a new relelase</li>  <li>prebuilt # x86和arm架构下预编译的一些资源</li>  <li>prebuilts # 有clang eclipse gcc misc ndk qemu-kernel sdk tools 等子目录，交叉编译工具链所在目录</li>  <li>sdk # sdk及模拟器</li>  <li>system # 核心代码，包含了最小化可启动的环境，还有底层调试及检查工具，adbd 也在 system/core 目录</li>  <li>tools # 有子目录 build 和 motodev，可能跟摩托罗拉有关</li>  <li>vendor # 设备制造商专用的配置存放目录，存放规则 vendor/$vendor/$product</li></ul><h3 id=\"着重关心的\">着重关心的</h3><p>如果不是像小米这样的有自己硬件的厂商，其实一般关心的层面在 <code class=\"language-plaintext highlighter-rouge\">Android Framework</code> 和 <code class=\"language-plaintext highlighter-rouge\">Applications</code>。映射到具体包就是 <code class=\"language-plaintext highlighter-rouge\">frameworks</code> 和 <code class=\"language-plaintext highlighter-rouge\">packages</code>。应用程序没啥好看的，每个版本也不尽相同，主要看看 <code class=\"language-plaintext highlighter-rouge\">frameworks</code>，下面内容摘自 <a href=\"http://blog.csdn.net/liyuanjinglyj/article/details/48056579\">Git_Android 的 Android核心服务解析篇(二)——Android源码结构分析</a>：</p><p>应用程序框架是Android系统中的核心部分，也就是SDK部分，它会提供接口给应用程序使用，同时应用程序框架又会与系统服务，系统程序库，硬件抽象层的关联，所以其作用十分重大，应用程序框架的实现代码大部分都在/frameworks/base和/frameworks/av目录下。</p><p>frameworks/base的目录结构如下所示：<strong>frameworks/base</strong></p><ul>  <li>api //全是XML文件，定义了API</li>  <li>cmds //Android中的重要命令（am，app_proce等）</li>  <li>core //核心库</li>  <li>data //声音字体等数据文件</li>  <li>docs //文档</li>  <li>drm //数字版权管理</li>  <li>graphics  //图形图像</li>  <li>icu4j //用于解决国际化问题</li>  <li>include //头文件</li>  <li>keystore  //数字签名证书相关</li>  <li>libs //库</li>  <li>location  //地理位置</li>  <li>media //多媒体</li>  <li>native //本地库</li>  <li>nfc-extras  //NFC相关</li>  <li>obex //蓝牙传输</li>  <li>opengl //OpenGL相关</li>  <li>packages  //设置，TTS,VPN程序</li>  <li>policy //锁屏界面相关</li>  <li>sax //XML解析器</li>  <li>services  //Android服务</li>  <li>telephony  //电话相关</li>  <li>test-runner  //测试相关</li>  <li>tests //测试相关</li>  <li>tools //工具</li>  <li>voip //可视通话</li>  <li>wifi //无线网络</li></ul><p>Android应用程序框架层的大部分实现代码被保存在/frameworks/base目录下，其实在这个目录中还有一个名为service的目录，里面的代码用于实现Android系统服务，其目录结构如下所示：</p><p><strong>frameworks/base/services</strong></p><ul>  <li>common_time  //日期时间相关的服务</li>  <li>input //输入系统服务</li>  <li>Java //其他重要服务的Java层</li>  <li>jni //其他重要服务的JNI层</li>  <li>tests //测试相关</li></ul><p>其中java和jni两个目录分别是一些其他的服务的Java层和JNI层实现，java目录下的目录结构以及其他Android系统服务的相关说明如下所示：</p><p><strong>frameworks/base/services/core/java/com/android/server</strong></p><ul>  <li>accessibility</li>  <li>am</li>  <li>connectivity</li>  <li>display</li>  <li>dreams</li>  <li>drm</li>  <li>input</li>  <li>location</li>  <li>net</li>  <li>pm</li>  <li>power</li>  <li>updates</li>  <li>usb</li></ul><p>\\——wm</p><ul>  <li>AlarmManagerService.java//闹钟服务</li>  <li>AppWidgetService.java//应用程序小工具服务</li>  <li>AppWidgetServiceImpl.java</li>  <li>AttributeCache.java</li></ul><p>\\——BackupManagerService.java//备份服务</p><ul>  <li>BatteryService.java//电池相关服务</li>  <li>BluetoothManagerService.java//蓝牙</li>  <li>BootReceiver.java</li>  <li>BrickReceiver.java</li>  <li>CertBlacklister.java</li>  <li>ClipboardService.java</li>  <li>CommonTimeManagementService.java//时间管理服务</li>  <li>ConnectivityService.java</li>  <li>CountryDetectorService.java</li>  <li>DevicePolicyManagerService.java</li>  <li>DeviceStorageMonitorService.java//设备存储器监听服务</li>  <li>DiskStatsService.java//磁盘状态服务</li>  <li>DockObserver.java//底座监视服务</li>  <li>DropBoxManagerService.java</li>  <li>EntropyMixer.java</li>  <li>EventLogTags.logtags</li>  <li>INativeDaemonConnectorCallbacks.java</li>  <li>InputMethodManagerService.java//输入法管理服务</li>  <li>IntentResolver.java</li>  <li>IntentResolverOld.java</li>  <li>LightsService.java</li>  <li>LocationManagerService.java//地理位置服务</li>  <li>MasterClearReceiver.java</li>  <li>MountService.java//挂载服务</li>  <li>NativeDaemonConnector.java</li>  <li>NativeDaemonConnectorException.java</li>  <li>NativeDaemonEvent.java</li>  <li>NetworkManagementService.java//网络管理服务</li>  <li>NetworkTimeUpdateService.java</li>  <li>NotificationManagerService.java//通知服务</li>  <li>NsdService.java</li>  <li>PackageManagerBackupAgent.java</li>  <li>PreferredComponent.java</li>  <li>ProcessMap.java</li>  <li>RandomBlock.java</li>  <li>RecognitionManagerService.java</li>  <li>SamplingProfilerService.java</li>  <li>SerialService.java//NFC相关</li>  <li>ServiceWatcher.java</li>  <li>ShutdownActivity.java</li>  <li>StatusBarManagerService.java//状态栏管理服务</li>  <li>SystemBackupAgent.java</li>  <li>SystemService.java</li>  <li>TelephonyRegistry.java</li>  <li>TextServicesManagerService.java</li>  <li>ThrottleService.java</li>  <li>TwilightCalculator.java</li>  <li>TwilightService.java</li>  <li>UiModeManagerService.java</li>  <li>UpdateLockService.java//锁屏更新服务</li>  <li>VibratorService.java//震动服务</li>  <li>WallpaperManagerService.java//壁纸服务</li>  <li>Watchdog.java//看门狗</li>  <li>WifiService.java//无线网络服务</li>  <li>WiredAccessoryManager.java//无线设备管理服务</li></ul><p>从上面的文件夹和文件可以看出，Android中涉及的服务种类有：界面，网络，电话等核心模块，这些专属服务是系统级别的服务，这些系统服务一般都会在Android系统启动的时候加载，在系统关闭的时候结束，受到系统的管理，应用程序并没有权力去打开或者关闭，它们会随着系统的运行一直在后台运行，供应用程序和其他组件来使用。</p><p>另外，在framework/av/目录下面有一个services目录，在此目录中存放的是音频和照相机的服务的实现代码，此目录的具体结构如下所示：</p><p><strong>frameworks/av/services</strong></p><ul>  <li>audioflinger//音频管理服务</li>  <li>camera//照相机的管理服务</li></ul><p>av/services目录主要用来支持Android系统中的音频和照相机服务。</p><p>媒体库：Android中的媒体库在2.3版之前是由OpenCore实现的，2.3版之后Stragefright被替换了,OpenCore成为新的多媒体的实现库。同时Android自带了一些音视频的管理库，用于管理多媒体的录制，播放，编码和解码等功能。</p><p>Android的多媒体程序库的实现代码主要在/frameworks/av/media目录中，其目录结构如下：</p><p><strong>frameworks/av/media/</strong></p><ul>  <li>common_time  //时间相关</li>  <li>libeffects  //多媒体效果</li>  <li>libmedia  //多媒体录制，播放</li>  <li>libmedia_native  //里面只有一个Android。迥，用来编译native文件</li>  <li>libmediaplayerservice//多媒体播放服务的实现库</li>  <li>libstagefright  //Stagefright的实现库</li>  <li>mediaserver  //跨进程多媒体服务</li>  <li>mtp //MTP协议的实现（媒体传输协议）</li></ul><p>图层显示库：Android中的图层显示库主要负责对显示子系统的管理，负责图层的渲染，叠加，绘制等功能，提供了2D和3D图层的无缝融合，是整个Android系统显示的“大脑中枢”，其代码在/frameworks/native/services/surfaceflinger/目录下，其目录结构如下所示：</p><p><strong>frameworks/native/services/surfaceflinger/</strong></p><ul>  <li>DisplayHardware//显示底层相关</li>  <li>tests//测试</li>  <li>Android.mk//MakeFile文件</li>  <li>Barrier.h</li>  <li>Client.cpp//显示的客户端实现文件</li>  <li>Client.h</li>  <li>clz.cpp</li>  <li>clz.h</li>  <li>DdmConnection.cpp</li>  <li>DdmConnection.h</li>  <li>DisplayDevice.cpp//显示设备相关</li>  <li>DisplayDevice.h</li>  <li>EventThread.cpp//消息线程</li>  <li>EventThread.h</li>  <li>GLExtensions.cpp//OpenGL扩展</li>  <li>GLExtensions.h</li>  <li>Layer.cpp//图层相关</li>  <li>Layer.h</li>  <li>LayerBase.cpp//图层基类</li>  <li>LayerBase.h</li>  <li>LayerDim.cpp//图层相关</li>  <li>LayerDim.h</li>  <li>LayerScreenshot.cpp//图层相关</li>  <li>LayerScreenshot.h</li>  <li>MessageQueue.cpp//消息队列</li>  <li>MessageQueue.h</li>  <li>MODULE_LICENSE_APACHE2//证书</li>  <li>SurfaceFlinger.cpp//图层管理者，图层管理的核心类</li>  <li>SurfaceFlinger.h</li>  <li>SurfaceTextureLayer.cpp//文字图层</li>  <li>SurfaceTextureLayer.h</li>  <li>Transform.cpp</li>  <li>Transform.h</li></ul><p>3D图形库：Android中的3D图形渲染是采用OpenGL来实现的，OpenGl是开源的第三方图形渲染库，使用该库可以实现Android中的3D图形硬件加速或者3D图形软件加速功能，是一个非常重要的功能库。从Android 4.3开始，支持最新，最强大的OpenGL ES3.0.其实现代码在/frameworks/native/opengl中，其目录结构如下所示：</p><p><strong>frameworks/native/opengl/</strong></p><ul>  <li>include //OpenGL中的头文件</li>  <li>libagl //在Mac OS上的库</li>  <li>libs //OpenGL的接口和实现库</li>  <li>specs //OpenGL的文档</li>  <li>tests //测试相关</li>  <li>tools //工具库</li></ul><p>SQLite：SQLite是Android系统自带的一个轻量级关系数据库，其实现源代码已经在网上开源。SQLite的优点是操作方便，运行速度较快，占用资源较少等，比较适合在嵌入式设备上面使用。SQLite是Android系统自带的实现数据库功能的核心库，其代码实现分为Java和C两个部分，Java部分的代码位于/frameworks/base/core/java/android/database，主要是实现SQLite的框架和接口的实现，使用户开发应用程序时能很简单地操作数据库，并且捕获数据库异常。目录结构如下所示：</p><p><strong>frameworks/base/core/java/android/database/</strong></p><ul>  <li>sqlite//SQLite的框架文件</li>  <li>AbstractCursor.java//游标的抽象类</li>  <li>AbstractWindowedCursor.java</li>  <li>BulkCursorDescriptor.java</li>  <li>BulkCursorNative.java</li>  <li>BulkCursorToCursorAdaptor.java//游标适配器</li>  <li>CharArrayBuffer.java</li>  <li>ContentObservable.java</li>  <li>ContentObserver.java</li>  <li>CrossProcessCursor.java</li>  <li>CrossProcessCursorWrapper.java//CrossProcessCursor的封装类</li>  <li>Cursor.java//游标实现娄</li>  <li>CursorIndexOutOfBoundsException.java//游标出界异常</li>  <li>CursorJoiner.java</li>  <li>CursorToBulkCursorAdaptor.java//适配器</li>  <li>CursorWindow.java//游标窗口</li>  <li>CursorWindowAllocationException.java//游标窗口异常</li>  <li>CursorWrapper.java//游标封装类</li>  <li>DatabaseErrorHandler.java//数据库错误句柄</li>  <li>DatabaseUtils.java//数据库工具类</li>  <li>DataSetObservable.java</li>  <li>DataSetObserver.java</li>  <li>DefaultDatabaseErrorHandle.java//默认数据库错误句柄</li>  <li>IBulkCursor.java</li>  <li>IContentObserver.aidl//aidl用于跨进程通信</li>  <li>MatrixCursor.java</li>  <li>MergeCursor.java</li>  <li>Observable.java</li>  <li>package.html</li>  <li>SQLException.java//数据库异常</li>  <li>StaleDataException.java</li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/03/10/android-source-development-notes-2",
            
            
            
            "tags": ["Android","Framework","源码"],
            
            "date_published": "2017-03-10T00:00:00+00:00",
            "date_modified": "2017-03-10T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/03/10/android-source-development-notes-1",
            "title": "Android 源码笔记 #1 编译&烧录",
            "summary": null,
            "content_text": "由于最近工作需要 + 自己也挺感兴趣，折腾起 Android 的下层开发。环境描述：  macOS 10.12 Sierra  Xcode 8（安装各种环境会用到，然而正式编译时没用这个）  android-5.1.1_r14，LMY48M，Nexus 7（flo）素材准备上 Google 爸爸的 Android Source ，按 Establishing a Build Environment 和 Downloading the Source 做完即可，只有小坑如下：  Creating a case-sensitive disk image 时，不要用 Disk Utility 的 GUI 界面创建，大概因为版本更新了，找不到创建稀疏磁盘的选项，并且大小写那项我选了两回都没生效（？？？），请按它后续的提示直接用 shell 操作；  Reverting from make 3.82 这段，看清楚其实只有在 4.0.x 及以下系统才需要做，现在一般不会去编这个版本了可以忽略；  Initializing a Repo client 就是下源码啦，可以使用清华大学的 AOSP 镜像，比较不会碰到下载的各种问题（不过我是公司网，直连速度喜人 4M/s）。编译按着 Android Source 的步骤，现在终于要 Preparing to Build 啦，注意到其实还有个页面可能没看仔细——Requirements，这里有坑的：  Mac OS (Intel/x86)      Android 6.0 (Marshmallow) - AOSP master: Mac OS v10.10 (Yosemite) or later with Xcode 4.5.2 and Command Line Tools          Android 5.x (Lollipop): Mac OS v10.8 (Mountain Lion) with Xcode 4.5.2 and Command Line Tools              Android 4.1.x-4.3.x (Jelly Bean) - Android 4.4.x (KitKat): Mac OS v10.6 (Snow Leopard) or Mac OS X v10.7 (Lion) and Xcode 4.2 (Apple’s Developer Tools)        Android 1.5 (Cupcake) - Android 4.0.x (Ice Cream Sandwich): Mac OS v10.5 (Leopard) or Mac OS X v10.6 (Snow Leopard) and the Mac OS X v10.5 SDK  按这个表，Google 其实推荐 5.x 6.0 使用 4.5.2 的 Xcode 及其 SDK 来编译，然而现代 macOS 早已不支持这些老东西了：  StackOverflow 上各种教你拷贝 10.8 的 Xcode SDK、改 build/core/combo/mac_version.mk ，我试了一早上各种版本，没成  有些民间教程表示自己啥也没改，10.10 10.11 SDK 完美运行没有问题，我也是没成  重点来了，这个答案 有理有据，他直接用旧版本的 Xcode，具体操作是下个旧版的 DMG（链接可能无效，自己上苹果的开发者页面找一下即可） 然后挂载上来，路径是 /Volumes/Xcode/（懒得安装到本地），最后在 shell 中选择这个作为当前 Xcode 的版本 sudo xcode-select -s /Volumes/Xcode/Xcode.app/Contents/Developer目测一切奇怪的环境问题都可以用这个终极办法修复。最后的最后，终于是编译啦：$ make clobber$ source build/envsetup.sh$ lunch aosp_arm-eng              $ make -j4                               需要注意的是：  lunch 要选对应机型和权限类型，比如我要编 Nexus 7（flo）的 debug，就是 lunch aosp_flo-userdebug  如果选的不是 ARM 虚拟机类型的编译版本，则需要加入对应机型的特定驱动一起编译，具体可以参考 Google’s Nexus driver page 以及这篇文章的驱动部分说明  make -j 跟的数字有些讲究，其实根据线程池的最高效算法，CPU 密集型的线程池应该是 n + 1 的 pool 大小，由于现在的 Intel CPU 都是超线程的，例如我用的 15 寸 Mac 是 4 核 8 线程，所以就是 make -j9烧录Running Build 这章没多少内容，也就一个命令有点坑：fastboot flashall -w。直接运行会抛错：error: neither -p product specified nor ANDROID_PRODUCT_OUT set。需要设置一下 img 的目录，按照提示 export ANDROID_BUILD_OUT=\"path/to/your/img/folder\" 设置即可 （-p 参数用了没成功…大概姿势有问题）OK，终于 Run 起来了。后续可以做进一步的调试了。参考链接  Downloading and Building - Android Source  Build and Run Android from AOSP Source Code to a Nexus 7欢迎关注我的公众号和微博。",
            "content_html": "<p>由于最近工作需要 + 自己也挺感兴趣，折腾起 Android 的下层开发。</p><h2 id=\"环境描述\">环境描述：</h2><ul>  <li>macOS 10.12 Sierra</li>  <li>Xcode 8（安装各种环境会用到，然而正式编译时没用这个）</li>  <li>android-5.1.1_r14，LMY48M，Nexus 7（flo）</li></ul><!--more--><h2 id=\"素材准备\">素材准备</h2><p>上 Google 爸爸的 <a href=\"http://source.android.com/source/initializing.html\">Android Source</a> ，按 <code class=\"language-plaintext highlighter-rouge\">Establishing a Build Environment</code> 和 <code class=\"language-plaintext highlighter-rouge\">Downloading the Source</code> 做完即可，只有小坑如下：</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">Creating a case-sensitive disk image</code> 时，不要用 Disk Utility 的 GUI 界面创建，大概因为版本更新了，找不到创建稀疏磁盘的选项，并且大小写那项我选了两回都没生效（？？？），<strong>请按它后续的提示直接用 shell 操作</strong>；</li>  <li><code class=\"language-plaintext highlighter-rouge\">Reverting from make 3.82</code> 这段，看清楚其实只有在 4.0.x 及以下系统才需要做，现在一般不会去编这个版本了<strong>可以忽略</strong>；</li>  <li><code class=\"language-plaintext highlighter-rouge\">Initializing a Repo client</code> 就是下源码啦，可以使用<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\">清华大学的 AOSP 镜像</a>，比较不会碰到下载的各种问题（不过我是公司网，直连速度喜人 4M/s）。</li></ul><h2 id=\"编译\">编译</h2><p>按着 Android Source 的步骤，现在终于要 <code class=\"language-plaintext highlighter-rouge\">Preparing to Build</code> 啦，注意到其实还有个页面可能没看仔细——<a href=\"https://source.android.com/source/requirements.html\">Requirements</a>，这里有坑的：</p><blockquote>  <p><strong>Mac OS (Intel/x86)</strong></p>  <ul>    <li>Android 6.0 (Marshmallow) - AOSP master: Mac OS v10.10 (Yosemite) or later with Xcode 4.5.2 and Command Line Tools</li>    <li>      <p>Android 5.x (Lollipop): Mac OS v10.8 (Mountain Lion) with Xcode 4.5.2 and Command Line Tools</p>    </li>    <li>      <p>Android 4.1.x-4.3.x (Jelly Bean) - Android 4.4.x (KitKat): Mac OS v10.6 (Snow Leopard) or Mac OS X v10.7 (Lion) and Xcode 4.2 (Apple’s Developer Tools)</p>    </li>    <li>Android 1.5 (Cupcake) - Android 4.0.x (Ice Cream Sandwich): Mac OS v10.5 (Leopard) or Mac OS X v10.6 (Snow Leopard) and the Mac OS X v10.5 SDK</li>  </ul></blockquote><p>按这个表，Google 其实推荐 5.x 6.0 使用 4.5.2 的 Xcode 及其 SDK 来编译，然而现代 macOS 早已不支持这些老东西了：</p><ul>  <li>StackOverflow 上各种教你拷贝 10.8 的 Xcode SDK、改 <code class=\"language-plaintext highlighter-rouge\">build/core/combo/mac_version.mk</code> ，我试了一早上各种版本，没成</li>  <li>有些民间教程表示自己啥也没改，10.10 10.11 SDK 完美运行没有问题，我也是没成</li>  <li><strong>重点来了</strong>，<a href=\"http://stackoverflow.com/questions/31589866/running-aosp-build-on-mac-yosemite-and-later/36709862#36709862\">这个答案</a> 有理有据，他直接用旧版本的 Xcode，具体操作是下个旧版的 DMG（链接可能无效，自己上苹果的开发者页面找一下即可） 然后挂载上来，路径是 /Volumes/Xcode/（懒得安装到本地），最后在 shell 中选择这个作为当前 Xcode 的版本 <code class=\"language-plaintext highlighter-rouge\">sudo xcode-select -s /Volumes/Xcode/Xcode.app/Contents/Developer</code></li></ul><p>目测一切奇怪的环境问题都可以用这个终极办法修复。</p><p>最后的最后，终于是编译啦：</p><div class=\"language-shell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span>make clobber<span class=\"nv\">$ </span><span class=\"nb\">source </span>build/envsetup.sh<span class=\"nv\">$ </span>lunch aosp_arm-eng              <span class=\"nv\">$ </span>make <span class=\"nt\">-j4</span>                               </code></pre></div></div><p>需要注意的是：</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">lunch</code> 要选对应机型和权限类型，比如我要编 Nexus 7（flo）的 debug，就是 <code class=\"language-plaintext highlighter-rouge\">lunch aosp_flo-userdebug</code></li>  <li>如果选的不是 ARM 虚拟机类型的编译版本，则需要加入对应机型的特定驱动一起编译，具体可以参考 <a href=\"https://developers.google.com/android/drivers\">Google’s Nexus driver page</a> 以及这篇文章的<a href=\"http://www.jianshu.com/p/1c3d47b2031f\">驱动部分说明</a></li>  <li><code class=\"language-plaintext highlighter-rouge\">make -j</code> 跟的数字有些讲究，其实根据线程池的最高效算法，CPU 密集型的线程池应该是 n + 1 的 pool 大小，由于现在的 Intel CPU 都是超线程的，例如我用的 15 寸 Mac 是 4 核 8 线程，所以就是 <code class=\"language-plaintext highlighter-rouge\">make -j9</code></li></ul><h2 id=\"烧录\">烧录</h2><p><code class=\"language-plaintext highlighter-rouge\">Running Build</code> 这章没多少内容，也就一个命令有点坑：<code class=\"language-plaintext highlighter-rouge\">fastboot flashall -w</code>。直接运行会抛错：<code class=\"language-plaintext highlighter-rouge\">error: neither -p product specified nor ANDROID_PRODUCT_OUT set</code>。需要设置一下 img 的目录，按照提示 <code class=\"language-plaintext highlighter-rouge\">export ANDROID_BUILD_OUT=\"path/to/your/img/folder\"</code> 设置即可 （-p 参数用了没成功…大概姿势有问题）</p><p>OK，终于 Run 起来了。后续可以做进一步的调试了。</p><h2 id=\"参考链接\">参考链接</h2><ol>  <li><a href=\"http://source.android.com/source/\">Downloading and Building - Android Source</a></li>  <li><a href=\"https://stanfy.com/blog/build-and-run-android-from-aosp-source-code-to-a-nexus-7/\">Build and Run Android from AOSP Source Code to a Nexus 7</a></li></ol><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/03/10/android-source-development-notes-1",
            
            
            
            "tags": ["Android","Framework","源码"],
            
            "date_published": "2017-03-10T00:00:00+00:00",
            "date_modified": "2017-03-10T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2017/03/08/plugadget-note-6-start-plugin-service",
            "title": "插件化笔记 #6 启动插件 Service",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes上节学习到了插件化资源 ID 冲突的问题和解法，本节主要讨论 Service 的插件化启动。按照本系列的尿性，肯定要简单易搞，所以预注册 Service 是本节的讨论前提。具体原因在 Activity 那节写了，但是需要额外说明的是其实 Service 由于量少且新增少，是比较少做复杂插件化方案的。Service 的启动流程推荐看这篇 startService启动过程分析：其实由于我们提前注册了 Service，没有了各种校验问题，所以只需要跟 Activity 一样注入 ClassLoader 去加载对应的模块代码就可以启动 Service。但是 Service 并没有像 Activity 那样方便的切入点（Instrumention）：[ActivityThread.java]private void handleCreateService(CreateServiceData data) {    // If we are getting ready to gc after going to the background, well    // we are back active so skip it.    unscheduleGcIdler();    LoadedApk packageInfo = getPackageInfoNoCheck(                data.info.applicationInfo, data.compatInfo);    Service service = null;    try {        java.lang.ClassLoader cl = packageInfo.getClassLoader();        service = (Service) cl.loadClass(data.info.name).newInstance();    } catch (Exception e) {        if (!mInstrumentation.onException(service, e)) {            throw new RuntimeException(\"Unable to instantiate service \" + data.info.name + \": \" + e.toString(), e);        }    }    ...}public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai, CompatibilityInfo compatInfo) {    return getPackageInfo(ai, compatInfo, null, false, true, false);}private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,         ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) {    final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));    synchronized (mResourcesManager) {        WeakReference&lt;LoadedApk&gt; ref;        if (differentUser) {            // Caching not supported across users            ref = null;        } else if (includeCode) {            ref = mPackages.get(aInfo.packageName);        } else {            ref = mResourcePackages.get(aInfo.packageName);        }                LoadedApk packageInfo = ref != null ? ref.get() : null;        if (packageInfo == null || (packageInfo.mResources != null &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) {            if (localLOGV) Slog.v(TAG, (includeCode ? \"Loading code package \"                        : \"Loading resource-only package \") + aInfo.packageName                        + \" (in \" + (mBoundApplication != null                                ? mBoundApplication.processName : null)                        + \")\");            packageInfo =                    new LoadedApk(this, aInfo, compatInfo, baseLoader,                            securityViolation, includeCode &amp;&amp;                            (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);            if (mSystemThread &amp;&amp; \"android\".equals(aInfo.packageName)) {                    packageInfo.installSystemApplicationInfo(aInfo,                            getSystemContext().mPackageInfo.getClassLoader());            }            if (differentUser) {                // Caching not supported across users            } else if (includeCode) {                mPackages.put(aInfo.packageName,                        new WeakReference&lt;LoadedApk&gt;(packageInfo));            } else {                mResourcePackages.put(aInfo.packageName,                        new WeakReference&lt;LoadedApk&gt;(packageInfo));            }        }        return packageInfo;    }}既然没有直接有效的切入点，那么其他的插件化方案都是怎么做的？除了文初 weishu 的那个高级方法以外，还有一种比较实在并且通吃的解法。动态插入 Element - Dex 动态性的通解Dex 动态载入的原理其实是从 Google MultiDex 方案出来后大家才敢投入研究和使用的，具体参考Android分包原理这篇文章。在了解了有这样的方案之后，很多人纷纷表示这可以用来做插件化和热修复，类似的博客有大头鬼的Android热更新实现原理。看完这两篇之后，其实应该了解的差不多了。本质上这种 Dex 载入的方案就是把代码载入到自定义的 ClassLoader 中，跟之前写的 Activity Hook 方案异曲同工。只不过这是一种比较彻底、方便，一次性解决了所有需要注入 ClassLoader 的地方。不仅可以用来启动 Service，也可以用来启动 Activity（当然前提是你预注册了）。具体代码 Demo 请参考文初的链接。Demo Usage  在插件工程 ./gradlew assembleDebug 打出插件  导入插件到手机指定目录（这个目录是自己随便指定的，跟 Demo 代码里的加载路径一致即可）：mv app/build/outputs/apk/app-debug.apk app/build/outputs/apk/6-Plugin.apk &amp;&amp; adb push app/build/outputs/apk/6-Plugin.apk /system/dex/  在宿主工程 ./gradlew installDebug 打包并安装宿主 APK  打开宿主 App，查看效果  参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，本文参考资料均已在文中给出链接。欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><p>上节学习到了插件化资源 ID 冲突的问题和解法，本节主要讨论 Service 的插件化启动。按照本系列的尿性，肯定要简单易搞，所以预注册 Service 是本节的讨论前提。具体原因在 Activity 那节写了，但是需要额外说明的是其实 Service 由于量少且新增少，是比较少做<a href=\"http://weishu.me/2016/05/11/understand-plugin-framework-service/\">复杂插件化</a>方案的。</p><!--more--><h2 id=\"service-的启动流程\">Service 的启动流程</h2><p>推荐看这篇 <a href=\"http://gityuan.com/2016/03/06/start-service/\">startService启动过程分析</a>：</p><p><img src=\"http://2bab-images.lastmayday.com/blog/2017-03-08-start-plugin-service-1.jpeg?imageslim\" alt=\"\" /></p><p><img src=\"http://2bab-images.lastmayday.com/blog/2017-03-08-start-plugin-service-2.jpeg?imageslim\" alt=\"\" /></p><p>其实由于我们提前注册了 Service，没有了各种校验问题，所以只需要跟 Activity 一样注入 ClassLoader 去加载对应的模块代码就可以启动 Service。但是 Service 并没有像 Activity 那样方便的切入点（Instrumention）：</p><p>[ActivityThread.java]</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">handleCreateService</span><span class=\"o\">(</span><span class=\"nc\">CreateServiceData</span> <span class=\"n\">data</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// If we are getting ready to gc after going to the background, well</span>    <span class=\"c1\">// we are back active so skip it.</span>    <span class=\"n\">unscheduleGcIdler</span><span class=\"o\">();</span>    <span class=\"nc\">LoadedApk</span> <span class=\"n\">packageInfo</span> <span class=\"o\">=</span> <span class=\"n\">getPackageInfoNoCheck</span><span class=\"o\">(</span>                <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">.</span><span class=\"na\">applicationInfo</span><span class=\"o\">,</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">compatInfo</span><span class=\"o\">);</span>    <span class=\"nc\">Service</span> <span class=\"n\">service</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>    <span class=\"k\">try</span> <span class=\"o\">{</span>        <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ClassLoader</span> <span class=\"n\">cl</span> <span class=\"o\">=</span> <span class=\"n\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">getClassLoader</span><span class=\"o\">();</span>        <span class=\"n\">service</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">Service</span><span class=\"o\">)</span> <span class=\"n\">cl</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">.</span><span class=\"na\">name</span><span class=\"o\">).</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">mInstrumentation</span><span class=\"o\">.</span><span class=\"na\">onException</span><span class=\"o\">(</span><span class=\"n\">service</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"o\">{</span>            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">RuntimeException</span><span class=\"o\">(</span><span class=\"s\">\"Unable to instantiate service \"</span> <span class=\"o\">+</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">info</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">+</span> <span class=\"s\">\": \"</span> <span class=\"o\">+</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(),</span> <span class=\"n\">e</span><span class=\"o\">);</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"o\">...</span><span class=\"o\">}</span><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"nc\">LoadedApk</span> <span class=\"nf\">getPackageInfoNoCheck</span><span class=\"o\">(</span><span class=\"nc\">ApplicationInfo</span> <span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"nc\">CompatibilityInfo</span> <span class=\"n\">compatInfo</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">return</span> <span class=\"nf\">getPackageInfo</span><span class=\"o\">(</span><span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">compatInfo</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span><span class=\"o\">}</span><span class=\"kd\">private</span> <span class=\"nc\">LoadedApk</span> <span class=\"nf\">getPackageInfo</span><span class=\"o\">(</span><span class=\"nc\">ApplicationInfo</span> <span class=\"n\">aInfo</span><span class=\"o\">,</span> <span class=\"nc\">CompatibilityInfo</span> <span class=\"n\">compatInfo</span><span class=\"o\">,</span>         <span class=\"nc\">ClassLoader</span> <span class=\"n\">baseLoader</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">securityViolation</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">includeCode</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">registerPackage</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"n\">differentUser</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">UserHandle</span><span class=\"o\">.</span><span class=\"na\">myUserId</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"nc\">UserHandle</span><span class=\"o\">.</span><span class=\"na\">getUserId</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">uid</span><span class=\"o\">));</span>    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">mResourcesManager</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">LoadedApk</span><span class=\"o\">&gt;</span> <span class=\"n\">ref</span><span class=\"o\">;</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">differentUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"c1\">// Caching not supported across users</span>            <span class=\"n\">ref</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">includeCode</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">ref</span> <span class=\"o\">=</span> <span class=\"n\">mPackages</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span><span class=\"o\">);</span>        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>            <span class=\"n\">ref</span> <span class=\"o\">=</span> <span class=\"n\">mResourcePackages</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span><span class=\"o\">);</span>        <span class=\"o\">}</span>                <span class=\"nc\">LoadedApk</span> <span class=\"n\">packageInfo</span> <span class=\"o\">=</span> <span class=\"n\">ref</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">ref</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"kc\">null</span><span class=\"o\">;</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">packageInfo</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">mResources</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">mResources</span><span class=\"o\">.</span><span class=\"na\">getAssets</span><span class=\"o\">().</span><span class=\"na\">isUpToDate</span><span class=\"o\">()))</span> <span class=\"o\">{</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">localLOGV</span><span class=\"o\">)</span> <span class=\"nc\">Slog</span><span class=\"o\">.</span><span class=\"na\">v</span><span class=\"o\">(</span><span class=\"no\">TAG</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">includeCode</span> <span class=\"o\">?</span> <span class=\"s\">\"Loading code package \"</span>                        <span class=\"o\">:</span> <span class=\"s\">\"Loading resource-only package \"</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span>                        <span class=\"o\">+</span> <span class=\"s\">\" (in \"</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">mBoundApplication</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>                                <span class=\"o\">?</span> <span class=\"n\">mBoundApplication</span><span class=\"o\">.</span><span class=\"na\">processName</span> <span class=\"o\">:</span> <span class=\"kc\">null</span><span class=\"o\">)</span>                        <span class=\"o\">+</span> <span class=\"s\">\")\"</span><span class=\"o\">);</span>            <span class=\"n\">packageInfo</span> <span class=\"o\">=</span>                    <span class=\"k\">new</span> <span class=\"nf\">LoadedApk</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">aInfo</span><span class=\"o\">,</span> <span class=\"n\">compatInfo</span><span class=\"o\">,</span> <span class=\"n\">baseLoader</span><span class=\"o\">,</span>                            <span class=\"n\">securityViolation</span><span class=\"o\">,</span> <span class=\"n\">includeCode</span> <span class=\"o\">&amp;&amp;</span>                            <span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">flags</span><span class=\"o\">&amp;</span><span class=\"nc\">ApplicationInfo</span><span class=\"o\">.</span><span class=\"na\">FLAG_HAS_CODE</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">registerPackage</span><span class=\"o\">);</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mSystemThread</span> <span class=\"o\">&amp;&amp;</span> <span class=\"s\">\"android\"</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span><span class=\"o\">))</span> <span class=\"o\">{</span>                    <span class=\"n\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">installSystemApplicationInfo</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">,</span>                            <span class=\"n\">getSystemContext</span><span class=\"o\">().</span><span class=\"na\">mPackageInfo</span><span class=\"o\">.</span><span class=\"na\">getClassLoader</span><span class=\"o\">());</span>            <span class=\"o\">}</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">differentUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"c1\">// Caching not supported across users</span>            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">includeCode</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">mPackages</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span><span class=\"o\">,</span>                        <span class=\"k\">new</span> <span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">LoadedApk</span><span class=\"o\">&gt;(</span><span class=\"n\">packageInfo</span><span class=\"o\">));</span>            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>                <span class=\"n\">mResourcePackages</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">aInfo</span><span class=\"o\">.</span><span class=\"na\">packageName</span><span class=\"o\">,</span>                        <span class=\"k\">new</span> <span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">LoadedApk</span><span class=\"o\">&gt;(</span><span class=\"n\">packageInfo</span><span class=\"o\">));</span>            <span class=\"o\">}</span>        <span class=\"o\">}</span>        <span class=\"k\">return</span> <span class=\"n\">packageInfo</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>既然没有直接有效的切入点，那么其他的插件化方案都是怎么做的？除了文初 weishu 的那个高级方法以外，还有一种比较实在并且通吃的解法。</p><h2 id=\"动态插入-element---dex-动态性的通解\">动态插入 Element - Dex 动态性的通解</h2><p>Dex 动态载入的原理其实是从 Google MultiDex 方案出来后大家才敢投入研究和使用的，具体参考<a href=\"http://souly.cn/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/02/25/android%E5%88%86%E5%8C%85%E5%8E%9F%E7%90%86/\">Android分包原理</a>这篇文章。</p><p>在了解了有这样的方案之后，很多人纷纷表示这可以用来做插件化和热修复，类似的博客有大头鬼的<a href=\"http://blog.csdn.net/lzyzsd/article/details/49843581\">Android热更新实现原理</a>。</p><p>看完这两篇之后，其实应该了解的差不多了。<strong>本质上这种 Dex 载入的方案就是把代码载入到自定义的 ClassLoader 中，跟之前写的 Activity Hook 方案异曲同工。只不过这是一种比较彻底、方便，一次性解决了所有需要注入 ClassLoader 的地方。不仅可以用来启动 Service，也可以用来启动 Activity（当然前提是你预注册了）。</strong></p><p>具体代码 Demo 请参考文初的链接。</p><h2 id=\"demo-usage\">Demo Usage</h2><ol>  <li>在插件工程 <code class=\"language-plaintext highlighter-rouge\">./gradlew assembleDebug</code> 打出插件</li>  <li>导入插件到手机指定目录（这个目录是自己随便指定的，跟 Demo 代码里的加载路径一致即可）：<code class=\"language-plaintext highlighter-rouge\">mv app/build/outputs/apk/app-debug.apk app/build/outputs/apk/6-Plugin.apk &amp;&amp; adb push app/build/outputs/apk/6-Plugin.apk /system/dex/</code></li>  <li>在宿主工程 <code class=\"language-plaintext highlighter-rouge\">./gradlew installDebug</code> 打包并安装宿主 APK</li>  <li>打开宿主 App，查看效果</li>  <li><img src=\"http://2bab-images.lastmayday.com/blog/2017-03-08-start-plugin-service-3.png?imageslim\" alt=\"\" /></li></ol><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，本文参考资料均已在文中给出链接。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2017/03/08/plugadget-note-6-start-plugin-service",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2017-03-08T00:00:00+00:00",
            "date_modified": "2017-03-08T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2016/12/01/plugadget-note-5-resmodificationplugin",
            "title": "插件化笔记 #5 资源分区修改插件",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes上节学习到「各插件构造各自的 Resource 对象，各个插件的资源互不影响」，本节使用另外一种方案——「所有插件的资源都加载到一个 AssetManager，全局可用」。单一 Resource（AssetManager）的方案，主要问题在于资源 ID 冲突，解决的方案大体上分三种：  修改 AAPT 的源码  修改 AAPT 的生成产物（R.java，resource.arsc，各类 xml 包括 layout）  使用 public.xml 手动设置 padding其中方案 1 出现的较早，原理也比较简单，修改的部分不多，携程的 DynamicApk 等开源项目都在使用。而方案 2 则鲜为人知，但是 Small 项目给我们做了一个完整的实例，本节的 Gradle 插件就是基于 Small 的源码「抽离 + 修改」而来。方案 3 不涉及到打包流程改动，在此不做阐释。资源的打包过程这里引用罗老师的一篇博文：  一. 解析AndroidManifest.xml  二. 添加被引用资源包  三. 收集资源文件  四. 将收集到的资源增加到资源表  五. 编译values类资源  六. 给Bag资源分配ID  七. 编译Xml资源文件  八. 生成资源符号  九. 生成资源索引表  十. 编译AndroidManifest.xml文件  十一. 生成R.java文件  十二. 打包APK文件显然，我们的插入点应该是 11-12 步中间（这废话啊），然后我们来看一个 Apk 打包过程中，Gradle 的哪个任务对应了这个插入点（注意，这里以 Debug 打包为例）：  :app:preBuild UP-TO-DATE  :app:preDebugBuild UP-TO-DATE  :app:checkDebugManifest  :app:preReleaseBuild UP-TO-DATE  …  :app:prepareDebugDependencies  :app:compileDebugAidl UP-TO-DATE  :app:compileDebugRenderscript UP-TO-DATE  :app:generateDebugBuildConfig UP-TO-DATE  :app:generateDebugResValues UP-TO-DATE  :app:generateDebugResources UP-TO-DATE  :app:mergeDebugResources UP-TO-DATE  :app:processDebugManifest UP-TO-DATE  :app:processDebugResources UP-TO-DATE  ////////上面是 Resource 处理 ////////////这里就是分割点////////////////下面是 Java Source 处理/////////  :app:generateDebugSources UP-TO-DATE  :app:incrementalDebugJavaCompilationSafeguard UP-TO-DATE  :app:compileDebugJavaWithJavacIncremental compilation of 2 classes completed in 0.737 secs.  :app:compileDebugNdk UP-TO-DATE  …  :app:transformResourcesWithMergeJavaResForDebug UP-TO-DATE  :app:validateSigningDebug  :app:packageDebug  :app:assembleDebug可以看到 Resource 的处理和 Java 文件的处理有一个比较明晰的分割处，所以我们就在这个地方修改 AAPT 的生成物。Hook插件打包依赖于我们的打包插件：// project's  build.gradleclasspath 'com.example.gradle:res-modification-plugin:1.0.1-SNAPSHOT'// app's build.gradleapply plugin: 'res-modification'Gradle 插件需要注入的点：@Overridevoid apply(Project project) {    this.project = project    project.afterEvaluate {        def processDebugResources = (ProcessAndroidResources) project.tasks['processDebugResources']        // 阿咏（https://github.com/lomanyong）的提示，防止 processDebugResources 因为 Up-To-Data 而跳过        processDebugResources.outputs.upToDateWhen { false }        // 注入点        processDebugResources.doLast { ProcessAndroidResources i -&gt;            println \"inject point!\"            hookAapt(i)        }    }}实现资源分区的的大致流程（详情请查看源码）：private def hookAapt(ProcessAndroidResources aaptTask) {    // Unpack resources.ap_    File apFile = aaptTask.packageOutputFile    FileTree apFiles = project.zipTree(apFile)    File unzipApDir = new File(apFile.parentFile, 'ap_unzip')    unzipApDir.delete()    project.copy {        from apFiles        into unzipApDir        include 'AndroidManifest.xml'        include 'resources.arsc'        include 'res/**/*'    }    // Modify assets    File symbolFile = new File(aaptTask.textSymbolOutputDir, 'R.txt')    prepareSplit(symbolFile)    File sourceOutputDir = aaptTask.sourceOutputDir    File rJavaFile = new File(sourceOutputDir, \"com/example/plugin5/R.java\")    def rev = project.android.buildToolsRevision    int noResourcesFlag = 0    def filteredResources = new HashSet()    def updatedResources = new HashSet()    Aapt aapt = new Aapt(unzipApDir, rJavaFile, symbolFile, rev)    if (this.retainedTypes != null &amp;&amp; this.retainedTypes.size() &gt; 0) {        aapt.filterResources(this.retainedTypes, filteredResources)        println \"[${project.name}] split library res files...\"        aapt.filterPackage(this.retainedTypes, this.packageId, this.idMaps, null,                this.retainedStyleables, updatedResources)        println \"[${project.name}] slice asset package and reset package id...\"        String pkg = \"com.example.plugin5\"        // Overwrite the aapt-generated R.java with full edition        rJavaFile.delete()        aapt.generateRJava(rJavaFile, pkg, this.allTypes, this.allStyleables)        println \"[${project.name}] split library R.java files...\"    } else {        println 'No Resource To Modify'    }    String aaptExe = aaptTask.buildTools.getPath(BuildToolInfo.PathId.AAPT)    // Delete filtered entries.    // Cause there is no `aapt update' command supported, so for the updated resources    // we also delete first and run `aapt add' later.    filteredResources.addAll(updatedResources)    ZipUtils.with(apFile).deleteAll(filteredResources)    // Re-add updated entries.    // $ aapt add resources.ap_ file1 file2 ...    project.exec {        executable aaptExe        workingDir unzipApDir        args 'add', apFile.path        args updatedResources        // store the output instead of printing to the console        // standardOutput = new ByteArrayOutputStream()    }}这样，我们就可以在 Plugin 的 Activity 里实现「宿主+插件」的资源加载：public class MainActivity extends Activity {    private Resources allResources;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // 使用插件的资源        setContentView(R.layout.plugin_activity_main);        TextView testTv = (TextView) findViewById(R.id.test_textview);        // 使用宿主的资源        String hostName = getResources().getString(                getResources().getIdentifier(\"host_name\", \"string\", \"com.example.resmodification\"));        int hostNameColor = getResources().getColor(                getResources().getIdentifier(\"host_name_color\", \"color\", \"com.example.resmodification\"));        testTv.setText(hostName);        testTv.setTextColor(hostNameColor);    }    @Override    protected void attachBaseContext(Context newBase) {        hookResource(newBase);        super.attachBaseContext(newBase);    }    /**     * 宿主和插件的资源放在了一个 Resource 对象里，因为我们在打包时做了资源PP段分区，所以不会出现资源冲突的现象。     * 不过目前只是在该 Activity 把我们构建的 Resource 对象 Set 进去了，所以也只能在当前 Context 的环境里同时     * 访问到两个包的资源（我们仅做简单的测试）。一个成熟的插件化架构应该是把所有 Context 初始化的注入都做好（有多     * 种实现手段）。     */    public Resources getPluginR(Context context) {        if (allResources != null) {            return allResources;        }        try {            String dexPath = \"/system/dex/\" + \"5-Plugin.apk\";            AssetManager assetManager = AssetManager.class.newInstance();            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPaths\", new Class[]{String[].class});            String[] paths = new String[2];            paths[0] = dexPath; // 插件 Asset            paths[1] = context.getPackageResourcePath(); // 宿主的 Asset            addAssetPath.invoke(assetManager, new Object[]{paths});            allResources = new Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());            return allResources;        } catch (Exception e) {            e.printStackTrace();            return null;        }    }    private void hookResource(Context newBase) {        try {            Field field = newBase.getClass().getDeclaredField(\"mResources\");            field.setAccessible(true);            field.set(newBase, getPluginR(newBase));        } catch (Exception e) {            e.printStackTrace();        }    }}Demo Usage  在 Gradle 插件工程执行 ./gradlew publishToMavenLocal，使得 Gradle 插件可以被我们的 插件 App 工程找到并依赖  在插件工程 ./gradlew assembleDebug 打出插件  导入插件到手机指定目录（这个目录是自己随便指定的，跟 Demo 代码里的加载路径一致即可）：mv app-debug.apk 5-Plugin.apk &amp;&amp; adb push 5-Plugin.apk /system/dex/  在宿主工程 ./gradlew installDebug 打包并安装宿主 APK  打开宿主 App，查看效果参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  Android应用程序资源的编译和打包过程分析  插件化-资源处理  Small欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><p>上节学习到「各插件构造各自的 <code class=\"language-plaintext highlighter-rouge\">Resource</code> 对象，各个插件的资源互不影响」，本节使用另外一种方案——「所有插件的资源都加载到一个 <code class=\"language-plaintext highlighter-rouge\">AssetManager</code>，全局可用」。</p><p>单一 Resource（AssetManager）的方案，主要问题在于资源 ID 冲突，解决的方案大体上分三种：</p><ol>  <li>修改 AAPT 的源码</li>  <li>修改 AAPT 的生成产物（R.java，resource.arsc，各类 xml 包括 layout）</li>  <li>使用 public.xml 手动设置 padding</li></ol><p>其中方案 1 出现的较早，原理也比较简单，修改的部分不多，携程的 <a href=\"https://github.com/CtripMobile/DynamicAPK/tree/master/caapt\">DynamicApk</a> 等开源项目都在使用。而方案 2 则鲜为人知，但是 <a href=\"https://github.com/wequick/Small\">Small</a> 项目给我们做了一个完整的实例，<strong>本节的 Gradle 插件就是基于 Small 的源码「抽离 + 修改」而来</strong>。方案 3 不涉及到打包流程改动，在此不做阐释。</p><!--more--><h2 id=\"资源的打包过程\">资源的打包过程</h2><p>这里引用罗老师的一篇博文：</p><blockquote>  <p>一. 解析AndroidManifest.xml</p>  <p>二. 添加被引用资源包</p>  <p>三. 收集资源文件</p>  <p>四. 将收集到的资源增加到资源表</p>  <p>五. 编译values类资源</p>  <p>六. 给Bag资源分配ID</p>  <p>七. 编译Xml资源文件</p>  <p>八. 生成资源符号</p>  <p>九. 生成资源索引表</p>  <p>十. 编译AndroidManifest.xml文件</p>  <p>十一. 生成R.java文件</p>  <p>十二. 打包APK文件</p></blockquote><p>显然，我们的插入点应该是 11-12 步中间（这废话啊），然后我们来看一个 Apk 打包过程中，Gradle 的哪个任务对应了这个插入点（注意，这里以 Debug 打包为例）：</p><blockquote>  <p>:app:preBuild UP-TO-DATE</p>  <p>:app:preDebugBuild UP-TO-DATE</p>  <p>:app:checkDebugManifest</p>  <p>:app:preReleaseBuild UP-TO-DATE</p>  <p>…</p>  <p>:app:prepareDebugDependencies</p>  <p>:app:compileDebugAidl UP-TO-DATE</p>  <p>:app:compileDebugRenderscript UP-TO-DATE</p>  <p>:app:generateDebugBuildConfig UP-TO-DATE</p>  <p>:app:generateDebugResValues UP-TO-DATE</p>  <p>:app:generateDebugResources UP-TO-DATE</p>  <p>:app:mergeDebugResources UP-TO-DATE</p>  <p>:app:processDebugManifest UP-TO-DATE</p>  <p>:app:processDebugResources UP-TO-DATE</p>  <p>////////上面是 Resource 处理 ////////////这里就是分割点////////////////下面是 Java Source 处理/////////</p>  <p>:app:generateDebugSources UP-TO-DATE</p>  <p>:app:incrementalDebugJavaCompilationSafeguard UP-TO-DATE</p>  <p>:app:compileDebugJavaWithJavacIncremental compilation of 2 classes completed in 0.737 secs.</p>  <p>:app:compileDebugNdk UP-TO-DATE</p>  <p>…</p>  <p>:app:transformResourcesWithMergeJavaResForDebug UP-TO-DATE</p>  <p>:app:validateSigningDebug</p>  <p>:app:packageDebug</p>  <p>:app:assembleDebug</p></blockquote><p>可以看到 Resource 的处理和 Java 文件的处理有一个比较明晰的分割处，所以我们就在这个地方修改 AAPT 的生成物。</p><h2 id=\"hook\">Hook</h2><p>插件打包依赖于我们的打包插件：</p><div class=\"language-gradle highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// project's  build.gradle</span><span class=\"n\">classpath</span> <span class=\"s1\">'com.example.gradle:res-modification-plugin:1.0.1-SNAPSHOT'</span><span class=\"c1\">// app's build.gradle</span><span class=\"n\">apply</span> <span class=\"nl\">plugin:</span> <span class=\"s1\">'res-modification'</span></code></pre></div></div><p>Gradle 插件需要注入的点：</p><div class=\"language-groovy highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Override</span><span class=\"kt\">void</span> <span class=\"nf\">apply</span><span class=\"o\">(</span><span class=\"n\">Project</span> <span class=\"n\">project</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">project</span> <span class=\"o\">=</span> <span class=\"n\">project</span>    <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">afterEvaluate</span> <span class=\"o\">{</span>        <span class=\"kt\">def</span> <span class=\"n\">processDebugResources</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">ProcessAndroidResources</span><span class=\"o\">)</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">tasks</span><span class=\"o\">[</span><span class=\"s1\">'processDebugResources'</span><span class=\"o\">]</span>        <span class=\"c1\">// 阿咏（https://github.com/lomanyong）的提示，防止 processDebugResources 因为 Up-To-Data 而跳过</span>        <span class=\"n\">processDebugResources</span><span class=\"o\">.</span><span class=\"na\">outputs</span><span class=\"o\">.</span><span class=\"na\">upToDateWhen</span> <span class=\"o\">{</span> <span class=\"kc\">false</span> <span class=\"o\">}</span>        <span class=\"c1\">// 注入点</span>        <span class=\"n\">processDebugResources</span><span class=\"o\">.</span><span class=\"na\">doLast</span> <span class=\"o\">{</span> <span class=\"n\">ProcessAndroidResources</span> <span class=\"n\">i</span> <span class=\"o\">-&gt;</span>            <span class=\"n\">println</span> <span class=\"s2\">\"inject point!\"</span>            <span class=\"n\">hookAapt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>实现资源分区的的大致流程（详情请查看源码）：</p><div class=\"language-groovy highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">private</span> <span class=\"kt\">def</span> <span class=\"nf\">hookAapt</span><span class=\"o\">(</span><span class=\"n\">ProcessAndroidResources</span> <span class=\"n\">aaptTask</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// Unpack resources.ap_</span>    <span class=\"n\">File</span> <span class=\"n\">apFile</span> <span class=\"o\">=</span> <span class=\"n\">aaptTask</span><span class=\"o\">.</span><span class=\"na\">packageOutputFile</span>    <span class=\"n\">FileTree</span> <span class=\"n\">apFiles</span> <span class=\"o\">=</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">zipTree</span><span class=\"o\">(</span><span class=\"n\">apFile</span><span class=\"o\">)</span>    <span class=\"n\">File</span> <span class=\"n\">unzipApDir</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"n\">apFile</span><span class=\"o\">.</span><span class=\"na\">parentFile</span><span class=\"o\">,</span> <span class=\"s1\">'ap_unzip'</span><span class=\"o\">)</span>    <span class=\"n\">unzipApDir</span><span class=\"o\">.</span><span class=\"na\">delete</span><span class=\"o\">()</span>    <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">copy</span> <span class=\"o\">{</span>        <span class=\"n\">from</span> <span class=\"n\">apFiles</span>        <span class=\"n\">into</span> <span class=\"n\">unzipApDir</span>        <span class=\"n\">include</span> <span class=\"s1\">'AndroidManifest.xml'</span>        <span class=\"n\">include</span> <span class=\"s1\">'resources.arsc'</span>        <span class=\"n\">include</span> <span class=\"s1\">'res/**/*'</span>    <span class=\"o\">}</span>    <span class=\"c1\">// Modify assets</span>    <span class=\"n\">File</span> <span class=\"n\">symbolFile</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"n\">aaptTask</span><span class=\"o\">.</span><span class=\"na\">textSymbolOutputDir</span><span class=\"o\">,</span> <span class=\"s1\">'R.txt'</span><span class=\"o\">)</span>    <span class=\"n\">prepareSplit</span><span class=\"o\">(</span><span class=\"n\">symbolFile</span><span class=\"o\">)</span>    <span class=\"n\">File</span> <span class=\"n\">sourceOutputDir</span> <span class=\"o\">=</span> <span class=\"n\">aaptTask</span><span class=\"o\">.</span><span class=\"na\">sourceOutputDir</span>    <span class=\"n\">File</span> <span class=\"n\">rJavaFile</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"n\">sourceOutputDir</span><span class=\"o\">,</span> <span class=\"s2\">\"com/example/plugin5/R.java\"</span><span class=\"o\">)</span>    <span class=\"kt\">def</span> <span class=\"n\">rev</span> <span class=\"o\">=</span> <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">android</span><span class=\"o\">.</span><span class=\"na\">buildToolsRevision</span>    <span class=\"kt\">int</span> <span class=\"n\">noResourcesFlag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"kt\">def</span> <span class=\"n\">filteredResources</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">()</span>    <span class=\"kt\">def</span> <span class=\"n\">updatedResources</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">()</span>    <span class=\"n\">Aapt</span> <span class=\"n\">aapt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Aapt</span><span class=\"o\">(</span><span class=\"n\">unzipApDir</span><span class=\"o\">,</span> <span class=\"n\">rJavaFile</span><span class=\"o\">,</span> <span class=\"n\">symbolFile</span><span class=\"o\">,</span> <span class=\"n\">rev</span><span class=\"o\">)</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">retainedTypes</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">retainedTypes</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">aapt</span><span class=\"o\">.</span><span class=\"na\">filterResources</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">retainedTypes</span><span class=\"o\">,</span> <span class=\"n\">filteredResources</span><span class=\"o\">)</span>        <span class=\"n\">println</span> <span class=\"s2\">\"[${project.name}] split library res files...\"</span>        <span class=\"n\">aapt</span><span class=\"o\">.</span><span class=\"na\">filterPackage</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">retainedTypes</span><span class=\"o\">,</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">packageId</span><span class=\"o\">,</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">idMaps</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span>                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">retainedStyleables</span><span class=\"o\">,</span> <span class=\"n\">updatedResources</span><span class=\"o\">)</span>        <span class=\"n\">println</span> <span class=\"s2\">\"[${project.name}] slice asset package and reset package id...\"</span>        <span class=\"n\">String</span> <span class=\"n\">pkg</span> <span class=\"o\">=</span> <span class=\"s2\">\"com.example.plugin5\"</span>        <span class=\"c1\">// Overwrite the aapt-generated R.java with full edition</span>        <span class=\"n\">rJavaFile</span><span class=\"o\">.</span><span class=\"na\">delete</span><span class=\"o\">()</span>        <span class=\"n\">aapt</span><span class=\"o\">.</span><span class=\"na\">generateRJava</span><span class=\"o\">(</span><span class=\"n\">rJavaFile</span><span class=\"o\">,</span> <span class=\"n\">pkg</span><span class=\"o\">,</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">allTypes</span><span class=\"o\">,</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">allStyleables</span><span class=\"o\">)</span>        <span class=\"n\">println</span> <span class=\"s2\">\"[${project.name}] split library R.java files...\"</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>        <span class=\"n\">println</span> <span class=\"s1\">'No Resource To Modify'</span>    <span class=\"o\">}</span>    <span class=\"n\">String</span> <span class=\"n\">aaptExe</span> <span class=\"o\">=</span> <span class=\"n\">aaptTask</span><span class=\"o\">.</span><span class=\"na\">buildTools</span><span class=\"o\">.</span><span class=\"na\">getPath</span><span class=\"o\">(</span><span class=\"n\">BuildToolInfo</span><span class=\"o\">.</span><span class=\"na\">PathId</span><span class=\"o\">.</span><span class=\"na\">AAPT</span><span class=\"o\">)</span>    <span class=\"c1\">// Delete filtered entries.</span>    <span class=\"c1\">// Cause there is no `aapt update' command supported, so for the updated resources</span>    <span class=\"c1\">// we also delete first and run `aapt add' later.</span>    <span class=\"n\">filteredResources</span><span class=\"o\">.</span><span class=\"na\">addAll</span><span class=\"o\">(</span><span class=\"n\">updatedResources</span><span class=\"o\">)</span>    <span class=\"n\">ZipUtils</span><span class=\"o\">.</span><span class=\"na\">with</span><span class=\"o\">(</span><span class=\"n\">apFile</span><span class=\"o\">).</span><span class=\"na\">deleteAll</span><span class=\"o\">(</span><span class=\"n\">filteredResources</span><span class=\"o\">)</span>    <span class=\"c1\">// Re-add updated entries.</span>    <span class=\"c1\">// $ aapt add resources.ap_ file1 file2 ...</span>    <span class=\"n\">project</span><span class=\"o\">.</span><span class=\"na\">exec</span> <span class=\"o\">{</span>        <span class=\"n\">executable</span> <span class=\"n\">aaptExe</span>        <span class=\"n\">workingDir</span> <span class=\"n\">unzipApDir</span>        <span class=\"n\">args</span> <span class=\"s1\">'add'</span><span class=\"o\">,</span> <span class=\"n\">apFile</span><span class=\"o\">.</span><span class=\"na\">path</span>        <span class=\"n\">args</span> <span class=\"n\">updatedResources</span>        <span class=\"c1\">// store the output instead of printing to the console</span>        <span class=\"c1\">// standardOutput = new ByteArrayOutputStream()</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>这样，我们就可以在 Plugin 的 Activity 里实现「宿主+插件」的资源加载：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MainActivity</span> <span class=\"kd\">extends</span> <span class=\"nc\">Activity</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"nc\">Resources</span> <span class=\"n\">allResources</span><span class=\"o\">;</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">onCreate</span><span class=\"o\">(</span><span class=\"nc\">Bundle</span> <span class=\"n\">savedInstanceState</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">onCreate</span><span class=\"o\">(</span><span class=\"n\">savedInstanceState</span><span class=\"o\">);</span>        <span class=\"c1\">// 使用插件的资源</span>        <span class=\"n\">setContentView</span><span class=\"o\">(</span><span class=\"no\">R</span><span class=\"o\">.</span><span class=\"na\">layout</span><span class=\"o\">.</span><span class=\"na\">plugin_activity_main</span><span class=\"o\">);</span>        <span class=\"nc\">TextView</span> <span class=\"n\">testTv</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">TextView</span><span class=\"o\">)</span> <span class=\"n\">findViewById</span><span class=\"o\">(</span><span class=\"no\">R</span><span class=\"o\">.</span><span class=\"na\">id</span><span class=\"o\">.</span><span class=\"na\">test_textview</span><span class=\"o\">);</span>        <span class=\"c1\">// 使用宿主的资源</span>        <span class=\"nc\">String</span> <span class=\"n\">hostName</span> <span class=\"o\">=</span> <span class=\"n\">getResources</span><span class=\"o\">().</span><span class=\"na\">getString</span><span class=\"o\">(</span>                <span class=\"n\">getResources</span><span class=\"o\">().</span><span class=\"na\">getIdentifier</span><span class=\"o\">(</span><span class=\"s\">\"host_name\"</span><span class=\"o\">,</span> <span class=\"s\">\"string\"</span><span class=\"o\">,</span> <span class=\"s\">\"com.example.resmodification\"</span><span class=\"o\">));</span>        <span class=\"kt\">int</span> <span class=\"n\">hostNameColor</span> <span class=\"o\">=</span> <span class=\"n\">getResources</span><span class=\"o\">().</span><span class=\"na\">getColor</span><span class=\"o\">(</span>                <span class=\"n\">getResources</span><span class=\"o\">().</span><span class=\"na\">getIdentifier</span><span class=\"o\">(</span><span class=\"s\">\"host_name_color\"</span><span class=\"o\">,</span> <span class=\"s\">\"color\"</span><span class=\"o\">,</span> <span class=\"s\">\"com.example.resmodification\"</span><span class=\"o\">));</span>        <span class=\"n\">testTv</span><span class=\"o\">.</span><span class=\"na\">setText</span><span class=\"o\">(</span><span class=\"n\">hostName</span><span class=\"o\">);</span>        <span class=\"n\">testTv</span><span class=\"o\">.</span><span class=\"na\">setTextColor</span><span class=\"o\">(</span><span class=\"n\">hostNameColor</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">attachBaseContext</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">newBase</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">hookResource</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">);</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">attachBaseContext</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"cm\">/**     * 宿主和插件的资源放在了一个 Resource 对象里，因为我们在打包时做了资源PP段分区，所以不会出现资源冲突的现象。     * 不过目前只是在该 Activity 把我们构建的 Resource 对象 Set 进去了，所以也只能在当前 Context 的环境里同时     * 访问到两个包的资源（我们仅做简单的测试）。一个成熟的插件化架构应该是把所有 Context 初始化的注入都做好（有多     * 种实现手段）。     */</span>    <span class=\"kd\">public</span> <span class=\"nc\">Resources</span> <span class=\"nf\">getPluginR</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">allResources</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">return</span> <span class=\"n\">allResources</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">String</span> <span class=\"n\">dexPath</span> <span class=\"o\">=</span> <span class=\"s\">\"/system/dex/\"</span> <span class=\"o\">+</span> <span class=\"s\">\"5-Plugin.apk\"</span><span class=\"o\">;</span>            <span class=\"nc\">AssetManager</span> <span class=\"n\">assetManager</span> <span class=\"o\">=</span> <span class=\"nc\">AssetManager</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">.</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>            <span class=\"nc\">Method</span> <span class=\"n\">addAssetPath</span> <span class=\"o\">=</span> <span class=\"n\">assetManager</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getMethod</span><span class=\"o\">(</span><span class=\"s\">\"addAssetPaths\"</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"nc\">Class</span><span class=\"o\">[]{</span><span class=\"nc\">String</span><span class=\"o\">[].</span><span class=\"na\">class</span><span class=\"o\">});</span>            <span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">paths</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">String</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">];</span>            <span class=\"n\">paths</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dexPath</span><span class=\"o\">;</span> <span class=\"c1\">// 插件 Asset</span>            <span class=\"n\">paths</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getPackageResourcePath</span><span class=\"o\">();</span> <span class=\"c1\">// 宿主的 Asset</span>            <span class=\"n\">addAssetPath</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"n\">assetManager</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"nc\">Object</span><span class=\"o\">[]{</span><span class=\"n\">paths</span><span class=\"o\">});</span>            <span class=\"n\">allResources</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Resources</span><span class=\"o\">(</span><span class=\"n\">assetManager</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getResources</span><span class=\"o\">().</span><span class=\"na\">getDisplayMetrics</span><span class=\"o\">(),</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getResources</span><span class=\"o\">().</span><span class=\"na\">getConfiguration</span><span class=\"o\">());</span>            <span class=\"k\">return</span> <span class=\"n\">allResources</span><span class=\"o\">;</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">hookResource</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">newBase</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">Field</span> <span class=\"n\">field</span> <span class=\"o\">=</span> <span class=\"n\">newBase</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getDeclaredField</span><span class=\"o\">(</span><span class=\"s\">\"mResources\"</span><span class=\"o\">);</span>            <span class=\"n\">field</span><span class=\"o\">.</span><span class=\"na\">setAccessible</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>            <span class=\"n\">field</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">,</span> <span class=\"n\">getPluginR</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">));</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><h2 id=\"demo-usage\">Demo Usage</h2><ol>  <li>在 Gradle 插件工程执行 <code class=\"language-plaintext highlighter-rouge\">./gradlew publishToMavenLocal</code>，使得 Gradle 插件可以被我们的 插件 App 工程找到并依赖</li>  <li>在插件工程 <code class=\"language-plaintext highlighter-rouge\">./gradlew assembleDebug</code> 打出插件</li>  <li>导入插件到手机指定目录（这个目录是自己随便指定的，跟 Demo 代码里的加载路径一致即可）：<code class=\"language-plaintext highlighter-rouge\">mv app-debug.apk 5-Plugin.apk &amp;&amp; adb push 5-Plugin.apk /system/dex/</code></li>  <li>在宿主工程 <code class=\"language-plaintext highlighter-rouge\">./gradlew installDebug</code> 打包并安装宿主 APK</li>  <li>打开宿主 App，查看效果</li></ol><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li><a href=\"http://blog.csdn.net/luoshengyang/article/details/8744683\">Android应用程序资源的编译和打包过程分析</a></li>  <li><a href=\"http://www.jianshu.com/p/96d5b83ca26c\">插件化-资源处理</a></li>  <li><a href=\"https://github.com/wequick/Small\">Small</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2016/12/01/plugadget-note-5-resmodificationplugin",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2016-12-01T00:00:00+00:00",
            "date_modified": "2016-12-01T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2016/11/16/plugadget-note-4-loadpluginresource",
            "title": "插件化笔记 #4 加载插件资源文件",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes插件化的资源加载大体上也分两种：  每个插件构造单一的 Resource 对象，各个插件的资源互不影响  所有插件的资源都加载到一个 AssetManager，全局可用，但是会出现资源 ID 冲突的现象，必须在打包流程中做修改本节以构造单一对象为基础讲解，资源冲突的问题和方案下节讲。资源的寻找过程  在Activity中的getResources()方法会走到ContextWrapper的实现上，而ContextWrapper顾名思义它只是一个包装类，最终的调用是ContextWrapper的实际类ContextImpl中的方法。  ContextImpl中getResources()方法返回了它的成员变量mResource,我们看一下ContextImpl的构造函数，其中mResources被第一次赋值是通过下面的函数调用: Resources resources = packageInfo.getResources(mainThread);  packageInfo是一个LoadedApk类型的参数，mainThread是ActivityThread类型的参数，mainThread就是当前Apk运行的主进程类，我们继续看LoadedApk中的方法： public Resources getResources(ActivityThread mainThread) {    if (mResources == null) {        mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,                    mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, this);    }    return mResources; }Resources getTopLevelResources(String resDir, String[] splitResDirs, String[] overlayDirs,            String[] libDirs, int displayId, Configuration overrideConfiguration,            LoadedApk pkgInfo) {    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs,                displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);}  mResourceManager是一个ResourceManager类型的成员变量，当我们戳开ResourceManager的代码时，惊喜的发现这个类是一个单例，然后定位到getTopLevelResources方法ResourcesKey key = new ResourcesKey(resDir, displayId, overrideConfiguration, scale, token);Resources r;WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);r = wr != null ? wr.get() : null;if (r != null &amp;&amp; r.getAssets().isUpToDate()) {    return r;}AssetManager assets = new AssetManager();if (resDir != null) {    if (assets.addAssetPath(resDir) == 0) {        return null;    }}r = new Resources(assets, dm, config, compatInfo, token);WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);Resources existing = wr != null ? wr.get() : null;if (existing != null &amp;&amp; existing.getAssets().isUpToDate()) {    r.getAssets().close();    return existing;}mActiveResources.put(key, new WeakReference&lt;Resources&gt;(r));return r;至此，我们知道了资源的真正载入和管理是由 AssetManager 来实现的，那么 Hook 点也知道了——修改 ContextImpl 的 Resource 对象所持有的 AssetManager。Hook在 Plugin 的 Activity 里实现资源加载：public class MainActivity extends AppCompatActivity {    private Resources pluginR;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        // 如果不 Hook mResource，也可以直接 getPluginR 来获取 values 的资源，但是无法装载 Layout        // getPluginR().getString(R.string.plugin_string_res); //        // Fragment 或者 自定义 View 等需要自己 Inflate 的也支持        /*int bundleLayoutId = R.layout.activity_main;        View bundleView = LayoutInflater.from(this).inflate(bundleLayoutId, null);        setContentView(bundleView);*/        setContentView(R.layout.activity_main);    }    @Override    protected void attachBaseContext(Context newBase) {        try {            Field field = newBase.getClass().getDeclaredField(\"mResources\");            field.setAccessible(true);            field.set(newBase, getPluginR(newBase));        } catch (Exception e) {            e.printStackTrace();        }        super.attachBaseContext(newBase);    }    public Resources getPluginR(Context context) {        if (pluginR != null) {            return pluginR;        }        try {            String dexPath = \"/system/dex/\" + \"4-Plugin.apk\";            AssetManager assetManager = AssetManager.class.newInstance();            Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);            addAssetPath.invoke(assetManager, dexPath);            pluginR = new Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());            //独立使用Resource时（不hook mResource）            //Resources origin = super.getResources();            //pluginR = new Resources(assetManager, origin.getDisplayMetrics(), origin.getConfiguration());            return pluginR;        } catch (Exception e) {            e.printStackTrace();            return null;        }    }}参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  ANDROID应用程序插件化研究之ASSETMANAGER  插件化-资源处理  Android插件化（三）加载插件apk中的Resource资源欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><p>插件化的资源加载大体上也分两种：</p><ul>  <li>每个插件构造单一的 <code class=\"language-plaintext highlighter-rouge\">Resource</code> 对象，各个插件的资源互不影响</li>  <li>所有插件的资源都加载到一个 <code class=\"language-plaintext highlighter-rouge\">AssetManager</code>，全局可用，但是会出现资源 ID 冲突的现象，必须在打包流程中做修改</li></ul><p>本节以构造单一对象为基础讲解，资源冲突的问题和方案下节讲。</p><h2 id=\"资源的寻找过程\">资源的寻找过程</h2><blockquote>  <p>在Activity中的getResources()方法会走到ContextWrapper的实现上，而ContextWrapper顾名思义它只是一个包装类，最终的调用是ContextWrapper的实际类ContextImpl中的方法。</p>  <p>ContextImpl中getResources()方法返回了它的成员变量mResource,我们看一下ContextImpl的构造函数，其中mResources被第一次赋值是通过下面的函数调用:</p></blockquote><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> Resources resources = packageInfo.getResources(mainThread);</code></pre></div></div><!--more--><blockquote>  <p>packageInfo是一个LoadedApk类型的参数，mainThread是ActivityThread类型的参数，mainThread就是当前Apk运行的主进程类，我们继续看LoadedApk中的方法：</p></blockquote><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> public Resources getResources(ActivityThread mainThread) {    if (mResources == null) {        mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,                    mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, null, this);    }    return mResources; }</code></pre></div></div><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Resources getTopLevelResources(String resDir, String[] splitResDirs, String[] overlayDirs,            String[] libDirs, int displayId, Configuration overrideConfiguration,            LoadedApk pkgInfo) {    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs,                displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);}</code></pre></div></div><blockquote>  <p>mResourceManager是一个ResourceManager类型的成员变量，当我们戳开ResourceManager的代码时，惊喜的发现这个类是一个单例，然后定位到getTopLevelResources方法</p></blockquote><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">ResourcesKey</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">ResourcesKey</span><span class=\"o\">(</span><span class=\"n\">resDir</span><span class=\"o\">,</span> <span class=\"n\">displayId</span><span class=\"o\">,</span> <span class=\"n\">overrideConfiguration</span><span class=\"o\">,</span> <span class=\"n\">scale</span><span class=\"o\">,</span> <span class=\"n\">token</span><span class=\"o\">);</span><span class=\"nc\">Resources</span> <span class=\"n\">r</span><span class=\"o\">;</span><span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">Resources</span><span class=\"o\">&gt;</span> <span class=\"n\">wr</span> <span class=\"o\">=</span> <span class=\"n\">mActiveResources</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">wr</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">wr</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"kc\">null</span><span class=\"o\">;</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">getAssets</span><span class=\"o\">().</span><span class=\"na\">isUpToDate</span><span class=\"o\">())</span> <span class=\"o\">{</span>    <span class=\"k\">return</span> <span class=\"n\">r</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"nc\">AssetManager</span> <span class=\"n\">assets</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">AssetManager</span><span class=\"o\">();</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">resDir</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">assets</span><span class=\"o\">.</span><span class=\"na\">addAssetPath</span><span class=\"o\">(</span><span class=\"n\">resDir</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Resources</span><span class=\"o\">(</span><span class=\"n\">assets</span><span class=\"o\">,</span> <span class=\"n\">dm</span><span class=\"o\">,</span> <span class=\"n\">config</span><span class=\"o\">,</span> <span class=\"n\">compatInfo</span><span class=\"o\">,</span> <span class=\"n\">token</span><span class=\"o\">);</span><span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">Resources</span><span class=\"o\">&gt;</span> <span class=\"n\">wr</span> <span class=\"o\">=</span> <span class=\"n\">mActiveResources</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span><span class=\"nc\">Resources</span> <span class=\"n\">existing</span> <span class=\"o\">=</span> <span class=\"n\">wr</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">wr</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"kc\">null</span><span class=\"o\">;</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">existing</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">existing</span><span class=\"o\">.</span><span class=\"na\">getAssets</span><span class=\"o\">().</span><span class=\"na\">isUpToDate</span><span class=\"o\">())</span> <span class=\"o\">{</span>    <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">getAssets</span><span class=\"o\">().</span><span class=\"na\">close</span><span class=\"o\">();</span>    <span class=\"k\">return</span> <span class=\"n\">existing</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"n\">mActiveResources</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"nc\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"nc\">Resources</span><span class=\"o\">&gt;(</span><span class=\"n\">r</span><span class=\"o\">));</span><span class=\"k\">return</span> <span class=\"n\">r</span><span class=\"o\">;</span></code></pre></div></div><p>至此，我们知道了资源的真正载入和管理是由 AssetManager 来实现的，那么 Hook 点也知道了——修改 ContextImpl 的 Resource 对象所持有的 AssetManager。</p><h2 id=\"hook\">Hook</h2><p>在 Plugin 的 Activity 里实现资源加载：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MainActivity</span> <span class=\"kd\">extends</span> <span class=\"nc\">AppCompatActivity</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"nc\">Resources</span> <span class=\"n\">pluginR</span><span class=\"o\">;</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">onCreate</span><span class=\"o\">(</span><span class=\"nc\">Bundle</span> <span class=\"n\">savedInstanceState</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">onCreate</span><span class=\"o\">(</span><span class=\"n\">savedInstanceState</span><span class=\"o\">);</span>        <span class=\"c1\">// 如果不 Hook mResource，也可以直接 getPluginR 来获取 values 的资源，但是无法装载 Layout</span>        <span class=\"c1\">// getPluginR().getString(R.string.plugin_string_res); //</span>        <span class=\"c1\">// Fragment 或者 自定义 View 等需要自己 Inflate 的也支持</span>        <span class=\"cm\">/*int bundleLayoutId = R.layout.activity_main;        View bundleView = LayoutInflater.from(this).inflate(bundleLayoutId, null);        setContentView(bundleView);*/</span>        <span class=\"n\">setContentView</span><span class=\"o\">(</span><span class=\"no\">R</span><span class=\"o\">.</span><span class=\"na\">layout</span><span class=\"o\">.</span><span class=\"na\">activity_main</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">attachBaseContext</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">newBase</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">Field</span> <span class=\"n\">field</span> <span class=\"o\">=</span> <span class=\"n\">newBase</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getDeclaredField</span><span class=\"o\">(</span><span class=\"s\">\"mResources\"</span><span class=\"o\">);</span>            <span class=\"n\">field</span><span class=\"o\">.</span><span class=\"na\">setAccessible</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>            <span class=\"n\">field</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">,</span> <span class=\"n\">getPluginR</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">));</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>        <span class=\"o\">}</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">attachBaseContext</span><span class=\"o\">(</span><span class=\"n\">newBase</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"kd\">public</span> <span class=\"nc\">Resources</span> <span class=\"nf\">getPluginR</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pluginR</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">return</span> <span class=\"n\">pluginR</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">String</span> <span class=\"n\">dexPath</span> <span class=\"o\">=</span> <span class=\"s\">\"/system/dex/\"</span> <span class=\"o\">+</span> <span class=\"s\">\"4-Plugin.apk\"</span><span class=\"o\">;</span>            <span class=\"nc\">AssetManager</span> <span class=\"n\">assetManager</span> <span class=\"o\">=</span> <span class=\"nc\">AssetManager</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">.</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>            <span class=\"nc\">Method</span> <span class=\"n\">addAssetPath</span> <span class=\"o\">=</span> <span class=\"n\">assetManager</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getMethod</span><span class=\"o\">(</span><span class=\"s\">\"addAssetPath\"</span><span class=\"o\">,</span> <span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">);</span>            <span class=\"n\">addAssetPath</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"n\">assetManager</span><span class=\"o\">,</span> <span class=\"n\">dexPath</span><span class=\"o\">);</span>            <span class=\"n\">pluginR</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Resources</span><span class=\"o\">(</span><span class=\"n\">assetManager</span><span class=\"o\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getResources</span><span class=\"o\">().</span><span class=\"na\">getDisplayMetrics</span><span class=\"o\">(),</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getResources</span><span class=\"o\">().</span><span class=\"na\">getConfiguration</span><span class=\"o\">());</span>            <span class=\"c1\">//独立使用Resource时（不hook mResource）</span>            <span class=\"c1\">//Resources origin = super.getResources();</span>            <span class=\"c1\">//pluginR = new Resources(assetManager, origin.getDisplayMetrics(), origin.getConfiguration());</span>            <span class=\"k\">return</span> <span class=\"n\">pluginR</span><span class=\"o\">;</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li><a href=\"http://www.liuguangli.win/archives/370\">ANDROID应用程序插件化研究之ASSETMANAGER</a></li>  <li><a href=\"http://www.jianshu.com/p/96d5b83ca26c\">插件化-资源处理</a></li>  <li><a href=\"http://blog.csdn.net/nupt123456789/article/details/50414175\">Android插件化（三）加载插件apk中的Resource资源</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2016/11/16/plugadget-note-4-loadpluginresource",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2016-11-16T00:00:00+00:00",
            "date_modified": "2016-11-16T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2016/11/16/plugadget-note-3-startpluginactivity",
            "title": "插件化笔记 #3 启动插件 Activity",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes其实从这一节开始，就需要区分两种插件化的方案：  需要提前在 Manifest 里注册 Activity 、Service 的  不需要的网路上大多是研究不需要注册的方案，需要 hook 各种 Activity、Service 的启动流程和生命周期。一般来说 hook 的原则是越少越好，越少越不会和系统的变动有冲突，自然也就不会出问题。当然，也有不做深度 hook 的方案，比如被反编译出来的 Atlas （现在改名叫 ACDD，https://github.com/zjf1023/ACDDExtension)。下面都是按预先注册的方案来解释，这样的方案较为简单，hook的量极少，稳定可靠，当然也就牺牲了一定的动态性。Activity 启动需要什么启动流程的分析网路上很多很多，这边摘了一个比较精简的版本：      每个Activity的启动过程都是通过startActivityForResult() 最终都会调用Instrument.execStartActivity()    再由ActivityManagerNative.startActivity() 通过 IPC AMS所在进程，ActivityManagerService.startActivity()    最后 ActivityStackSupervisor.startActivityLocked(),权限以及安全检查mService.checkPermission。我们的Activity如果不注册就会在这个检查时返回一个没有注册的错误，最后回到应用进程的时候抛出这个没注册的异常。    安全校验完成以后，会调用ApplicationThread.scheduleLaunchActivity()    这一步让ApplicationThread做好跳转 activity 的准备（一些数据的封装），紧接着通过handle发送消息通知app.thread要进行Activity启动调度了，然后 app.thread接收到消息的时候才开始进行调度。    这个message的接收是在ActivityThread中的handleMessage(Message msg)处理的。  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");final ActivityClientRecord r = (ActivityClientRecord) msg.obj;r.packageInfo = getPackageInfoNoCheck(\t        r.activityInfo.applicationInfo, r.compatInfo);handleLaunchActivity(r, null);Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);      这句中handleLaunchActivity()又调用了performLaunchActivity(r, customIntent); 而最终又调用了这句：  java.lang.ClassLoader cl = r.packageInfo.getClassLoader();activity = mInstrumentation.newActivity(        cl, component.getClassName(), r.intent);StrictMode.incrementExpectedActivityCount(activity.getClass());r.intent.setExtrasClassLoader(cl);      兜了一圈又回到Instrumentation了。结果终于找到了可以hook的点了，就是这个mInstrumentation.newActivity()  Hook因为我们提前注册了 Activity，所以其实不会碰到校验的问题。剩下的问题就只有，我们的插件 Activity 代码不在当前 Classloader 里。java.lang.ClassLoader cl = r.packageInfo.getClassLoader();activity = mInstrumentation.newActivity(        cl, component.getClassName(), r.intent);Hook 的点也是显而易见的，在 Instrumentation 里把 ClassLoader 换掉。Application里：@Overrideprotected void attachBaseContext(Context base) {    super.attachBaseContext(base);    installDex();    hookInstrumentation();}private void installDex() {    // 外部路径    File optimizedDexOutputPath = new File(\"/system/dex/\" + \"3-Plugin.apk\");    // 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录）    File dexOutputDir = this.getDir(\"dex\", 0);    dexClassLoader = new DexClassLoader(            optimizedDexOutputPath.getAbsolutePath(),            dexOutputDir.getAbsolutePath(),            null,            getClassLoader());}private void hookInstrumentation() {    try {        Class&lt;?&gt; activityThreadClass = Class.forName(\"android.app.ActivityThread\");        Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\"currentActivityThread\");        currentActivityThreadMethod.setAccessible(true);        Object currentActivityThread = currentActivityThreadMethod.invoke(null);        // 拿到原始的 mInstrumentation字段        Field mInstrumentationField = activityThreadClass.getDeclaredField(\"mInstrumentation\");        mInstrumentationField.setAccessible(true);        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);        //如果没有注入过，就执行替换        if (!(mInstrumentation instanceof CustomInstrumentation)) {            CustomInstrumentation pluginInstrumentation = new CustomInstrumentation(mInstrumentation, dexClassLoader);            mInstrumentationField.set(currentActivityThread, pluginInstrumentation);        }    } catch (Exception e) {        e.printStackTrace();    }}CustomInstrumentation：public class CustomInstrumentation extends Instrumentation {    private ClassLoader customClassloader;    private Instrumentation base;    public CustomInstrumentation(Instrumentation base, ClassLoader classLoader) {        this.base = base;  // 如果要不注册 Activity 就能启动的方式，那么还需要 hook execStartActivity 等方法，此时会用到这个 base 的 Instrumentation        customClassloader = classLoader;    }    @Override    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {        // 替换了 ClassLoader        return super.newActivity(customClassloader, className, intent);    }}至此，我们就能启动插件的 Activity 了。参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  8个类搞定插件化——Activity实现方案  Android 插件化原理解析——插件加载机制  Android插件化（一）：使用改进的MultiDex动态加载assets中的apk欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><p>其实从这一节开始，就需要区分两种插件化的方案：</p><ul>  <li>需要提前在 Manifest 里注册 Activity 、Service 的</li>  <li>不需要的</li></ul><p>网路上大多是研究不需要注册的方案，需要 hook 各种 Activity、Service 的启动流程和生命周期。一般来说 hook 的原则是越少越好，越少越不会和系统的变动有冲突，自然也就不会出问题。</p><p>当然，也有不做深度 hook 的方案，比如被反编译出来的 Atlas （现在改名叫 ACDD，https://github.com/zjf1023/ACDDExtension)。下面都是按预先注册的方案来解释，这样的方案较为简单，hook的量极少，稳定可靠，当然也就牺牲了一定的动态性。</p><!--more--><h2 id=\"activity-启动需要什么\">Activity 启动需要什么</h2><p>启动流程的分析网路上很多很多，这边摘了一个比较精简的版本：</p><blockquote>  <ul>    <li>每个Activity的启动过程都是通过startActivityForResult() 最终都会调用Instrument.execStartActivity()</li>    <li>再由ActivityManagerNative.startActivity() 通过 IPC AMS所在进程，ActivityManagerService.startActivity()</li>    <li>最后 ActivityStackSupervisor.startActivityLocked(),权限以及安全检查mService.checkPermission。我们的Activity如果不注册就会在这个检查时返回一个没有注册的错误，最后回到应用进程的时候抛出这个没注册的异常。</li>    <li>安全校验完成以后，会调用ApplicationThread.scheduleLaunchActivity()</li>    <li>这一步让ApplicationThread做好跳转 activity 的准备（一些数据的封装），紧接着通过handle发送消息通知app.thread要进行Activity启动调度了，然后 app.thread接收到消息的时候才开始进行调度。</li>    <li>这个message的接收是在ActivityThread中的handleMessage(Message msg)处理的。</li>  </ul></blockquote><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Trace</span><span class=\"o\">.</span><span class=\"na\">traceBegin</span><span class=\"o\">(</span><span class=\"nc\">Trace</span><span class=\"o\">.</span><span class=\"na\">TRACE_TAG_ACTIVITY_MANAGER</span><span class=\"o\">,</span> <span class=\"s\">\"activityStart\"</span><span class=\"o\">);</span><span class=\"kd\">final</span> <span class=\"nc\">ActivityClientRecord</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">ActivityClientRecord</span><span class=\"o\">)</span> <span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"na\">obj</span><span class=\"o\">;</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">packageInfo</span> <span class=\"o\">=</span> <span class=\"n\">getPackageInfoNoCheck</span><span class=\"o\">(</span>\t        <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">activityInfo</span><span class=\"o\">.</span><span class=\"na\">applicationInfo</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">compatInfo</span><span class=\"o\">);</span><span class=\"n\">handleLaunchActivity</span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span><span class=\"nc\">Trace</span><span class=\"o\">.</span><span class=\"na\">traceEnd</span><span class=\"o\">(</span><span class=\"nc\">Trace</span><span class=\"o\">.</span><span class=\"na\">TRACE_TAG_ACTIVITY_MANAGER</span><span class=\"o\">);</span></code></pre></div></div><blockquote>  <ul>    <li>这句中handleLaunchActivity()又调用了performLaunchActivity(r, customIntent); 而最终又调用了这句：</li>  </ul></blockquote><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ClassLoader</span> <span class=\"n\">cl</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">getClassLoader</span><span class=\"o\">();</span><span class=\"n\">activity</span> <span class=\"o\">=</span> <span class=\"n\">mInstrumentation</span><span class=\"o\">.</span><span class=\"na\">newActivity</span><span class=\"o\">(</span>        <span class=\"n\">cl</span><span class=\"o\">,</span> <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">getClassName</span><span class=\"o\">(),</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">intent</span><span class=\"o\">);</span><span class=\"nc\">StrictMode</span><span class=\"o\">.</span><span class=\"na\">incrementExpectedActivityCount</span><span class=\"o\">(</span><span class=\"n\">activity</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">());</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">intent</span><span class=\"o\">.</span><span class=\"na\">setExtrasClassLoader</span><span class=\"o\">(</span><span class=\"n\">cl</span><span class=\"o\">);</span></code></pre></div></div><blockquote>  <ul>    <li>兜了一圈又回到Instrumentation了。结果终于找到了可以hook的点了，就是这个mInstrumentation.newActivity()</li>  </ul></blockquote><h2 id=\"hook\">Hook</h2><p>因为我们提前注册了 Activity，所以其实不会碰到校验的问题。剩下的问题就只有，我们的插件 Activity 代码不在当前 Classloader 里。</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ClassLoader</span> <span class=\"n\">cl</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">packageInfo</span><span class=\"o\">.</span><span class=\"na\">getClassLoader</span><span class=\"o\">();</span><span class=\"n\">activity</span> <span class=\"o\">=</span> <span class=\"n\">mInstrumentation</span><span class=\"o\">.</span><span class=\"na\">newActivity</span><span class=\"o\">(</span>        <span class=\"n\">cl</span><span class=\"o\">,</span> <span class=\"n\">component</span><span class=\"o\">.</span><span class=\"na\">getClassName</span><span class=\"o\">(),</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">intent</span><span class=\"o\">);</span></code></pre></div></div><p>Hook 的点也是显而易见的，在 Instrumentation 里把 ClassLoader 换掉。</p><p>Application里：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Override</span><span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">attachBaseContext</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">base</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">attachBaseContext</span><span class=\"o\">(</span><span class=\"n\">base</span><span class=\"o\">);</span>    <span class=\"n\">installDex</span><span class=\"o\">();</span>    <span class=\"n\">hookInstrumentation</span><span class=\"o\">();</span><span class=\"o\">}</span><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">installDex</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"c1\">// 外部路径</span>    <span class=\"nc\">File</span> <span class=\"n\">optimizedDexOutputPath</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">File</span><span class=\"o\">(</span><span class=\"s\">\"/system/dex/\"</span> <span class=\"o\">+</span> <span class=\"s\">\"3-Plugin.apk\"</span><span class=\"o\">);</span>    <span class=\"c1\">// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录）</span>    <span class=\"nc\">File</span> <span class=\"n\">dexOutputDir</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">getDir</span><span class=\"o\">(</span><span class=\"s\">\"dex\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span>    <span class=\"n\">dexClassLoader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">DexClassLoader</span><span class=\"o\">(</span>            <span class=\"n\">optimizedDexOutputPath</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>            <span class=\"n\">dexOutputDir</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>            <span class=\"kc\">null</span><span class=\"o\">,</span>            <span class=\"n\">getClassLoader</span><span class=\"o\">());</span><span class=\"o\">}</span><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">hookInstrumentation</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"k\">try</span> <span class=\"o\">{</span>        <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">activityThreadClass</span> <span class=\"o\">=</span> <span class=\"nc\">Class</span><span class=\"o\">.</span><span class=\"na\">forName</span><span class=\"o\">(</span><span class=\"s\">\"android.app.ActivityThread\"</span><span class=\"o\">);</span>        <span class=\"nc\">Method</span> <span class=\"n\">currentActivityThreadMethod</span> <span class=\"o\">=</span> <span class=\"n\">activityThreadClass</span><span class=\"o\">.</span><span class=\"na\">getDeclaredMethod</span><span class=\"o\">(</span><span class=\"s\">\"currentActivityThread\"</span><span class=\"o\">);</span>        <span class=\"n\">currentActivityThreadMethod</span><span class=\"o\">.</span><span class=\"na\">setAccessible</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>        <span class=\"nc\">Object</span> <span class=\"n\">currentActivityThread</span> <span class=\"o\">=</span> <span class=\"n\">currentActivityThreadMethod</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">);</span>        <span class=\"c1\">// 拿到原始的 mInstrumentation字段</span>        <span class=\"nc\">Field</span> <span class=\"n\">mInstrumentationField</span> <span class=\"o\">=</span> <span class=\"n\">activityThreadClass</span><span class=\"o\">.</span><span class=\"na\">getDeclaredField</span><span class=\"o\">(</span><span class=\"s\">\"mInstrumentation\"</span><span class=\"o\">);</span>        <span class=\"n\">mInstrumentationField</span><span class=\"o\">.</span><span class=\"na\">setAccessible</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>        <span class=\"nc\">Instrumentation</span> <span class=\"n\">mInstrumentation</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">Instrumentation</span><span class=\"o\">)</span> <span class=\"n\">mInstrumentationField</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">currentActivityThread</span><span class=\"o\">);</span>        <span class=\"c1\">//如果没有注入过，就执行替换</span>        <span class=\"k\">if</span> <span class=\"o\">(!(</span><span class=\"n\">mInstrumentation</span> <span class=\"k\">instanceof</span> <span class=\"nc\">CustomInstrumentation</span><span class=\"o\">))</span> <span class=\"o\">{</span>            <span class=\"nc\">CustomInstrumentation</span> <span class=\"n\">pluginInstrumentation</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">CustomInstrumentation</span><span class=\"o\">(</span><span class=\"n\">mInstrumentation</span><span class=\"o\">,</span> <span class=\"n\">dexClassLoader</span><span class=\"o\">);</span>            <span class=\"n\">mInstrumentationField</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">currentActivityThread</span><span class=\"o\">,</span> <span class=\"n\">pluginInstrumentation</span><span class=\"o\">);</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>CustomInstrumentation：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CustomInstrumentation</span> <span class=\"kd\">extends</span> <span class=\"nc\">Instrumentation</span> <span class=\"o\">{</span>    <span class=\"kd\">private</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">customClassloader</span><span class=\"o\">;</span>    <span class=\"kd\">private</span> <span class=\"nc\">Instrumentation</span> <span class=\"n\">base</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"nf\">CustomInstrumentation</span><span class=\"o\">(</span><span class=\"nc\">Instrumentation</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">classLoader</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">base</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">;</span>  <span class=\"c1\">// 如果要不注册 Activity 就能启动的方式，那么还需要 hook execStartActivity 等方法，此时会用到这个 base 的 Instrumentation</span>        <span class=\"n\">customClassloader</span> <span class=\"o\">=</span> <span class=\"n\">classLoader</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">public</span> <span class=\"nc\">Activity</span> <span class=\"nf\">newActivity</span><span class=\"o\">(</span><span class=\"nc\">ClassLoader</span> <span class=\"n\">cl</span><span class=\"o\">,</span> <span class=\"nc\">String</span> <span class=\"n\">className</span><span class=\"o\">,</span> <span class=\"nc\">Intent</span> <span class=\"n\">intent</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"nc\">InstantiationException</span><span class=\"o\">,</span> <span class=\"nc\">IllegalAccessException</span><span class=\"o\">,</span> <span class=\"nc\">ClassNotFoundException</span> <span class=\"o\">{</span>        <span class=\"c1\">// 替换了 ClassLoader</span>        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">newActivity</span><span class=\"o\">(</span><span class=\"n\">customClassloader</span><span class=\"o\">,</span> <span class=\"n\">className</span><span class=\"o\">,</span> <span class=\"n\">intent</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>至此，我们就能启动插件的 Activity 了。</p><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li><a href=\"http://kymjs.com/code/2016/05/15/01\">8个类搞定插件化——Activity实现方案</a></li>  <li><a href=\"http://weishu.me/2016/04/05/understand-plugin-framework-classloader/\">Android 插件化原理解析——插件加载机制</a></li>  <li><a href=\"https://github.com/nuptboyzhb/AndroidPluginFramework/blob/master/%E7%AC%AC%E4%B8%80%E8%AF%BE-%E6%94%B9%E8%BF%9B%E7%9A%84MultiDex%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%99%AE%E9%80%9Aapk/README.md\">Android插件化（一）：使用改进的MultiDex动态加载assets中的apk</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2016/11/16/plugadget-note-3-startpluginactivity",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2016-11-16T00:00:00+00:00",
            "date_modified": "2016-11-16T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2016/09/18/plugadget-note-2-loadpluginclass",
            "title": "插件化笔记 #2 加载插件代码",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes如何获取能够被加载的 .dex 文件准备如下两个测试类，其中TestDexInterface还需要拷贝一份到工程中[TestDexClass.java]package example.com.classeasyload;public class TestDexClass implements TestDexInterface{    @Override    public float getPiValue() {        return 3.14f;    }}[TestDexInterface.java]package example.com.classeasyload;public interface TestDexInterface {    float getPiValue();}  javac *.java                              -&gt; .class  jar cvf origin.jar .                      -&gt; .jar  dx --dex --output=target.dex origin.jar   -&gt; .dex按文章的步骤，自己实现了一遍，需要注意的是第二步打jar包的时候需要连包名所在的文件夹一起打进去|____example| |____com| | |____classeasyload| | | |____TestDexClass.class| | | |____TestDexInterface.classjar包里应该是如上的结构。加载并调用.dex里面的方法这里我先 adb shell mkdir -p /system/dex/, 然后adb push target.dex /system/dex/如MainActivity里代码所示：File optimizedDexOutputPath = new File(\"/system/dex/\" + \"target.dex\");// 外部路径File dexOutputDir = this.getDir(\"dex\", 0);// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录）DexClassLoader dexClassLoader = new DexClassLoader(       optimizedDexOutputPath.getAbsolutePath(),       dexOutputDir.getAbsolutePath(),       null,       getClassLoader());try {    Class libProviderClazz = dexClassLoader.loadClass(\"example.com.classeasyload.TestDexClass\");    TestDexInterface dexInterface = (TestDexInterface) libProviderClazz.newInstance();    Toast.makeText(this, dexInterface.getPiValue() + \"\", Toast.LENGTH_LONG).show();} catch (Exception e) {    e.printStackTrace();}最终成功Toast出了3.14。参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  http://blog.csdn.net/singwhatiwanna/article/details/40283117  http://blog.csdn.net/NUPTboyZHB/article/category/1204147  https://zhuanlan.zhihu.com/p/20515113欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><h2 id=\"如何获取能够被加载的-dex-文件\">如何获取能够被加载的 .dex 文件</h2><p>准备如下两个测试类，其中TestDexInterface还需要拷贝一份到工程中</p><p><strong>[TestDexClass.java]</strong></p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">package</span> <span class=\"nn\">example.com.classeasyload</span><span class=\"o\">;</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">TestDexClass</span> <span class=\"kd\">implements</span> <span class=\"nc\">TestDexInterface</span><span class=\"o\">{</span>    <span class=\"nd\">@Override</span>    <span class=\"kd\">public</span> <span class=\"kt\">float</span> <span class=\"nf\">getPiValue</span><span class=\"o\">()</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"mf\">3.14f</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p><strong>[TestDexInterface.java]</strong></p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">package</span> <span class=\"nn\">example.com.classeasyload</span><span class=\"o\">;</span><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">TestDexInterface</span> <span class=\"o\">{</span>    <span class=\"kt\">float</span> <span class=\"nf\">getPiValue</span><span class=\"o\">();</span><span class=\"o\">}</span></code></pre></div></div><ol>  <li><code class=\"language-plaintext highlighter-rouge\">javac *.java                              -&gt; .class</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">jar cvf origin.jar .                      -&gt; .jar</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">dx --dex --output=target.dex origin.jar   -&gt; .dex</code></li></ol><!--more--><p>按文章的步骤，自己实现了一遍，需要注意的是第二步打jar包的时候需要连包名所在的文件夹一起打进去</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>|____example| |____com| | |____classeasyload| | | |____TestDexClass.class| | | |____TestDexInterface.class</code></pre></div></div><p>jar包里应该是如上的结构。</p><h2 id=\"加载并调用dex里面的方法\">加载并调用.dex里面的方法</h2><p>这里我先 <code class=\"language-plaintext highlighter-rouge\">adb shell mkdir -p /system/dex/</code>, 然后<code class=\"language-plaintext highlighter-rouge\">adb push target.dex /system/dex/</code>如MainActivity里代码所示：</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">File</span> <span class=\"n\">optimizedDexOutputPath</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">File</span><span class=\"o\">(</span><span class=\"s\">\"/system/dex/\"</span> <span class=\"o\">+</span> <span class=\"s\">\"target.dex\"</span><span class=\"o\">);</span><span class=\"c1\">// 外部路径</span><span class=\"nc\">File</span> <span class=\"n\">dexOutputDir</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">getDir</span><span class=\"o\">(</span><span class=\"s\">\"dex\"</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">);</span><span class=\"c1\">// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录）</span><span class=\"nc\">DexClassLoader</span> <span class=\"n\">dexClassLoader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">DexClassLoader</span><span class=\"o\">(</span>       <span class=\"n\">optimizedDexOutputPath</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>       <span class=\"n\">dexOutputDir</span><span class=\"o\">.</span><span class=\"na\">getAbsolutePath</span><span class=\"o\">(),</span>       <span class=\"kc\">null</span><span class=\"o\">,</span>       <span class=\"n\">getClassLoader</span><span class=\"o\">());</span><span class=\"k\">try</span> <span class=\"o\">{</span>    <span class=\"nc\">Class</span> <span class=\"n\">libProviderClazz</span> <span class=\"o\">=</span> <span class=\"n\">dexClassLoader</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"s\">\"example.com.classeasyload.TestDexClass\"</span><span class=\"o\">);</span>    <span class=\"nc\">TestDexInterface</span> <span class=\"n\">dexInterface</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">TestDexInterface</span><span class=\"o\">)</span> <span class=\"n\">libProviderClazz</span><span class=\"o\">.</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>    <span class=\"nc\">Toast</span><span class=\"o\">.</span><span class=\"na\">makeText</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">dexInterface</span><span class=\"o\">.</span><span class=\"na\">getPiValue</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">\"\"</span><span class=\"o\">,</span> <span class=\"nc\">Toast</span><span class=\"o\">.</span><span class=\"na\">LENGTH_LONG</span><span class=\"o\">).</span><span class=\"na\">show</span><span class=\"o\">();</span><span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span><span class=\"o\">}</span></code></pre></div></div><p>最终成功Toast出了<code class=\"language-plaintext highlighter-rouge\">3.14</code>。</p><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li><a href=\"http://blog.csdn.net/singwhatiwanna/article/details/40283117\">http://blog.csdn.net/singwhatiwanna/article/details/40283117</a></li>  <li><a href=\"http://blog.csdn.net/NUPTboyZHB/article/category/1204147\">http://blog.csdn.net/NUPTboyZHB/article/category/1204147</a></li>  <li><a href=\"https://zhuanlan.zhihu.com/p/20515113\">https://zhuanlan.zhihu.com/p/20515113</a></li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2016/09/18/plugadget-note-2-loadpluginclass",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2016-09-18T00:00:00+00:00",
            "date_modified": "2016-09-18T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2016/09/18/plugadget-note-1-classloader",
            "title": "插件化笔记 #1 ClassLoader 初探",
            "summary": null,
            "content_text": "  Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes有几个ClassLoader如MainActivity的代码所示， protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ClassLoader classLoader = getClassLoader();        if (classLoader != null) {            Log.i(\"[onCreate]\", classLoader.toString());            while (classLoader.getParent() != null) {                classLoader = classLoader.getParent();                Log.i(\"[onCreate While]\", classLoader.toString());            }        }    }打印出来的结果是I/[onCreate]: dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/example.com.classloaderdemo-1/base.apk\"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]I/[onCreate While]: com.android.tools.fd.runtime.IncrementalClassLoader@1d4251eaI/[onCreate While]: java.lang.BootClassLoader@2f2e5cdb卧槽，怎么有三个，这跟文章说的只有两个不一样啊 - -，而且我也只听师兄说过PathClassLoader和BootClassLoader，没见过这个IncrementalClassLoader啊，它是什么鬼？随手一搜，一篇结果链接，发现这是因为我用了 Instant Run 而出现的，再一想，嗯，Instant Run 本身也就是一种热修复的方式，思路就是把改动的地方打到dex里然后再用IncrementalClassLoader设置成app的ClassLoader的parent，即可拦截所有类加载的动作，从而实现动态增量加载。创建自己的ClassLoader实例/**  * Constructs a new instance of this class with the system class loader as  * its parent.  */protected ClassLoader() {    this(getSystemClassLoader(), false);}/**  * Constructs a new instance of this class with the specified class loader  * as its parent.  *  * @param parentLoader  *            The {@code ClassLoader} to use as the new class loader's  *            parent.  */protected ClassLoader(ClassLoader parentLoader) {    this(parentLoader, false);}/*  * constructor for the BootClassLoader which needs parent to be null.  */ClassLoader(ClassLoader parentLoader, boolean nullAllowed) {    if (parentLoader == null &amp;&amp; !nullAllowed) {        throw new NullPointerException(\"parentLoader == null &amp;&amp; !nullAllowed\");    }    parent = parentLoader;}文章提到  整个Android系统里所有的ClassLoader实例都会被一棵树关联起来，这也是ClassLoader的 双亲代理模型（Parent-Delegation Model）的特点。没提到的是，ClassLoader有三个构造器，根节点的BootClassLoader自然就是不需要parent的，如注释所写使用ClassLoader一些需要注意的问题  在Java中，只有当两个实例的类名、包名以及加载其的ClassLoader都相同，才会被认为是同一种类型。故，不可用与「加载旧类的ClassLoader」没有树的继承关系的「另一个ClassLoader」来加载新类，会出现类型不符合的异常。DexClassLoader 和 PathClassLoader  DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；  PathClassLoader只能加载系统中已经安装过的apk；  optimizedDirectory必须是一个内部存储路径，还记得我们之前说过的，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。加载类的过程ClassLoader.loadClass() -&gt; BaseDexClassLoader.findClass() -&gt; DexPathList-&gt;findClass()public Class findClass(String name) {        for (Element element : dexElements) {            DexFile dex = element.dexFile;            if (dex != null) {                Class clazz = dex.loadClassBinaryName(name, definingContext);                if (clazz != null) {                    return clazz;                }            }        }        return null;    }public Class loadClassBinaryName(String name, ClassLoader loader) {        return defineClass(name, loader, mCookie);    }private native static Class defineClass(String name, ClassLoader loader, int cookie);参考资料本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。  https://zhuanlan.zhihu.com/p/20524252欢迎关注我的公众号和微博。",
            "content_html": "<blockquote>  <p>Demo: https://github.com/2BAB/Android-Plugin-Dev-Notes</p></blockquote><h2 id=\"有几个classloader\">有几个ClassLoader</h2><p>如MainActivity的代码所示，</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">onCreate</span><span class=\"o\">(</span><span class=\"nc\">Bundle</span> <span class=\"n\">savedInstanceState</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">onCreate</span><span class=\"o\">(</span><span class=\"n\">savedInstanceState</span><span class=\"o\">);</span>        <span class=\"n\">setContentView</span><span class=\"o\">(</span><span class=\"no\">R</span><span class=\"o\">.</span><span class=\"na\">layout</span><span class=\"o\">.</span><span class=\"na\">activity_main</span><span class=\"o\">);</span>        <span class=\"nc\">ClassLoader</span> <span class=\"n\">classLoader</span> <span class=\"o\">=</span> <span class=\"n\">getClassLoader</span><span class=\"o\">();</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">classLoader</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"nc\">Log</span><span class=\"o\">.</span><span class=\"na\">i</span><span class=\"o\">(</span><span class=\"s\">\"[onCreate]\"</span><span class=\"o\">,</span> <span class=\"n\">classLoader</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">());</span>            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">classLoader</span><span class=\"o\">.</span><span class=\"na\">getParent</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">classLoader</span> <span class=\"o\">=</span> <span class=\"n\">classLoader</span><span class=\"o\">.</span><span class=\"na\">getParent</span><span class=\"o\">();</span>                <span class=\"nc\">Log</span><span class=\"o\">.</span><span class=\"na\">i</span><span class=\"o\">(</span><span class=\"s\">\"[onCreate While]\"</span><span class=\"o\">,</span> <span class=\"n\">classLoader</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">());</span>            <span class=\"o\">}</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span></code></pre></div></div><p>打印出来的结果是</p><div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>I/[onCreate]: dalvik.system.PathClassLoader[DexPathList[[zip file \"/data/app/example.com.classloaderdemo-1/base.apk\"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]I/[onCreate While]: com.android.tools.fd.runtime.IncrementalClassLoader@1d4251eaI/[onCreate While]: java.lang.BootClassLoader@2f2e5cdb</code></pre></div></div><p>卧槽，怎么有三个，这跟文章说的只有两个不一样啊 - -，而且我也只听师兄说过PathClassLoader和BootClassLoader，没见过这个IncrementalClassLoader啊，它是什么鬼？</p><!--more--><p>随手一搜，<a href=\"http://www.cnblogs.com/coding-way/p/5443718.html\">一篇结果链接</a>，发现这是因为我用了 Instant Run 而出现的，再一想，嗯，Instant Run 本身也就是一种热修复的方式，思路就是把改动的地方打到dex里然后再用IncrementalClassLoader设置成app的ClassLoader的parent，即可拦截所有类加载的动作，从而实现动态增量加载。</p><h2 id=\"创建自己的classloader实例\">创建自己的ClassLoader实例</h2><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/**  * Constructs a new instance of this class with the system class loader as  * its parent.  */</span><span class=\"kd\">protected</span> <span class=\"nf\">ClassLoader</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">getSystemClassLoader</span><span class=\"o\">(),</span> <span class=\"kc\">false</span><span class=\"o\">);</span><span class=\"o\">}</span><span class=\"cm\">/**  * Constructs a new instance of this class with the specified class loader  * as its parent.  *  * @param parentLoader  *            The {@code ClassLoader} to use as the new class loader's  *            parent.  */</span><span class=\"kd\">protected</span> <span class=\"nf\">ClassLoader</span><span class=\"o\">(</span><span class=\"nc\">ClassLoader</span> <span class=\"n\">parentLoader</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">parentLoader</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span><span class=\"o\">}</span><span class=\"cm\">/*  * constructor for the BootClassLoader which needs parent to be null.  */</span><span class=\"nc\">ClassLoader</span><span class=\"o\">(</span><span class=\"nc\">ClassLoader</span> <span class=\"n\">parentLoader</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">nullAllowed</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">parentLoader</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">nullAllowed</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">NullPointerException</span><span class=\"o\">(</span><span class=\"s\">\"parentLoader == null &amp;&amp; !nullAllowed\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span>    <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">parentLoader</span><span class=\"o\">;</span><span class=\"o\">}</span></code></pre></div></div><p>文章提到</p><blockquote>  <p>整个Android系统里所有的ClassLoader实例都会被一棵树关联起来，这也是ClassLoader的 双亲代理模型（Parent-Delegation Model）的特点。</p></blockquote><p>没提到的是，ClassLoader有三个构造器，根节点的BootClassLoader自然就是不需要parent的，如注释所写</p><h2 id=\"使用classloader一些需要注意的问题\">使用ClassLoader一些需要注意的问题</h2><blockquote>  <p>在Java中，只有当两个实例的类名、包名以及加载其的ClassLoader都相同，才会被认为是同一种类型。故，不可用与「加载旧类的ClassLoader」没有树的继承关系的「另一个ClassLoader」来加载新类，会出现类型不符合的异常。</p></blockquote><h2 id=\"dexclassloader-和-pathclassloader\">DexClassLoader 和 PathClassLoader</h2><blockquote>  <p>DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；  PathClassLoader只能加载系统中已经安装过的apk；</p></blockquote><blockquote>  <p>optimizedDirectory必须是一个内部存储路径，还记得我们之前说过的，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。</p></blockquote><h2 id=\"加载类的过程\">加载类的过程</h2><p>ClassLoader.loadClass() -&gt; BaseDexClassLoader.findClass() -&gt; DexPathList-&gt;findClass()</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"nc\">Class</span> <span class=\"nf\">findClass</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"nc\">Element</span> <span class=\"n\">element</span> <span class=\"o\">:</span> <span class=\"n\">dexElements</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"nc\">DexFile</span> <span class=\"n\">dex</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">.</span><span class=\"na\">dexFile</span><span class=\"o\">;</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dex</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"nc\">Class</span> <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">dex</span><span class=\"o\">.</span><span class=\"na\">loadClassBinaryName</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">definingContext</span><span class=\"o\">);</span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                    <span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span>                <span class=\"o\">}</span>            <span class=\"o\">}</span>        <span class=\"o\">}</span>        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>    <span class=\"o\">}</span><span class=\"kd\">public</span> <span class=\"nc\">Class</span> <span class=\"nf\">loadClassBinaryName</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">loader</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">return</span> <span class=\"nf\">defineClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">loader</span><span class=\"o\">,</span> <span class=\"n\">mCookie</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"kd\">private</span> <span class=\"kd\">native</span> <span class=\"kd\">static</span> <span class=\"nc\">Class</span> <span class=\"nf\">defineClass</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"nc\">ClassLoader</span> <span class=\"n\">loader</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">cookie</span><span class=\"o\">);</span></code></pre></div></div><h2 id=\"参考资料\">参考资料</h2><p>本系列为笔记文，文中有大量的源码解析都是引用的其他作者的成果，详见下方参考资料。</p><ul>  <li>https://zhuanlan.zhihu.com/p/20524252</li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2016/09/18/plugadget-note-1-classloader",
            
            
            
            "tags": ["Android","插件化"],
            
            "date_published": "2016-09-18T00:00:00+00:00",
            "date_modified": "2016-09-18T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2015/02/10/theme-color-for-chrome-on-lollipop",
            "title": "Android 5.0 以上 Chrome AppBar 颜色定制",
            "summary": null,
            "content_text": "放假在家用回了 Nexus 4，在 Lollipop 作为日常系统使用一段时间后，发现了一个有意思的东西。如下图，正常情况下使用 Chrome 浏览网站时，多任务的预览界面上，Chrome 的 App bar 是灰色一片。而其背后的知乎、Gmail因为设定了 colorPrimary 而极具辨识度。未开启“合并标签页和应用”的界面 / 开启后的界面 / Overview但是在浏览 V2EX 时发现，Chrome的 App bar 竟然不是之前的灰色,类似的情况出现在 Android Police 和 但大的博客。V2EX / @但丁不淡定 的博客 / Overview查了一发 Chrome 的更新历史，发现只要满足以下条件，即可定义 Overview App Bar 颜色，同时也影响了 Chrome 内的 toolbar / statusbar 颜色。      系统要求 Android 5.0 以上    未开启“合并标签页和应用” 的 Chrome 39 以上    在网站&lt;head&gt;中添加自定义主题颜色&lt;meta name=\"theme-color\" content=\"#262a30\"&gt;  本站使用的颜色及效果随着 Lollipop 的普及以及默认 Chrome 浏览器的支持，相信这个特性会得到越来越多的网站支持，带来原生应用般辨识度的同时也增添了网站的个性。欢迎关注我的公众号和微博。",
            "content_html": "<p>放假在家用回了 Nexus 4，在 Lollipop 作为日常系统使用一段时间后，发现了一个有意思的东西。如下图，正常情况下使用 Chrome 浏览网站时，多任务的预览界面上，Chrome 的 App bar 是灰色一片。而其背后的知乎、Gmail因为设定了 colorPrimary 而极具辨识度。</p><p><img src=\"https://ww1.sinaimg.cn/large/005YhI8igy1fvhj8eowjjj31kw0vp7az\" alt=\"未开启“合并标签页和应用”的界面，开启后的界面，Overview界面。\" /></p><div style=\"text-align:center;\"><i>未开启“合并标签页和应用”的界面 / 开启后的界面 / Overview</i></div><!--more--><p>但是在浏览 V2EX 时发现，Chrome的 App bar 竟然不是之前的灰色,类似的情况出现在 Android Police 和 但大的博客。</p><p><img src=\"https://ww1.sinaimg.cn/large/005YhI8igy1fvhj8v269oj31kw0vp7a6\" alt=\"V2EX / @但丁不淡定 的博客 / Overview\" /></p><div style=\"text-align:center;\"><i>V2EX / @但丁不淡定 的博客 / Overview</i></div><p>查了一发 Chrome 的更新历史，发现只要满足以下条件，即可定义 Overview App Bar 颜色，同时也影响了 Chrome 内的 toolbar / statusbar 颜色。</p><blockquote>  <ol>    <li>系统要求 Android 5.0 以上</li>    <li>未开启“合并标签页和应用” 的 Chrome 39 以上</li>    <li>在网站<code class=\"language-plaintext highlighter-rouge\">&lt;head&gt;</code>中添加自定义主题颜色<code class=\"language-plaintext highlighter-rouge\">&lt;meta name=\"theme-color\" content=\"#262a30\"&gt;</code></li>  </ol></blockquote><p><img src=\"http://engineering-blog-2bab.qiniudn.com/theme-color-2bab.jpg\" alt=\"本站的效果\" /></p><div style=\"text-align:center;\"><i>本站使用的颜色及效果</i></div><p>随着 Lollipop 的普及以及默认 Chrome 浏览器的支持，相信这个特性会得到越来越多的网站支持，带来原生应用般辨识度的同时也增添了网站的个性。</p><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2015/02/10/theme-color-for-chrome-on-lollipop",
            
            
            
            "tags": ["Android","Chrome"],
            
            "date_published": "2015-02-10T00:00:00+00:00",
            "date_modified": "2015-02-10T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://2bab.me//2015/02/09/app-cannot-be-uninstalled",
            "title": "无法卸载的 App - 设备管理器漏洞",
            "summary": null,
            "content_text": "前两天某朋友发现手机有个app无法卸载，后知其因设备管理器激活导致，遂去尝试取消，但却在取消那刻卡机。反复折腾之后，只能重刷。后来他发了一篇关于设备管理器bug的文章给我，便有了如下一番折腾。##尝鲜文章《Android 学习 设备管理器勾选后不能再取消了》（作者：带个回家）大致意思是：  继承 DeviceAdminReceiver 重写 onDisableRequested(Context context, Intent intent) 即可达到目的。@Overridepublic CharSequence onDisableRequested(Context context, Intent intent) {    // 这里处理 不可编辑设备。    Intent intent2 = new Intent(context, NoticeSetting.class);    intent2.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);    context.startActivity(intent2);    context.stopService(intent);// 是否可以停止    return \"\"; // \"这是一个可选的消息，警告有关禁止用户的请求\";    }在此之前，我并没有接触过设备管理器的功能，参考了 API Guides 的 Device Administration ，以及 DeviceAdminReceiver 的 API 后，试着写了一个跟上述文章一样的 app，4.4 &amp; 5.0均测试失败，可以正常取消激活。##再战搜索，找到《Android设备管理器漏洞》（作者：Jack_Jia）另一篇讲解此问题的文章。文章提到：  如果想在设备管理器列表中”隐身“，只要不注册 android.app.action.DEVICE_ADMIN_ENABLED 广播就行。也就是不给 intent-filter 标签设置该 action。&lt;receiver    android:name=\".MyDeviceReceiver\"    android:description=\"@string/receiver_description\"    android:label=\"@string/app_name\"    android:permission=\"android.permission.BIND_DEVICE_ADMIN\"&gt;    &lt;meta-data        android:name=\"android.app.device_admin\"        android:resource=\"@xml/device_manager_policies\" /&gt;    &lt;intent-filter&gt;        &lt;/intent-filter&gt;&lt;/receiver&gt;4.4 &amp; 5.0测试失败，设备管理器无法激活（代码激活不会弹出，设备管理器又找不到）。##三战继续搜索，发现百度安全实验室一篇文章《Android设备管理器漏洞2》。文章提到：  已激活设备管理器权限的手机木马利用该漏洞，可以在设置程序的设备管理器列表中隐藏，这样用户就无法通过正常途径取消该手机木马的设备管理器权限，从而达到无法卸载的目的。Android4.2版本以上系统已经修复该漏洞。  …  通过调用stopAppSwitch()方法，系统保证在进入取消设备管理器界面后，5秒内不会进行Activity的切换。  …  onDisableRequested函数满足以下条件即可：  1、返回内容不能为空，这样才可以使设备管理器弹出取消激活设备管理器警示信息 Dialog。  2、通过Activity切换的方式使设备管理器弹出的警示信息Dialog消失。使用户无法操作Dialog。如果做到以上两点，程序即可成功阻止用户取消激活设备管理器操作。故，只要在 onDisableRequested 方法中，让用户在取消激活时5s内无法操作界面，然后采取 Activity 切换的方法即可绕开取消激活的步骤。这里为了测试直观并且试一试设备管理器的 api，采用了百度提供的连续锁屏法。测试环境为5.0。public CharSequence onDisableRequested(Context context, Intent intent) {                                                                                                                                                                    //跳离当前询问是否取消激活的 dialog                                                                                              Intent outOfDialog = context.getPackageManager().getLaunchIntentForPackage(\"com.android.settings\");                 outOfDialog.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                                                                context.startActivity(outOfDialog);                                                                                                                                                                                                     //调用设备管理器本身的功能，每 100ms 锁屏一次，用户即便解锁也会立即被锁，直至 7s 后                                                                    final DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);      dpm.lockNow();                                                                                                      new Thread(new Runnable() {                                                                                             @Override                                                                                                           public void run() {                                                                                                     int i = 0;                                                                                                          while (i &lt; 70) {                                                                                                        dpm.lockNow();                                                                                                      try {                                                                                                                   Thread.sleep(100);                                                                                                  i++;                                                                                                            } catch (InterruptedException e) {                                                                                      e.printStackTrace();                                                                                            }                                                                                                               }                                                                                                               }                                                                                                               }).start();                                                                                                                                                                                                                             return \"\";                                                                                                      }                                                                                                                         安装后打开直接跳转激活界面：        一旦激活则无法正常卸载        进入设备管理器界面        尝试取消激活        强制进入锁屏  至此，用户用普通方法无法卸载该app。测试使用某数字软件可以卸载，具体步骤：在数字软件的软件卸载功能中卸载Trick，此时提示取消激活，跳转到设备管理器界面取消激活，引发锁屏，强制锁屏7s结束后，切回数字软件，你会发现出现了取消激活的dialog，点击取消成功。而文章开头提到的流氓软件，实则是跳转到一个所有按钮无效的自定义全屏界面（不是我这样跳到设置界面），使用数字软件无法解决问题。##总结日后看到设备管理器激活申请定要小心三分，本文提及内容请勿不正当使用。##相关下载  源码Gist  测试APK，安装后激活则无法卸载。  恢复APK，覆盖安装后可顺利取消激活。欢迎关注我的公众号和微博。",
            "content_html": "<p>前两天某朋友发现手机有个app无法卸载，后知其因设备管理器激活导致，遂去尝试取消，但却在取消那刻卡机。反复折腾之后，只能重刷。后来他发了一篇关于设备管理器bug的文章给我，便有了如下一番折腾。</p><p>##<strong>尝鲜</strong></p><p>文章<a href=\"http://androidmaster.iteye.com/blog/2035381\">《Android 学习 设备管理器勾选后不能再取消了》</a>（作者：带个回家）大致意思是：</p><blockquote>  <p>继承 DeviceAdminReceiver 重写 onDisableRequested(Context context, Intent intent) 即可达到目的。</p></blockquote><!-- more --><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Override</span><span class=\"kd\">public</span> <span class=\"nc\">CharSequence</span> <span class=\"nf\">onDisableRequested</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">,</span> <span class=\"nc\">Intent</span> <span class=\"n\">intent</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// 这里处理 不可编辑设备。</span>    <span class=\"nc\">Intent</span> <span class=\"n\">intent2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Intent</span><span class=\"o\">(</span><span class=\"n\">context</span><span class=\"o\">,</span> <span class=\"nc\">NoticeSetting</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">);</span>    <span class=\"n\">intent2</span><span class=\"o\">.</span><span class=\"na\">setFlags</span><span class=\"o\">(</span><span class=\"nc\">Intent</span><span class=\"o\">.</span><span class=\"na\">FLAG_ACTIVITY_NEW_TASK</span><span class=\"o\">);</span>    <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">startActivity</span><span class=\"o\">(</span><span class=\"n\">intent2</span><span class=\"o\">);</span>    <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">stopService</span><span class=\"o\">(</span><span class=\"n\">intent</span><span class=\"o\">);</span><span class=\"c1\">// 是否可以停止</span>    <span class=\"k\">return</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span> <span class=\"c1\">// \"这是一个可选的消息，警告有关禁止用户的请求\";</span>    <span class=\"o\">}</span></code></pre></div></div><p>在此之前，我并没有接触过设备管理器的功能，参考了 API Guides 的 <a href=\"http://developer.android.com/guide/topics/admin/device-admin.html\">Device Administration</a> ，以及 <a href=\"http://developer.android.com/reference/android/app/admin/DeviceAdminReceiver.html\">DeviceAdminReceiver</a> 的 API 后，试着写了一个跟上述文章一样的 app，<strong>4.4 &amp; 5.0均测试失败，可以正常取消激活</strong>。</p><p>##<strong>再战</strong></p><p>搜索，找到<a href=\"http://blog.csdn.net/androidsecurity/article/details/9124747\">《Android设备管理器漏洞》</a>（作者：Jack_Jia）另一篇讲解此问题的文章。文章提到：</p><blockquote>  <p>如果想在设备管理器列表中”隐身“，只要不注册 <code class=\"language-plaintext highlighter-rouge\">android.app.action.DEVICE_ADMIN_ENABLED</code> 广播就行。</p></blockquote><p>也就是不给 <code class=\"language-plaintext highlighter-rouge\">intent-filter</code> 标签设置该 action。</p><div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;receiver</span>    <span class=\"na\">android:name=</span><span class=\"s\">\".MyDeviceReceiver\"</span>    <span class=\"na\">android:description=</span><span class=\"s\">\"@string/receiver_description\"</span>    <span class=\"na\">android:label=</span><span class=\"s\">\"@string/app_name\"</span>    <span class=\"na\">android:permission=</span><span class=\"s\">\"android.permission.BIND_DEVICE_ADMIN\"</span><span class=\"nt\">&gt;</span>    <span class=\"nt\">&lt;meta-data</span>        <span class=\"na\">android:name=</span><span class=\"s\">\"android.app.device_admin\"</span>        <span class=\"na\">android:resource=</span><span class=\"s\">\"@xml/device_manager_policies\"</span> <span class=\"nt\">/&gt;</span>    <span class=\"nt\">&lt;intent-filter&gt;</span>        <span class=\"nt\">&lt;/intent-filter&gt;</span><span class=\"nt\">&lt;/receiver&gt;</span></code></pre></div></div><p><strong>4.4 &amp; 5.0测试失败，设备管理器无法激活（代码激活不会弹出，设备管理器又找不到）。</strong></p><p>##<strong>三战</strong></p><p>继续搜索，发现百度安全实验室一篇文章<a href=\"http://safe.baidu.com/2014-10/deviceadminexploit2.html\">《Android设备管理器漏洞2》</a>。文章提到：</p><blockquote>  <p>已激活设备管理器权限的手机木马利用该漏洞，可以在设置程序的设备管理器列表中隐藏，这样用户就无法通过正常途径取消该手机木马的设备管理器权限，从而达到无法卸载的目的。Android4.2版本以上系统已经修复该漏洞。</p>  <p>…</p>  <p>通过调用stopAppSwitch()方法，系统保证在进入取消设备管理器界面后，<strong>5秒内不会进行Activity的切换。</strong></p>  <p>…</p>  <p>onDisableRequested函数满足以下条件即可：</p>  <p>1、返回内容不能为空，这样才可以使设备管理器弹出取消激活设备管理器警示信息 Dialog。</p>  <p>2、通过Activity切换的方式使设备管理器弹出的警示信息Dialog消失。使用户无法操作Dialog。如果做到以上两点，程序即可成功阻止用户取消激活设备管理器操作。</p></blockquote><p>故，只要在 onDisableRequested 方法中，让用户在取消激活时5s内无法操作界面，然后采取 Activity 切换的方法即可绕开取消激活的步骤。这里为了测试直观并且试一试设备管理器的 api，采用了百度提供的连续锁屏法。测试环境为5.0。</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"nc\">CharSequence</span> <span class=\"nf\">onDisableRequested</span><span class=\"o\">(</span><span class=\"nc\">Context</span> <span class=\"n\">context</span><span class=\"o\">,</span> <span class=\"nc\">Intent</span> <span class=\"n\">intent</span><span class=\"o\">)</span> <span class=\"o\">{</span>                                                                                                                                                                    <span class=\"c1\">//跳离当前询问是否取消激活的 dialog                                                                                          </span>    <span class=\"nc\">Intent</span> <span class=\"n\">outOfDialog</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getPackageManager</span><span class=\"o\">().</span><span class=\"na\">getLaunchIntentForPackage</span><span class=\"o\">(</span><span class=\"s\">\"com.android.settings\"</span><span class=\"o\">);</span>                 <span class=\"n\">outOfDialog</span><span class=\"o\">.</span><span class=\"na\">setFlags</span><span class=\"o\">(</span><span class=\"nc\">Intent</span><span class=\"o\">.</span><span class=\"na\">FLAG_ACTIVITY_NEW_TASK</span><span class=\"o\">);</span>                                                                <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">startActivity</span><span class=\"o\">(</span><span class=\"n\">outOfDialog</span><span class=\"o\">);</span>                                                                                                                                                                                                     <span class=\"c1\">//调用设备管理器本身的功能，每 100ms 锁屏一次，用户即便解锁也会立即被锁，直至 7s 后                                                                </span>    <span class=\"kd\">final</span> <span class=\"nc\">DevicePolicyManager</span> <span class=\"n\">dpm</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">DevicePolicyManager</span><span class=\"o\">)</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"na\">getSystemService</span><span class=\"o\">(</span><span class=\"nc\">Context</span><span class=\"o\">.</span><span class=\"na\">DEVICE_POLICY_SERVICE</span><span class=\"o\">);</span>      <span class=\"n\">dpm</span><span class=\"o\">.</span><span class=\"na\">lockNow</span><span class=\"o\">();</span>                                                                                                      <span class=\"k\">new</span> <span class=\"nf\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"nc\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>                                                                                             <span class=\"nd\">@Override</span>                                                                                                           <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>                                                                                                     <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>                                                                                                          <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">70</span><span class=\"o\">)</span> <span class=\"o\">{</span>                                                                                                        <span class=\"n\">dpm</span><span class=\"o\">.</span><span class=\"na\">lockNow</span><span class=\"o\">();</span>                                                                                                      <span class=\"k\">try</span> <span class=\"o\">{</span>                                                                                                                   <span class=\"nc\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"mi\">100</span><span class=\"o\">);</span>                                                                                                  <span class=\"n\">i</span><span class=\"o\">++;</span>                                                                                                            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>                                                                                      <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>                                                                                            <span class=\"o\">}</span>                                                                                                               <span class=\"o\">}</span>                                                                                                               <span class=\"o\">}</span>                                                                                                               <span class=\"o\">}).</span><span class=\"na\">start</span><span class=\"o\">();</span>                                                                                                                                                                                                                             <span class=\"k\">return</span> <span class=\"s\">\"\"</span><span class=\"o\">;</span>                                                                                                      <span class=\"o\">}</span>                                                                                                                   </code></pre></div></div><ol>  <li>    <p>安装后打开直接跳转激活界面：<img src=\"http://2bab-images.lastmayday.com/blog/2015-02-09-app-cannot-be-uninstalled-1.jpeg?imageslim\" alt=\"安装后打开直接跳转激活界面\" /></p>  </li>  <li>    <p>一旦激活则无法正常卸载<img src=\"http://2bab-images.lastmayday.com/blog/2015-02-09-app-cannot-be-uninstalled-2.jpeg?imageslim\" alt=\"一旦激活则无法正常卸载\" /></p>  </li>  <li>    <p>进入设备管理器界面<img src=\"http://2bab-images.lastmayday.com/blog/2015-02-09-app-cannot-be-uninstalled-3.jpeg?imageslim\" alt=\"进入设备管理器界面\" /></p>  </li>  <li>    <p>尝试取消激活<img src=\"http://2bab-images.lastmayday.com/blog/2015-02-09-app-cannot-be-uninstalled-4.jpeg?imageslim\" alt=\"尝试取消激活\" /></p>  </li>  <li>    <p>强制进入锁屏<img src=\"http://2bab-images.lastmayday.com/blog/2015-02-09-app-cannot-be-uninstalled-5.jpeg?imageslim\" alt=\"强制进入锁屏\" /></p>  </li></ol><p>至此，用户用普通方法无法卸载该app。测试使用某数字软件可以卸载，具体步骤：在数字软件的软件卸载功能中卸载Trick，此时提示取消激活，跳转到设备管理器界面取消激活，引发锁屏，强制锁屏7s结束后，切回数字软件，你会发现出现了取消激活的dialog，点击取消成功。</p><p>而文章开头提到的流氓软件，实则是跳转到一个所有按钮无效的自定义全屏界面（不是我这样跳到设置界面），使用数字软件无法解决问题。</p><p>##<strong>总结</strong></p><p>日后看到设备管理器激活申请定要小心三分，本文提及内容请勿不正当使用。</p><p>##<strong>相关下载</strong></p><ul>  <li><a href=\"https://gist.github.com/2BAB/786513de79b7bfd82c3f\">源码Gist</a></li>  <li><a href=\"http://engineering-blog-2bab.qiniudn.com/DeviceAdmin-DeviceAdminTrick.apk\">测试APK</a>，安装后激活则无法卸载。</li>  <li><a href=\"http://engineering-blog-2bab.qiniudn.com/DeviceAdmin-recovery.apk\">恢复APK</a>，覆盖安装后可顺利取消激活。</li></ul><p><em>欢迎关注我的<a href=\"/about\">公众号和微博</a>。</em></p>",
            "url": "https://2bab.me//2015/02/09/app-cannot-be-uninstalled",
            
            
            
            
            
            "date_published": "2015-02-09T00:00:00+00:00",
            "date_modified": "2015-02-09T00:00:00+00:00",
            
                "author":  {
                "name": "2BAB",
                "url": "https://2bab.me/",
                "avatar": null
                }
                
            
        }
    
    ]
}