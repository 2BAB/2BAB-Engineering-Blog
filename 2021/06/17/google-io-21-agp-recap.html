<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="继往开来：Google I/O 21 Android Gradle Plugin 更新总结" /><meta name="author" content="2BAB" /><meta property="og:locale" content="en_US" /><meta name="description" content="距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。" /><meta property="og:description" content="距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。" /><link rel="canonical" href="https://2bab.me//2021/06/17/google-io-21-agp-recap" /><meta property="og:url" content="https://2bab.me//2021/06/17/google-io-21-agp-recap" /><meta property="og:site_name" content="2BAB’s Engineering Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-17T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="继往开来：Google I/O 21 Android Gradle Plugin 更新总结" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@2BAB" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"2BAB","url":"https://2bab.me/"},"dateModified":"2021-06-17T00:00:00+00:00","datePublished":"2021-06-17T00:00:00+00:00","description":"距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。","headline":"继往开来：Google I/O 21 Android Gradle Plugin 更新总结","mainEntityOfPage":{"@type":"WebPage","@id":"https://2bab.me//2021/06/17/google-io-21-agp-recap"},"url":"https://2bab.me//2021/06/17/google-io-21-agp-recap"}</script><title> 继往开来：Google I/O 21 Android Gradle Plugin 更新总结 - 2BAB&#39;s Engineering Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="2BAB's Engineering Blog" href="/atom.xml"><link rel="alternate" type="application/json" title="2BAB's Engineering Blog" href="https://2bab.me//feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.6;font-size:1.1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}p code{background:#f0f0f0;padding-left:0.2rem;padding-right:0.2rem}code{padding:.1rem}pre code{border:none}pre{border:1px solid #eee;padding:1rem;overflow-x:auto}blockquote{overflow-x:auto}table{display:inline-block;overflow:auto;border-collapse:collapse}table tr th,table tr td{border:1px solid #eee;padding:0.5rem}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:1rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}body{font-size:1rem}header{padding:0rem}section{padding:1rem 0 0 0}.post ul{margin-left:1rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.highlight .hll{background-color:#ffffcc}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{color:#000000;font-weight:bold}.highlight .o{color:#000000;font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold;font-style:italic}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#ffdddd}.highlight .ge{color:#000000;font-style:italic}.highlight .gr{color:#aa0000}.highlight .gh{color:#999999}.highlight .gi{color:#000000;background-color:#ddffdd}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaaaaa}.highlight .gt{color:#aa0000}.highlight .kc{color:#000000;font-weight:bold}.highlight .kd{color:#000000;font-weight:bold}.highlight .kn{color:#000000;font-weight:bold}.highlight .kp{color:#000000;font-weight:bold}.highlight .kr{color:#000000;font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#009999}.highlight .s{color:#d01040}.highlight .na{color:#008080}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:#008080}.highlight .nd{color:#3c5d5d;font-weight:bold}.highlight .ni{color:#800080}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nl{color:#990000;font-weight:bold}.highlight .nn{color:#555555}.highlight .nt{color:#000080}.highlight .nv{color:#008080}.highlight .ow{color:#000000;font-weight:bold}.highlight .w{color:#bbbbbb}.highlight .mf{color:#009999}.highlight .mh{color:#009999}.highlight .mi{color:#009999}.highlight .mo{color:#009999}.highlight .sb{color:#d01040}.highlight .sc{color:#d01040}.highlight .sd{color:#d01040}.highlight .s2{color:#d01040}.highlight .se{color:#d01040}.highlight .sh{color:#d01040}.highlight .si{color:#d01040}.highlight .sx{color:#d01040}.highlight .sr{color:#009926}.highlight .s1{color:#d01040}.highlight .ss{color:#990073}.highlight .bp{color:#999999}.highlight .vc{color:#008080}.highlight .vg{color:#008080}.highlight .vi{color:#008080}.highlight .il{color:#009999}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">2BAB's Engineering Blog</h1>--><nav role="navigation"><ul><li><a href="/" >文章</a></li><li><a href="https://binary.2bab.me/" >播客</a></li><li><a href="/about" >关于</a></li><li><a href="/search" >搜索</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>继往开来：Google I/O 21 Android Gradle Plugin 更新总结</h2><p>距离 Google I/O 2021 已经过去了将近一个月，最近几天捋了捋关于 Android Gradle Plugin（AGP）方面的东西，主要集中在 “What’s new in Android Gradle plugin” 这个 session。不过由于 2020 年没有 Google I/O，线下的活动也因为疫情全部暂停，所以这个 session 短短 11 分钟，信息量却相当大，几乎可当作是这两年更新的重点浓缩（前后看了三遍）。也因此，这篇文章里我会放出很多额外的参考资料，挖了下最近一两年大家可能忽略了的 talks/posts/repos。文章整体脉络仍按这个 session 的 agenda 来。</p><h2 id="性能提升">性能提升</h2><h3 id="configuration-cache">Configuration Cache</h3><p>Gradle 的生命周期分为大的三个部分：初始化阶段（Initialization Phase)，配置阶段（Configuration Phase），执行阶段（Execution Phase）。其中任务执行的部分只要处理恰当，已经能够很好的进行缓存和重用——重用已有的缓存是加快编译速度十分关键的一环，如果把这个机制运用到其他阶段当然也能带来一些收益。仅次于执行阶段耗时的一般是配置阶段，而今年 AGP 给我们带来的 Gradle <a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:requirements">Configuration Cache</a> 的支持，一项自 <a href="https://blog.gradle.org/introducing-configuration-caching">Gradle 6.6</a> 起开始孵化的新功能。它使得配置阶段的主要产出物——Task Graph 可以被重用，在示例的项目中这个优化可以带来 8s 左右的不必要等待（如果 Gradle 脚本配置并没有改变）。</p><p><img src="https://2bab-images.lastmayday.com/blog/20210617155730.png?imageslim" alt="" /></p><p>想体验这项优化只需要在执行 Gradle 命令时加入 <code class="language-plaintext highlighter-rouge">--configuration-cache</code>，例如 <code class="language-plaintext highlighter-rouge">./gradlew --configuration-cache help</code>。由于 Configuration Cache 现在还未完全稳定，如果你想一直开启（包括享受 IDE Sync 时的优化），需要使用如下 properties：</p><div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">org.gradle.unsafe.configuration-cache</span><span class="p">=</span><span class="s">true</span>
</code></pre></div></div><p>第一次使用时会看到计算 Task Graph 的提示：</p><blockquote><p>Calculating task graph as no configuration cache is available for tasks: :test-app:assembleDebug</p></blockquote><p>成功后会在 Build 结束时提示：</p><blockquote><p>Configuration cache entry stored.</p></blockquote><p>之后 Cache 就可以被下一次构建复用（如果没有构建脚本修改）：</p><blockquote><p>Reusing configuration cache.</p><p>…</p><p>51 actionable tasks: 2 executed, 49 up-to-date</p><p>Configuration cache entry reused.</p></blockquote><p>作为插件使用者，发现常用插件出现不支持的情况，可先搜索是否有相同的问题已经出现，例如下面这个 Kotlin 1.4.32 插件和 Gradle 7.0 配合时出现的问题：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-kotlin-plugin.png?imageslim" alt="" /></p><p>在这个 YouTrack <a href="https://youtrack.jetbrains.com/issue/KT-43605">issue</a> 下我们可以简单看到通过升级 Kotlin 插件版本至 1.5.0 以上即可解决。</p><p>事实上 AGP/Kotlin/Gradle 核心的几个插件（主要是背后的 Tasks）在最近的版本都已经支持 Configuration Cache，通过这几篇文档/issue 可以了解大概：</p><ul><li><a href="https://github.com/gradle/gradle/issues/13490">Help community Gradle plugins adopt the configuration cache #13490 - Gradle Github Issues</a></li><li><a href="https://developer.android.com/studio/releases/gradle-plugin#4.2-gradle-properties">Gradle Properties Change - Android Gradle Plugin 4.2 Release Note</a></li><li><a href="https://kotlinlang.org/docs/gradle.html#gradle-configuration-cache-support">Gradle Configuration Cache Support - Kotlin Doc</a></li></ul><p>而作为插件开发者，则还要关心 Configuration Cache 的适配工作。其重点在于：Task 的参数和内部实现需要避开直接传入/使用 Gradle 的几个 Context 及一些无法序列化的类。以我维护的 <a href="https://github.com/2BAB/Seal">Seal</a> 插件为例，它是一个解决 <code class="language-plaintext highlighter-rouge">AndroidManifest.xml</code> 冲突的小插件，我们执行 <code class="language-plaintext highlighter-rouge">/gradlew --configuration-cache :test-app:assembleDebug</code> 会发现有两个问题待修复：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-seal-plugin.png?imageslim" alt="" /></p><p>通过构建结束时输出的 Configuration Cache HTML Report 我们可以查看到详细的堆栈：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-error-html.png?imageslim" alt="" /></p><p>针对这个错误，其实仅仅需要把 <code class="language-plaintext highlighter-rouge">project.logger</code> 改成 <code class="language-plaintext highlighter-rouge">this.logger</code> 的引用即可：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-config-cache-git-change.png?imageslim" alt="" /></p><p>对于更复杂的规则和用例，可以参考 Gradle 的文档以及 AGP 兼容 Configuration Cache 的心路历程（修复了 400 多个 issues）：</p><ul><li><a href="https://docs.gradle.org/current/userguide/configuration_cache.html#config_cache:requirements">Configuration Cache</a></li><li><a href="https://medium.com/androiddevelopers/configuration-caching-deep-dive-bcb304698070">Configuration caching deep dive - Android Developers</a></li></ul><p>最后，有个 Gradle 官方维护的 <a href="https://github.com/gradle/android-cache-fix-gradle-plugin">android-cache-fix-gradle-plugin</a> ，一些 AGP build cache、configuration cache 的特殊问题，可以在此处查阅下，说不定正好是你项目碰到的。</p><h3 id="non-transitive-r-classes">Non-transitive R-classes</h3><p>事实上 R 文件的这类特性已经发展了很多年，可以参考这篇按时间顺序整理的<a href="https://www.mobileit.cz/Blog/Pages/r-class.aspx">文章</a>。但是最新的 <code class="language-plaintext highlighter-rouge">nonTransitiveAppRClass</code> 特性需要 AGP 7.0 及以上，目前资料较少，在 Android Studio Arctic Fox 版本发布说明中有部分提及：</p><blockquote><p>非传递性 R 类重构：在 Android Gradle 插件中使用非传递性 (non-transitive) R 类，可以为具有多个模块的应用带来更快的构建速度。它通过确保每个模块只包含对其自身资源的引用，而不从依赖关系中提取引用来防止资源的重复。您可以通过重构 (Refactor) &gt; 迁移到非传递性 R 类 (Migrate to Non-transitive R Classes) 来使用此功能。</p></blockquote><p>开启方式如下：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-non-transitive-r-as-refactor2.png?imageslim" alt="" /></p><p>这个操作帮助你自动添加两行特性开启的代码到 <code class="language-plaintext highlighter-rouge">gradle.properties</code>，并重新 build project：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-non-transitive-r-properties.png?imageslim" alt="" /></p><h3 id="cacheable-lint-task">Cacheable Lint Task</h3><p>Lint 的运行一直是耗时大户，在 AGP 7.0 后（最早计划于是 3.5，见这篇<a href="https://docs.gradle.org/current/userguide/caching_android_projects.html#lint">文档</a>），终于正式成为可缓存的 Task。</p><h3 id="其他">其他</h3><p>另外 AS + AGP 自 4.x 以来还有一些提升的点：</p><ul><li>Gradle Kotlin DSL 体验和性能提升，可以看到 <a href="https://github.com/google/iosched">Google I/O Android App</a> 项目已经全部改成 <code class="language-plaintext highlighter-rouge">*.gradle.kts</code> 脚本；</li><li>AAPT2 的性能提升；</li><li>JDK 11 引入的性能提升；</li><li>…</li></ul><p>可以在 AGP/AS 的 Release Notes 里找到这些信息。</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-new-as-bumblebee.png?imageslim" alt="" /></p><h2 id="新的-dsl">新的 DSL</h2><h3 id="dsl-doc-迁移至-androidcom">DSL Doc 迁移至 android.com</h3><p>旧的 AGP DSL <a href="https://google.github.io/android-gradle-dsl/">文档</a> 从 3.4 之后就不再更新了。新的文档迁移至 <a href="https://developer.android.com/reference/tools/gradle-api">android.com</a>，更加统一。依旧可按版本查看：</p><ul><li>当前版本（Current Release）：即稳定版本 4.2；</li><li>预览版本（Preview Releases）：即 beta 7.0 和 alpha 7.1 测试版；</li><li>之前的版本（Past Releases）：即之前所有的老版本，但由于中间的更迭/切换，所以其实 3.5 -&gt; 4.0 版本的文档都没有；</li></ul><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-dsl-doc.png?imageslim" alt="" /></p><p>这个变化也反映在了 <a href="https://android.googlesource.com/platform/manifest/+refs">google source</a> 的 tag 上，对于 AGP 源码来说 <code class="language-plaintext highlighter-rouge">gradle-x.y.z</code> 的 tag 自 3.4.0 之后就没有了，目前你可以使用 <code class="language-plaintext highlighter-rouge">studio-x.y.z</code> 例如 <code class="language-plaintext highlighter-rouge">studio-4.2.0</code> 来反向定位 AGP 的版本。</p><h3 id="android-studio-提供的-agp-升级助手">Android Studio 提供的 AGP 升级助手</h3><p>为了让开发者便捷流畅地升级 AGP，AGP 配合 AS 的推出了升级助手功能。这个新特性已经迭代了几个版本，目前对 Gradle Groovy DSL 脚本的升级十分有用，当你看到升级提示时（一般发生在刚打开一个工程时）：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant.png?imageslim" alt="" /></p><p>点击 <code class="language-plaintext highlighter-rouge">Upgrade</code> 还会有预览功能（截图自 session 的 slide）：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant-2.png?imageslim" alt="" /></p><p>不过对于 Gradle Kotlin DSL 的支持还有待补齐，例如基础的 <code class="language-plaintext highlighter-rouge">compileSdkVersion</code> 等废弃 DSL 的迁移也未支持：</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-agp-upgrade-assistant-3.png?imageslim" alt="" /></p><p>当然，复杂的对象引用也无法帮你直接修改，例如 <code class="language-plaintext highlighter-rouge">classpath(Deps.agp)</code>，这已经超过该工具能做的范围。你可以把其当成类似 <code class="language-plaintext highlighter-rouge">Java</code> 转 <code class="language-plaintext highlighter-rouge">Kotlin</code> 的辅助工具，先用它快速升级和整理基础的 DSL，然后再手动对照 DSL 文档修改出错的小部分。</p><h2 id="新的-variant-api">新的 Variant API</h2><p>Variant API 是这两年 Android 与插件开发相关的最重要更新，如果之前没有针对 AGP 生态开发过协同插件的朋友可以通过下面这张图“了解什么是 Variant”？</p><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-variant-api-definition-2.png?imageslim" alt="" /></p><p>Variant API 的更新可以概括：为了使协同插件的开发者依赖于更稳定的 API，将原来的 <code class="language-plaintext highlighter-rouge">com.android.tools.build:gradle</code> 包拆分成 <code class="language-plaintext highlighter-rouge">gradle</code> 和 <code class="language-plaintext highlighter-rouge">gradle-api</code> 两个包，做到接口和实现的隔离。实战角度来看我们可以关注两部分：Variant 遍历入口变更和部分自定义 Task 的简化。</p><h3 id="variant-遍历入口变更">Variant 遍历入口变更</h3><p>大部分 AGP 生态的协同插件都需要注册 Variant aware 的 Task，即遍历 Variant 注册与其对应的自定义 Task，例如上面提到的 Seal 插件的 <code class="language-plaintext highlighter-rouge">postUpdateDebugManifest</code> <code class="language-plaintext highlighter-rouge">postUpdateReleaseManifest</code>。你一定看到过这样的代码（Groovy）：</p><pre><code class="language-Groovy">def android = project.extensions.android
android.applicationVariants.all { variant -&gt;
    def variantName = variant.name.capitalize()
    createTask(project, variantName)
}
</code></pre><p>或者 Kotlin 的版本：</p><pre><code class="language-Kotlin">val androidExtension = project.extensions.findByType(AppExtension::class.java)!!
androidExtension.applicationVariants.all { variant -&gt;
    val variantName = variant.name.capitalize()
    createTask(project, variantName)
}
</code></pre><p>如果是适用于 library 的插件则需要 <code class="language-plaintext highlighter-rouge">LibraryExtension</code> 和 <code class="language-plaintext highlighter-rouge">libraryVariants</code>。</p><p>这类 API 现在改成了 <code class="language-plaintext highlighter-rouge">gradle-api</code> 内的新 API 调用：</p><pre><code class="language-Kotlin">val androidExtension = project.extensions.getByType&lt;ApplicationAndroidComponentsExtension&gt;()
androidExtension.onVariants { variant -&gt;
    ...
}
</code></pre><p>这里获取到的 Variant 是 <a href="https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/variant/ApplicationVariant">com.android.build.api.variant.ApplicationVariant</a>，Extension 则来自于 <a href="https://developer.android.com/reference/tools/gradle-api/4.2/com/android/build/api/extension/ApplicationAndroidComponentsExtension">com.android.build.api.extension.ApplicationAndroidComponentsExtension</a>。另外一个可能会用到的接口是 <code class="language-plaintext highlighter-rouge">beforeVariants(...)</code>，用来控制 Variant 的构建，例如全局修改一些 Variant 的属性等。从这段 Snippet 我们可能看不出来 Variant 具体的变化，但这变化背后包含了规范的 Variant 状态流转，公开的 API 等。</p><h3 id="部分自定义-task-的简化">部分自定义 Task 的简化</h3><p>这类简化指 Task 插入点和 Task 参数获取（注入）的简化，提供这类特性的 API 也称之为 Artifact APIs。在比较经典的模式里：对于插入点，一般我们会手动找到 Task 的前后依赖关系，使用 Gradle API 进行依赖关系重新梳理（甚至可能要自定义一些新的生命周期锚点 Task 辅助）；对于 Task 的参数，就使出各种奇技淫巧，从已有 Task 里的参数/中间产物/私有对象等找到我们需要的数据，再注入到自定义的 Task 中。而现在 Artifact APIs 规范了一套标准操作，使得我们可以简易地和已有的数据、中间产物进行交互，实战角度来看我们可以分为两种模式：</p><p>复杂的 Transform/Append/Create 操作：插入 Task 到特定节点和 Task 参数注入一条龙服务，一般适用于需要定义某个具体的插入点；</p><pre><code class="language-Kotlin">androidComponents {
    val gitVersionProvider = tasks.register&lt;GitVersionTask&gt;("gitVersionProvider") {
        gitVersionOutputFile.set(
            File(project.buildDir, "intermediates/gitVersionProvider/output"))
        outputs.upToDateWhen { false }
    }
    onVariants { variant -&gt;
        val manifestProducer = tasks.register&lt;ManifestProducerTask&gt;("${variant.name}ManifestProducer") {
            gitInfoFile.set(gitVersionProvider.flatMap(GitVersionTask::gitVersionOutputFile))
        }
        variant.artifacts.use(manifestProducer)
            .wiredWith(ManifestProducerTask::outputManifest)
            .toCreate(SingleArtifact.MERGED_MANIFEST)
    }
}
</code></pre><p>纯粹的 Get：主动获取 intermediates，一般适用于较为独立的 Task，没有严苛的插入位置要求（但是藉由 Provider 的传递会有隐式的 Task 依赖），没有需要替换等操作：</p><pre><code class="language-Kotlin">androidComponents {
    onVariants { variant -&gt;
        project.tasks.register&lt;DisplayApksTask&gt;("${variant.name}DisplayApks") {
            apkFolder.set(variant.artifacts.get(SingleArtifact.APK))
            builtArtifactsLoader.set(variant.artifacts.getBuiltArtifactsLoader())
        }
    }
}
</code></pre><h3 id="更多">更多</h3><p>从实用的角度来说，新的 Variant 接口、Extension 接口公开的 API 比之前少了，但更加规范。Artifacts 作为手动获取 Task input/output 的补充，目前的公开 API 也还比较少，希望插件开发者们在遇到合理的需要公开的 API 但目前还没有时，给 AGP team 多提点 issue :)。</p><p>另外，限于篇幅我无法在这里介绍全部的 Variant API 更新，包括新的 <code class="language-plaintext highlighter-rouge">Provider&lt;T&gt;</code> API 引入（Lazy Configuration），Variant 状态流转，更多种的 Artifacts API 的使用，如何借鉴它的设计来自己动手解决那些还没有被封装、公开的接口等等。你可以从下面几份资料中获得更多的灵感：</p><ul><li><a href="https://www.youtube.com/watch?v=OTANozHzgPc">From Gradle properties to AGP APIs - Android Dev Summit ‘19</a>：讲解了 Variant API 的基石—— <code class="language-plaintext highlighter-rouge">Provider&lt;T&gt;</code> API 及其衍生的多个子类，Variant 状态流转及其 API 的多种使用姿势等；</li><li><a href="https://medium.com/androiddevelopers/new-apis-in-the-android-gradle-plugin-f5325742e614">New APIs in the Android Gradle Plugin - Android Developers Blog</a>：介绍了 Variant API 想法设计的由来，新 API 的使用；</li><li><a href="https://github.com/android/gradle-recipes/tree/agp-7.1">android/gradle-recipes</a>：分别提供了 Groovy/Kotlin DSL 下 Variant API 常用的示例代码；</li><li><a href="https://developer.android.com/studio/releases/gradle-plugin-roadmap">Android Gradle Plugin DSL/API migration timeline</a>：未来三年 New DSL 和 Variant API 相关的 milestone；</li><li><a href="https://docs.gradle.org/current/userguide/lazy_configuration.html">Lazy Configuration</a>：Task 配置延迟获取，<code class="language-plaintext highlighter-rouge">Provider&lt;T&gt;</code> 及其各种子类，Task 隐式依赖等。</li></ul><h2 id="新的-asm-api">新的 ASM API</h2><p><img src="https://2bab-images.lastmayday.com/blog/io-2021-asm-api.png?imageslim" alt="" /></p><p>ASM API 是之前 Transform API 的替代品，旨在更低成本地提供一个 Class -&gt; Dex 之间的插入点用以修改字节码。它没有了之前 Transform API 的灵活性，比如目前看起来它和 ASM 字节码工具是绑定的，不支持 Javassist 或者 Aspect 等。但同时，它拥有更好的性能，更低的使用成本（指实现 transform 本身，因为 ASM 实际上是相对 Javasssist Aspect 更底层的 API，更灵活、学习成本也更高），以及更容易适配 Gradle 的新特性。目前刚刚开始孵化，从 API Doc 来看还不推荐开发者使用它来构建一个生产环境的插件。</p><pre><code class="language-Kotlin">abstract class ExamplePlugin : Plugin&lt;Project&gt; {

    override fun apply(project: Project) {

        val androidComponents = project.extensions.getByType(AndroidComponentsExtension::class.java)

        androidComponents.onVariants { variant -&gt;
            variant.transformClassesWith(ExampleClassVisitorFactory::class.java,
                                 InstrumentationScope.ALL) {
                it.writeToStdout.set(true)
            }
            variant.setAsmFramesComputationMode(FramesComputationMode.COPY_FRAMES)
        }
    }

    interface ExampleParams : InstrumentationParameters {
        @get:Input
        val writeToStdout: Property&lt;Boolean&gt;
    }

    abstract class ExampleClassVisitorFactory :
        AsmClassVisitorFactory&lt;ExampleParams&gt; {

        override fun createClassVisitor(
            classContext: ClassContext,
            nextClassVisitor: ClassVisitor
        ): ClassVisitor {
            return if (parameters.get().writeToStdout.get()) {
                TraceClassVisitor(nextClassVisitor, PrintWriter(System.out))
            } else {
                TraceClassVisitor(nextClassVisitor, PrintWriter(File("trace_out")))
            }
        }

        override fun isInstrumentable(classData: ClassData): Boolean {
            return classData.className.startsWith("com.example")
        }
    }
}
</code></pre><p>上面代码用到的 API 可以参考如下说明：</p><ul><li><a href="https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/component/Component.html#transformClassesWith(java.lang.Class,%20com.android.build.api.instrumentation.InstrumentationScope,%20kotlin.Function1)">Component#transformClassesWith(…)</a></li><li><a href="https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/instrumentation/InstrumentationParameters">InstrumentationParameters</a></li></ul><p>对经典的 Transform 不熟悉的朋友可以看下几个知名的 Transform 库封装（挺巧都是中国公司的开源项目）：</p><ul><li><a href="https://github.com/bytedance/ByteX">ByteX</a>（活跃）</li><li><a href="https://github.com/didi/booster">Booster</a>（活跃，部分功能使用）</li><li><a href="https://github.com/eleme/lancet">Lancet</a>（不活跃）</li></ul><h2 id="总结">总结</h2><p>从开发者的角度来看，Android 工具团队在 AGP &amp; AS 上更加注重 Engineering Experience 的东西了。在解决了很多历史遗留问题的同时，这次的 Session 还透露出对 AGP 周边生态的建设的长远计划，希望明年可以看到这些东西真的被更多 Android 开发者接受，到时候我也一定再写一篇 22 年版的总结和前瞻。</p><p><em>欢迎关注我的<a href="/about"> Github / 公众号 / 微博 / Twitter</a>。</em></p><span class="meta"><time datetime="2021-06-17T00:00:00+00:00">June 17, 2021</time> &middot; <a href="/tag/Android">Android</a>, <a href="/tag/Gradle">Gradle</a>, <a href="/tag/Android Gradle Plugin">Android Gradle Plugin</a>, <a href="/tag/构建">构建</a></span> <!--<span class="meta"><time datetime="2021-06-17T00:00:00+00:00">June 17, 2021</time> &middot; <a class="post" href="/tag/Android">Android</a>, <a class="post" href="/tag/Gradle">Gradle</a>, <a class="post" href="/tag/Android Gradle Plugin">Android Gradle Plugin</a>, <a class="post" href="/tag/构建">构建</a></span> --></section></main></body><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91072395-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-91072395-1'); </script></html>
