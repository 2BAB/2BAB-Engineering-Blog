<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="构建指北 #12 根据 Variant 决定是否启用插件" /><meta name="author" content="2BAB" /><meta property="og:locale" content="en_US" /><meta name="description" content="在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。" /><meta property="og:description" content="在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。" /><link rel="canonical" href="https://2bab.me//2021/12/21/enable-feature-by-variant" /><meta property="og:url" content="https://2bab.me//2021/12/21/enable-feature-by-variant" /><meta property="og:site_name" content="2BAB’s Engineering Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-21T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="构建指北 #12 根据 Variant 决定是否启用插件" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@2BAB" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"2BAB","url":"https://2bab.me/"},"dateModified":"2021-12-21T00:00:00+00:00","datePublished":"2021-12-21T00:00:00+00:00","description":"在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。","headline":"构建指北 #12 根据 Variant 决定是否启用插件","mainEntityOfPage":{"@type":"WebPage","@id":"https://2bab.me//2021/12/21/enable-feature-by-variant"},"url":"https://2bab.me//2021/12/21/enable-feature-by-variant"}</script><title> 构建指北 #12 根据 Variant 决定是否启用插件 - 2BAB&#39;s Engineering Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="2BAB's Engineering Blog" href="/atom.xml"><link rel="alternate" type="application/json" title="2BAB's Engineering Blog" href="https://2bab.me//feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.6;font-size:1.1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}p code{background:#f0f0f0;padding-left:0.2rem;padding-right:0.2rem}code{padding:.1rem}pre code{border:none}pre{border:1px solid #eee;padding:1rem;overflow-x:auto}blockquote{overflow-x:auto}table{display:inline-block;overflow:auto;border-collapse:collapse}table tr th,table tr td{border:1px solid #eee;padding:0.5rem}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:1rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}body{font-size:1rem}header{padding:0rem}section{padding:1rem 0 0 0}.post ul{margin-left:1rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.highlight .hll{background-color:#ffffcc}.highlight .c{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k{color:#000000;font-weight:bold}.highlight .o{color:#000000;font-weight:bold}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold;font-style:italic}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .gd{color:#000000;background-color:#ffdddd}.highlight .ge{color:#000000;font-style:italic}.highlight .gr{color:#aa0000}.highlight .gh{color:#999999}.highlight .gi{color:#000000;background-color:#ddffdd}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaaaaa}.highlight .gt{color:#aa0000}.highlight .kc{color:#000000;font-weight:bold}.highlight .kd{color:#000000;font-weight:bold}.highlight .kn{color:#000000;font-weight:bold}.highlight .kp{color:#000000;font-weight:bold}.highlight .kr{color:#000000;font-weight:bold}.highlight .kt{color:#445588;font-weight:bold}.highlight .m{color:#009999}.highlight .s{color:#d01040}.highlight .na{color:#008080}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:#008080}.highlight .nd{color:#3c5d5d;font-weight:bold}.highlight .ni{color:#800080}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nl{color:#990000;font-weight:bold}.highlight .nn{color:#555555}.highlight .nt{color:#000080}.highlight .nv{color:#008080}.highlight .ow{color:#000000;font-weight:bold}.highlight .w{color:#bbbbbb}.highlight .mf{color:#009999}.highlight .mh{color:#009999}.highlight .mi{color:#009999}.highlight .mo{color:#009999}.highlight .sb{color:#d01040}.highlight .sc{color:#d01040}.highlight .sd{color:#d01040}.highlight .s2{color:#d01040}.highlight .se{color:#d01040}.highlight .sh{color:#d01040}.highlight .si{color:#d01040}.highlight .sx{color:#d01040}.highlight .sr{color:#009926}.highlight .s1{color:#d01040}.highlight .ss{color:#990073}.highlight .bp{color:#999999}.highlight .vc{color:#008080}.highlight .vg{color:#008080}.highlight .vi{color:#008080}.highlight .il{color:#009999}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">2BAB's Engineering Blog</h1>--><nav role="navigation"><ul><li><a href="/" >文章</a></li><li><a href="https://binary.2bab.me/" >播客</a></li><li><a href="/about" >关于</a></li><li><a href="/search" >搜索</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>构建指北 #12 根据 Variant 决定是否启用插件</h2><p>在 Android 开发中使用过第三方 Gradle 插件的同学都应该碰到过这个问题：<strong>我只想在某一些 buildType 或者 flavor 中应用这个插件，但是找不到合适的办法。</strong></p><p>这个问题的根本原因在于 Variant（buildType + flavor) 不是一个 Gradle 概念，而是源于 Android Gralde Plugin（AGP）的多渠道配置。所以从 Gradle 平台的角度很难向上提供便捷的支持：一个工程内的插件引入是全局的、平台性的，不以某一个插件的意志（AGP）而改变下层平台的机制。</p><p>OK，但我们的问题还是要解决的，所以便了有下面四种问题的解法（大雾。我们按照无效到高效的顺序一一解释其中的思路。</p><h2 id="根据-variant-去-apply-插件无效-x">根据 Variant 去 apply 插件（无效 X</h2><pre><code class="language-Kotlin">flavorDimensions += "server"
productFlavors {
    ...
    create("production") {
        dimension = "server"
        applicationIdSuffix = ".production"
        versionNameSuffix = "-production"
        versionCode = 2
        apply("xxx") // 无效
    }
}
</code></pre><p>很多 Android 或者 Gradle 的初学者会觉得，我把 <code class="language-plaintext highlighter-rouge">apply(...)</code> 放在这里不就好了？（当然，你肯定不能用 <code class="language-plaintext highlighter-rouge">plugins { id("xxx") }</code>）这里的误区在于，<strong><code class="language-plaintext highlighter-rouge">apply(...)</code> 方法和当前上下文对象并没有关联</strong>：</p><p><img src="https://2bab-images.lastmayday.com/20211221205845.png?imageslim" alt="" /></p><p><img src="https://2bab-images.lastmayday.com/20211221210042.png?imageslim" alt="" /></p><ul><li><code class="language-plaintext highlighter-rouge">create("..."){}</code> 的闭包上下文是 <code class="language-plaintext highlighter-rouge">this:ApplicationProductFlavor</code>。</li><li><code class="language-plaintext highlighter-rouge">apply(...)</code> 则为挂载于 PluginAware 的一个扩展方法（以 <code class="language-plaintext highlighter-rouge">build.gradle.kts</code>），作用于整个 Project，这样一来你的插件还是会被全局引入。</li></ul><p>同样的经典误区：</p><pre><code class="language-Kotlin">create("production") {
    dimension = "server"
    applicationIdSuffix = ".production"
    versionNameSuffix = "-production"
    versionCode = 2
    packagingOptions {
        jniLibs {
            excludes.add("...")
        }
    }
}
</code></pre><p><img src="https://2bab-images.lastmayday.com/20211221212514.png?imageslim" alt="" /> 你可能觉得这样可以为这个 flavor 设置单独的 <code class="language-plaintext highlighter-rouge">packageingOptions</code>，但实际上这个方法是 <code class="language-plaintext highlighter-rouge">CommonExtension</code> 接口的一个方法，并不属于 <code class="language-plaintext highlighter-rouge">ApplicationProductFlavor</code>。也即它是为整个 Android Gradle Plugin 进行设置，而不是单一 flavor，如果你在每个 flavor 中都进行不同的设置，最后一次的设置会覆盖前面所有的。针对这个问题的解决方法，可参考我之前 <a href="https://www.bilibili.com/video/BV1WP4y1G71h">GDG 分享</a>中的“二次配置”部分。</p><h2 id="根据命令去-apply-插件部分有效-x">根据命令去 apply 插件（部分有效 X</h2><p>我们本次讨论的问题在一些 StackOverflow 问答中也能查到，其中有大量的答案是关于“解析键入的命令”来进行判断。</p><pre><code class="language-Kotlin">if (gradle.startParameter.taskRequests.toString().contains("production")) {
    apply(...)
}
</code></pre><p>这种做法能够解决你输入的命令为 <code class="language-plaintext highlighter-rouge">./gradlew clean assembleProductionRelease</code> 等等的情况，因为这类命令中仅包含了一个 Variant 的信息（也就是 Production + Release）。然而如果输入的命令是 <code class="language-plaintext highlighter-rouge">./gradlew clean assembleRelease</code>，它同时打包 <code class="language-plaintext highlighter-rouge">Staging</code> 和 <code class="language-plaintext highlighter-rouge">Production</code> 两个 flavors，这时上面的 <code class="language-plaintext highlighter-rouge">if(...)</code> 条件就完全不成立，你的构建也会因此遭到破坏。</p><p>多数情况 <code class="language-plaintext highlighter-rouge">taskRequests</code> 下对第三方 Android 构建插件的开发者都是不应去获取和使用的，和第一条误区一样它是 Gradle 平台自身的 API，没有为上层 AGP 的 Variant 概念做优化。</p><h2 id="禁用对应-variant-的插件-task有效-y">禁用对应 Variant 的插件 Task（有效 Y</h2><p>当然，SO 上也有人提到了正确、有效、且通用的做法——<strong>不要动态禁用（或开启）插件，而是去禁用插件内的 Task。</strong></p><pre><code class="language-Kotlin">plugins { id("com.example.ua") }
// or apply("com.example.ua")
...
tasks.whenTaskAdded {
    if (name.contains("production", true)
            &amp;&amp; name.contains("release", true)
            &amp;&amp; name.contains("UploadArchive", true)) {
        enabled = false
    }
}
</code></pre><p>假设有一个上传构建结果的插件叫做 <code class="language-plaintext highlighter-rouge">com.example.ua</code>，我们不管什么情况，都在<code class="language-plaintext highlighter-rouge">build.gradle.kts</code> 内引用它。但是往下看，我们基于 <code class="language-plaintext highlighter-rouge">whenTaskAdded {...}</code> 做了类似上一条误区的 <code class="language-plaintext highlighter-rouge">if(...)</code> 判断，然后符合条件的 task 的 <code class="language-plaintext highlighter-rouge">enabled</code> 属性设置为 <code class="language-plaintext highlighter-rouge">false</code>。为什么上一个方法不行，而这个可以？</p><p>我们要复习下这条 Gradle 脚本和 <code class="language-plaintext highlighter-rouge">android{}</code> DSL 规则：不管你 shell 键入的命令是什么，你键入的是 <code class="language-plaintext highlighter-rouge">clean</code> 也好 <code class="language-plaintext highlighter-rouge">help</code> 也好，这份脚本都是会完整地被执行，所有 Variant 的 Task 都会被注册（当然现在通常都是惰性注册了 <code class="language-plaintext highlighter-rouge">register(...)</code> 而不用 <code class="language-plaintext highlighter-rouge">create()</code>）。<strong>而 <code class="language-plaintext highlighter-rouge">whenTaskAdded{...}</code> 是 Gradle 平台的 API，它才不管你上层注册的 Task 分不分 Variant，它只管把所有注册后且确定会添加进运行图（是个有向无环图 DAG）的 Task 在这里提供一个回调的时机给开发者。与此同时，几乎所有的 Android 生态协同插件都会基于 Variant 的名字去给自己 Task 命名（如果它需要是一个 VariantAware Task 的话），例如 “UploadArchiveWithLogForProductionRelease”。这个不成文的规则给了我们字符串匹配的机会，也即你看到的上述代码。</strong></p><p>对于插件怎么找到对应的所有 Task，目前没有自动化的办法，也没有 API（但是最近的一个 AGP Team Q&amp;A 上，他们提到在和 Gradle 推进这个功能）。你可以做的就是：<strong>引入插件前打印下 Task List，引入后再打印一遍，找二者的 Diff。</strong> 当然对于一些比较简单的插件，直接看下文档或者源码，整理下有哪几个 Task 也行。</p><p>所以这个方案小结下就一句话：总是引用插件，但禁用掉不需要的 Task。</p><h2 id="在-task-注册时拦截高效-y">在 Task 注册时拦截（高效 Y</h2><p>我在上一篇[《构建指北 #11 BundleTool Gradle Plugin》](https://2bab.me/2021/12/19/bundle-tool-plugin]中提到：</p><blockquote><p>bundle-tool-gradle-plugin 支持按不同 variant 渠道去开启插件的几个功能特性。</p></blockquote><p>这光听起来就和上一个方案就有点神似了，难不成就是把 <code class="language-plaintext highlighter-rouge">enabled = false</code> 藏 Plugin 里，再吐个 DSL 的开关配置出来给用户选择？其实不然，解决思路上已经大差不差了。但稍微思考下还有两个可以改进的空间：</p><ol><li>既然我们想要在插件内部控制开关，何必使用 <code class="language-plaintext highlighter-rouge">task.enabled = false</code>，<strong>直接把注册流程跳过就好了</strong>（当然，这个做法不适用于所有情况，有时候还是需要动态禁用的）。</li><li>对于大部分的 Android 生态协同插件，其 DSL 一般都是 Variant 无关的静态配置，如果要设计一个 Variant 有关的配置，可能只能传入一堆自定义 rules（如下代码）：</li></ol><pre><code class="language-Kotlin">// 静态的 DSL 配置
bundletool {
    enableByVariantRules {
        create("debugStaging") {
            enabledFeature1 = true
            enabledFeature2 = true
            enabledFeature3 = false
        }
        create("debugProduction") {
            ...
        }
    }
} 
</code></pre><p>这种 rules 的复杂度比较难控制，在上述代码里它是一个 2 * 2 * 3 的笛卡尔积，配置起来十分不变。解决的方法也很容易想到，<strong>如果它能做成传入一个 Kotlin Lambda（或者 Groovy Closure），不就很方便了？就像我们做二次配置时使用的 <code class="language-plaintext highlighter-rouge">onVariants(...) {...}</code> 方法一样，我们需要一些“动态”的东西，用户可以与之互动的东西，减少配置的复杂度。</strong></p><pre><code class="language-Kotlin">// “动态”的 DSL 配置，基于 Kotlin Lambda 和 Groovy Closure 
bundleTool {
    enableByVariant { variant, feature -&gt;
        !(variant.name.contains("debug", true) &amp;&amp; feature == BundleToolFeature.GET_SIZE)
    }
    ...
} 
</code></pre><p>其中 <code class="language-plaintext highlighter-rouge">variant</code> 参数是 <code class="language-plaintext highlighter-rouge">com.android.build.api.variant.Variant</code>，即我们平时使用的 Variant API v2 的 Variant 对象；<code class="language-plaintext highlighter-rouge">feature</code> 参数是一个自定义的 enum 类，方便每个插件定制。然后我们看下实现：</p><pre><code class="language-Kotlin">/**
 * Extract `enableByVariant(...)` function, can be reused in other plugins.
 * Currently the Lambda and Closure are defined by raw types, they can be encapsulated
 * by [Property] as well to fulfill "lazily produced/consumed" purpose.
 */
abstract class EnableByFeatureExtension&lt;T&gt; {

    var kotlinEnableByVariant: EnableByVariant&lt;T&gt;? = null

    var groovyEnableByVariant: Closure&lt;Boolean&gt;? = null

    // For Gradle Kotlin DSL
    fun enableByVariant(selector: EnableByVariant&lt;T&gt;) {
        kotlinEnableByVariant = selector
    }

    // For Gradle Groovy DSL
    fun enableByVariant(selector: Closure&lt;Boolean&gt;) {
        groovyEnableByVariant = selector.dehydrate()
    }

    internal fun isFeatureEnabled(variant: Variant, t: T): Boolean = when {
        kotlinEnableByVariant != null -&gt; {
            kotlinEnableByVariant!!.invoke(variant, t)
        }
        groovyEnableByVariant != null -&gt; {
            groovyEnableByVariant!!.call(variant, t)
        }
        else -&gt; false
    }

}

internal typealias EnableByVariant&lt;T&gt; = (variant: Variant, t: T) -&gt; Boolean

abstract class BundleToolExtension: EnableByFeatureExtension&lt;BundleToolFeature&gt;() {

    abstract val buildApks: NamedDomainObjectContainer&lt;BuildApksRule&gt;

    abstract val getSize: NamedDomainObjectContainer&lt;GetSizeRule&gt;

}

enum class BundleToolFeature {

    // It's currently a predecessor for GET_SIZE,
    // and the first job that plugin does,
    // disable it will cause the task registry got removed.
    // The work action that transforms .aab to .apks using `build-apks` command.
    BUILD_APKS,

    // The work action that gets the transformed .apks file size using `get-size total` command.
    GET_SIZE

}
</code></pre><p>这里我们分别定义了针对 Groovy 和 Kotlin 两种 Gradle DSL 的 Closure/Lambda，它们接受 <code class="language-plaintext highlighter-rouge">Variant</code> 和自定义的一个泛型参数，返回一个 Boolean 值表示是否开启对应功能。接着我们定义了 <code class="language-plaintext highlighter-rouge">isFeatureEnabled(..,): Boolean</code> 方法对两个语言分支进行整合，方便插件内部的调用。当实际使用该 <code class="language-plaintext highlighter-rouge">EnableByFeatureExtension</code> 时，实际上我们会让插件的 <code class="language-plaintext highlighter-rouge">BundleToolExtension</code> 继承于它，从而隔离出插件本体功能和通用的开关特性，任意其他的插件可以方便地拷走这个类加入到自己的 Extension 中。</p><pre><code class="language-Kotlin">androidExtension.onVariants { variant -&gt;
    if (!config.isFeatureEnabled(variant, BundleToolFeature.BUILD_APKS)) {
        return@onVariants
    }
    val featureGetSize = config.isFeatureEnabled(variant, BundleToolFeature.GET_SIZE)
    ...
    val buildApksTaskProvider = project.tasks.register&lt;BundleToolTask&gt;(
        "TransformApksFromBundleFor${variantName}"
    ) {
        enableGetSizeFeature = featureGetSize
        ...
    }
}

abstract class BundleToolTask : DefaultTask() {

    @get:Input
    var enableGetSizeFeature: Boolean = false
    ...
    
    @TaskAction
    fun transform() {
        ...
        if (!enableGetSizeFeature) return
    }
}
</code></pre><p>最后，我们展示了在两个地方使用这个开关的例子：</p><ol><li>如果某个 Feature 影响的是整个 Task，我们可以使用开关跳过它的注册。</li><li>如果某个 Feature 只影响了一个 Task 内的部分功能，我们将开关的值传入 Task 内部再进行判断。</li></ol><p>上述的流程并非完全不可变，这个思路可以结合其他的开关方式进行调整。目前我已经在 <a href="https://github.com/2BAB/bundle-tool-gradle-plugin">bundle-tool-gradle-plugin</a> 和 <a href="https://github.com/2BAB/ScratchPaper">ScratchPaper</a> 使用了这个方案，让插件功能的引入更加灵活。</p><p><strong>当然，你可能也已经发现，这个方案其实是从插件开发的角度入手，除非所有的插件开发者都使用了类似的方案进行优化，否则方案 3 仍然是从用户角度出发的目前唯一的通用办法。但是这个方案的优势在于控制粒度更精细、也更方便，开发者可以任意定制。</strong></p><h2 id="总结">总结</h2><p>本文主要讨论了插件功能根据不同 Variant 渠道进行开启的解决方案，可能也是全网第一次有如此详细和完整的多种方案对比讨论。文章的思考和方案其实还可以被运用到其他的一些 Gradle 场景中，大家可以自行发挥想象。那 2021 年的最后一篇技术文章就到这边啦，咱们明年再见。</p><p><em>欢迎关注我的<a href="/about"> Github / 公众号 / 播客 / 微博 / Twitter</a>。</em></p><span class="meta"><time datetime="2021-12-21T00:00:00+00:00">December 21, 2021</time> &middot; <a href="/tag/Android">Android</a>, <a href="/tag/Gradle">Gradle</a>, <a href="/tag/Android Gradle Plugin">Android Gradle Plugin</a>, <a href="/tag/构建">构建</a></span> <!--<span class="meta"><time datetime="2021-12-21T00:00:00+00:00">December 21, 2021</time> &middot; <a class="post" href="/tag/Android">Android</a>, <a class="post" href="/tag/Gradle">Gradle</a>, <a class="post" href="/tag/Android Gradle Plugin">Android Gradle Plugin</a>, <a class="post" href="/tag/构建">构建</a></span> --></section></main></body><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91072395-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-91072395-1'); </script></html>
